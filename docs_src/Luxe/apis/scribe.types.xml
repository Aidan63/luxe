<haxe>
	<class path="ApplicationMain" params="" file="bin/mac64/cpp/haxe/ApplicationMain.hx">
		<_main_ public="1" static="1"><c path="Main"/></_main_>
		<_core public="1" static="1"><c path="luxe.Core"/></_core>
		<_lime public="1" static="1"><c path="lime.Lime"/></_lime>
		<main public="1" set="method" line="12" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</main>
	</class>
	<class path="Array" params="T" file="/usr/lib/haxe/std/Array.hx" extern="1">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.

		This operation does not modify `this` Array.

		If `a` is the empty Array `[]`, a copy of `this` Array is returned.

		The length of the returned Array is equal to the sum of `this.length`
		and `a.length`.

		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` is the empty Array `[]`, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this.length` will decrease by 1.

		If `this` is the empty Array `[]`, null is returned and the length
		remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the new
		length of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of `this` Array.

		This operation modifies `this` Array in place.

		If `this.length < 2`, `this` remains unchanged.]]></haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the first element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.

		If `this` is the empty Array `[]`, `null` is returned and the length
		remains 0.</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.

		This operation does not modify `this` Array.

		The elements are not copied and retain their identity.

		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.

		If `pos` or `end` are negative, their offsets are calculated from the
		end	of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.

		If `pos` exceeds `this.length` or if `end` exceeds or equals `pos`,
		the result is `[]`.</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.

		This operation modifies `this` Array in place.

		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.sort.MergeSort.sort()` can be used instead.

		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.

		This operation modifies `this` Array in place.

		If `len` is < 0 or `pos` exceeds `this`.length, the result is the empty
		Array [].

		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.

		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Array.

		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use Std.string() to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element `x` at the position `pos`.

		This operation modifies `this` Array in place.

		The offset is calculated like so:

		- If `pos` exceeds `this.length`, the offset is `this.length`.
		- If `pos` is negative, the offset is calculated from the end of `this`
		  Array, i.e. `this.length + pos`. If this yields a negative value, the
		  offset is 0.
		- Otherwise, the offset is `pos`.

		If the resulting offset does not exceed `this.length`, all elements from
		and including that offset to the end of `this` Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurence of `x` in `this` Array.

		This operation modifies `this` Array in place.

		If `x` is found by checking standard equality, it is removed from `this`
		Array and all following elements are reindexed acoordingly. The function
		then returns true.

		If `x` is not found, `this` Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<indexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the first occurense of `x` in `this` Array, searching front to back.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with zero index. If it is negative, it will be taken as the
		offset from the end of `this` Array to compute the starting index. If given or computed
		starting index is less than 0, the whole array will be searched, if it is greater than
		or equal to the length of `this` Array, the function returns -1.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the last occurense of `x` in `this` Array, searching back to front.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with the last element index. If it is negative, it will be
		taken as the offset from the end of `this` Array to compute the starting index. If
		given or computed starting index is greater than or equal to the length of `this` Array,
		the whole array will be searched, if it is less than 0, the function returns -1.</haxe_doc>
		</lastIndexOf>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of `this` Array.

		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However,
		`a == a.copy()` is always false.</haxe_doc>
		</copy>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<map public="1" params="S" set="method">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<c path="map.S"/>
				</f>
				<c path="Array"><c path="map.S"/></c>
			</f>
			<haxe_doc>Creates a new Array by applying function `f` to all elements of `this`.

		The order of elements is preserved.

		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<filter public="1" set="method">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<x path="Bool"/>
				</f>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns an Array containing those elements of `this` for which `f`
		returned true.

		The individual elements are not duplicated and retain their identity.

		If `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API.</haxe_doc>
	</class>
	<abstract path="Class" params="T" file="/usr/lib/haxe/std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="cpp.Lib" params="" file="/usr/lib/haxe/std/cpp/Lib.hx">
		<load public="1" set="method" line="29" static="1">
			<f a="lib:prim:nargs">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>Load and return a Cpp primitive from a DLL library.</haxe_doc>
		</load>
		<loadLazy public="1" set="method" line="48" static="1">
			<f a="lib:prim:nargs">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>Tries to load, and always returns a valid function, but the function may throw
		if called.</haxe_doc>
		</loadLazy>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="EReg" params="" file="/usr/lib/haxe/std/cpp/_std/EReg.hx">
		<regexp_new_options line="174" static="1"><f a=":">
	<c path="String"/>
	<c path="String"/>
	<d/>
</f></regexp_new_options>
		<regexp_match line="175" static="1"><f a=":::">
	<d/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></regexp_match>
		<regexp_matched_pos line="177" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<a>
		<pos><x path="Int"/></pos>
		<len><x path="Int"/></len>
	</a>
</f></regexp_matched_pos>
		<r><d/></r>
		<last><c path="String"/></last>
		<global><x path="Bool"/></global>
		<match public="1" set="method" line="36">
			<f a="s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `this` regular expression matches String `s`.

		This method modifies the internal state.

		If `s` is `null`, the result is unspecified.</haxe_doc>
		</match>
		<replace public="1" set="method" line="98">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replaces the first substring of `s` which `this` EReg matches with `by`.

		If `this` EReg does not match any substring, the result is `s`.

		By default, this method replaces only the first matched substring. If
		the global g modifier is in place, all matched substrings are replaced.

		If `by` contains `$1` to `$9`, the digit corresponds to number of a
		matched sub-group and its value is used instead. If no such sub-group
		exists, the replacement is unspecified. The string `$$` becomes `$`.

		If `s` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<new public="1" set="method" line="28">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new regular expression with pattern `r` and modifiers `opt`.

		This is equivalent to the shorthand syntax `~/r/opt`

		If `r` or `opt` are null, the result is unspecified.</haxe_doc>
		</new>
		<haxe_doc>The EReg class represents regular expressions.

	While basic usage and patterns consistently work across platforms, some more
	complex operations may yield different results. This is a necessary trade-
	off to retain a certain level of performance.

	EReg instances can be created by calling the constructor, or with the
	special syntax ~/pattern/modifier

	EReg instances maintain an internal state, which is affected by several of
	its methods.

	A detailed explanation of the supported operations is available at
	http://haxe.org/doc/cross/regexp</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Enum" params="T" file="/usr/lib/haxe/std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="/usr/lib/haxe/std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<class path="Lambda" params="" file="/usr/lib/haxe/std/Lambda.hx">
		<array public="1" params="A" set="method" line="42" static="1">
			<f a="it">
				<t path="Iterable"><c path="array.A"/></t>
				<c path="Array"><c path="array.A"/></c>
			</f>
			<haxe_doc>Creates an Array from Iterable `it`.

		If `it` is an Array, this function returns a copy of it.</haxe_doc>
		</array>
		<has public="1" params="A" set="method" line="98" static="1">
			<f a="it:elt">
				<t path="Iterable"><c path="has.A"/></t>
				<c path="has.A"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `it` contains `elt`.

		This function returns true as soon as an element is found which is equal
		to `elt` according to the `==` operator.

		If no such element is found, the result is false.</haxe_doc>
		</has>
		<count public="1" params="A" set="method" line="191" static="1">
			<f a="it:?pred" v=":null">
				<t path="Iterable"><c path="count.A"/></t>
				<f a="">
					<c path="count.A"/>
					<x path="Bool"/>
				</f>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the number of elements in `it` for which `pred` is true, or the
		total number of elements in `it` if `pred` is null.

		This function traverses all elements.</haxe_doc>
		</count>
		<indexOf public="1" params="T" set="method" line="217" static="1">
			<f a="it:v">
				<t path="Iterable"><c path="indexOf.T"/></t>
				<c path="indexOf.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of the first element `v` within Iterable `it`.

		This function uses operator `==` to check for equality.

		If `v` does not exist in `it`, the result is -1.</haxe_doc>
		</indexOf>
		<haxe_doc>The `Lambda` class is a collection of methods to support functional
	programming. It is ideally used with 'using Lambda' and then acts as an
	extension to Iterable types.

	On static platforms, working with the Iterable structure might be slower
	than performing the operations directly on known types, such as Array and
	List.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="List" params="T" file="/usr/lib/haxe/std/List.hx">
		<h><c path="Array"><d/></c></h>
		<q><c path="Array"><d/></c></q>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` List.</haxe_doc>
		</length>
		<add public="1" set="method" line="49">
			<f a="item">
				<c path="List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the end of `this` List.

		`this.length` increases by 1.</haxe_doc>
		</add>
		<iterator public="1" set="method" line="161">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>Returns an iterator on the elements of the list.</haxe_doc>
		</iterator>
		<new public="1" set="method" line="40">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It is optimized so that adding or removing an
	element does not imply copying the whole array content every time.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="Luxe" params="" file="/Users/sven/dev/luxe/luxe/Luxe.hx">
		<dt public="1" line="22" static="1">
			<x path="Float"/>
			<haxe_doc>The time the last frame took, this value can be altered or fixed using `Luxe.timescale` or `Luxe.fixed_timestep`</haxe_doc>
		</dt>
		<timescale public="1" line="24" static="1">
			<x path="Float"/>
			<haxe_doc>The scale of time that affects the update rates and deltas</haxe_doc>
		</timescale>
		<fixed_timestep public="1" line="26" static="1">
			<x path="Float"/>
			<haxe_doc>Set this for a fixed timestep value</haxe_doc>
		</fixed_timestep>
		<mouse public="1" static="1">
			<t path="luxe.Vector"/>
			<haxe_doc>The last known mouse position</haxe_doc>
		</mouse>
		<core public="1" static="1">
			<c path="luxe.Core"/>
			<haxe_doc>Direct access to the core engine</haxe_doc>
		</core>
		<debug public="1" static="1">
			<c path="luxe.Debug"/>
			<haxe_doc>Access to the core debug features</haxe_doc>
		</debug>
		<draw public="1" static="1">
			<c path="luxe.Draw"/>
			<haxe_doc>Access to the drawing features</haxe_doc>
		</draw>
		<audio public="1" static="1">
			<c path="luxe.Audio"/>
			<haxe_doc>Access to the audio features</haxe_doc>
		</audio>
		<timer public="1" static="1">
			<c path="luxe.Timer"/>
			<haxe_doc>Access to the timing features</haxe_doc>
		</timer>
		<events public="1" static="1">
			<c path="luxe.Events"/>
			<haxe_doc>Access to the global event system</haxe_doc>
		</events>
		<input public="1" static="1">
			<c path="luxe.Input"/>
			<haxe_doc>Access to the input features</haxe_doc>
		</input>
		<scene public="1" static="1">
			<c path="luxe.Scene"/>
			<haxe_doc>Access to the default luxe scene</haxe_doc>
		</scene>
		<utils public="1" static="1">
			<c path="luxe.utils.Utils"/>
			<haxe_doc>Access to the different utilities</haxe_doc>
		</utils>
		<physics public="1" static="1">
			<c path="luxe.Physics"/>
			<haxe_doc>Access to the physics bindings, if any</haxe_doc>
		</physics>
		<camera public="1" static="1">
			<c path="luxe.Camera"/>
			<haxe_doc>Access to the default camera</haxe_doc>
		</camera>
		<resources public="1" static="1">
			<c path="luxe.ResourceManager"/>
			<haxe_doc>Access to the default resource manager</haxe_doc>
		</resources>
		<renderer public="1" static="1">
			<c path="phoenix.Renderer"/>
			<haxe_doc>Access to the rendering system</haxe_doc>
		</renderer>
		<time public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>The current time in seconds, highest precision from the platform</haxe_doc>
		</time>
		<screen public="1" get="accessor" set="null" static="1">
			<c path="luxe.Screen"/>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>Access to information about the game window (sizes, cursor etc)</haxe_doc>
		</screen>
		<get_screen set="method" line="63" static="1"><f a=""><c path="luxe.Screen"/></f></get_screen>
		<get_time set="method" line="69" static="1"><f a=""><x path="Float"/></f></get_time>
		<shutdown public="1" set="method" line="76" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>shutdown the engine and quit</haxe_doc>
		</shutdown>
		<showConsole public="1" set="method" line="83" static="1">
			<f a="_show">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>show/hide the debug console programmatically</haxe_doc>
		</showConsole>
		<loadText public="1" set="method" line="90" static="1">
			<f a="_id:?_onloaded" v=":null">
				<c path="String"/>
				<f a="">
					<c path="luxe.TextResource"/>
					<x path="Void"/>
				</f>
				<c path="luxe.TextResource"/>
			</f>
			<haxe_doc>Load a text resource</haxe_doc>
		</loadText>
		<loadData public="1" set="method" line="104" static="1">
			<f a="_id:?_onloaded" v=":null">
				<c path="String"/>
				<f a="">
					<c path="luxe.DataResource"/>
					<x path="Void"/>
				</f>
				<c path="luxe.DataResource"/>
			</f>
			<haxe_doc>Load a bytes/data resource</haxe_doc>
		</loadData>
		<loadSound public="1" set="method" line="118" static="1">
			<f a="_name:_id:?_is_music:?_onloaded" v="::false:null">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<f a="">
					<c path="luxe.SoundResource"/>
					<x path="Void"/>
				</f>
				<c path="luxe.SoundResource"/>
			</f>
			<haxe_doc>Load a sound resource</haxe_doc>
		</loadSound>
		<loadTexture public="1" set="method" line="133" static="1">
			<f a="_id:?_onloaded:?_silent:?_asset_bytes" v=":null:false:null">
				<c path="String"/>
				<f a="">
					<c path="phoenix.Texture"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<t path="lime.utils.ByteArray"/>
				<c path="phoenix.Texture"/>
			</f>
			<haxe_doc>Load a texture/image resource</haxe_doc>
		</loadTexture>
		<loadTextures public="1" set="method" line="140" static="1">
			<f a="_ids:?_onloaded:?_silent" v=":null:false">
				<c path="Array"><c path="String"/></c>
				<f a="">
					<c path="Array"><c path="phoenix.Texture"/></c>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Load multiple texture/image resources, useful for preloading</haxe_doc>
		</loadTextures>
		<loadFont public="1" set="method" line="147" static="1">
			<f a="_id:?_path:?_onloaded" v=":null:null">
				<c path="String"/>
				<c path="String"/>
				<f a="">
					<c path="phoenix.BitmapFont"/>
					<x path="Void"/>
				</f>
				<c path="phoenix.BitmapFont"/>
			</f>
			<haxe_doc>Load a font resource</haxe_doc>
		</loadFont>
		<loadShader public="1" set="method" line="154" static="1">
			<f a="?_ps_id:?_vs_id:?_onloaded" v="'default':'default':null">
				<c path="String"/>
				<c path="String"/>
				<f a="">
					<c path="phoenix.Shader"/>
					<x path="Void"/>
				</f>
				<c path="phoenix.Shader"/>
			</f>
			<haxe_doc>Load a shader resource</haxe_doc>
		</loadShader>
		<openURL public="1" set="method" line="163" static="1">
			<f a="_url">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Open the system browser with the given URL</haxe_doc>
		</openURL>
		<fileDialogFolder public="1" set="method" line="170" static="1">
			<f a="_title:_text">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Open the system folder dialog picker</haxe_doc>
		</fileDialogFolder>
		<fileDialogOpen public="1" set="method" line="177" static="1">
			<f a="_title:_text">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Open the system file open dialog picker</haxe_doc>
		</fileDialogOpen>
		<fileDialogSave public="1" set="method" line="184" static="1">
			<f a="_title:_text">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Open the system file save dialog picker</haxe_doc>
		</fileDialogSave>
		<addGeometry public="1" set="method" line="193" static="1">
			<f a="_geom">
				<c path="phoenix.geometry.Geometry"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Add geometry to the default batcher</haxe_doc>
		</addGeometry>
		<removeGeometry public="1" set="method" line="200" static="1">
			<f a="_geom">
				<c path="phoenix.geometry.Geometry"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Remove geometry to the default batcher</haxe_doc>
		</removeGeometry>
		<addGroup public="1" set="method" line="207" static="1">
			<f a="_group:?_pre_render:?_post_render" v=":null:null">
				<x path="Int"/>
				<f a="">
					<c path="phoenix.Batcher"/>
					<x path="Void"/>
				</f>
				<f a="">
					<c path="phoenix.Batcher"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Add a geometry group to the default batcher</haxe_doc>
		</addGroup>
		<createBatcher public="1" set="method" line="214" static="1">
			<f a="?_name:?_camera:?_add" v="'batcher':null:true">
				<c path="String"/>
				<c path="luxe.Camera"/>
				<x path="Bool"/>
				<c path="phoenix.Batcher"/>
			</f>
			<haxe_doc>Create a batcher, convenience for create batcher, add batcher, and create camera for the batcher.</haxe_doc>
		</createBatcher>
	</class>
	<class path="luxe.Game" params="" file="/Users/sven/dev/luxe/luxe/luxe/Game.hx">
		<luxecore public="1"><c path="luxe.Core"/></luxecore>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<meta><m n=":noCompletion"/></meta>
	</class>
	<class path="Main" params="" file="src/Main.hx">
		<extends path="luxe.Game"/>
		<delta_time_text public="1"><c path="luxe.Text"/></delta_time_text>
		<ready public="1" set="method" line="15"><f a=""><x path="Void"/></f></ready>
		<onkeyup public="1" set="method" line="27"><f a="e">
	<t path="luxe.KeyEvent"/>
	<x path="Void"/>
</f></onkeyup>
		<update public="1" set="method" line="36"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<destroyed public="1" set="method" line="43"><f a=""><x path="Void"/></f></destroyed>
		<new public="1" set="method" line="9"><f a=""><x path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<abstract path="Map" params="K:V" file="/usr/lib/haxe/std/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><c path="IMap">
	<c path="Map.K"/>
	<c path="Map.V"/>
</c></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="Map.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="Map.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="Map.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="Map.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.

	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.

	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.

	Maps can also be created with `key1 => value1, key2 => value2` syntax.

	Map is an abstract type, it is not available at runtime.]]></haxe_doc>
		<meta><m n=":multiType"><e>K</e></m></meta>
		<impl><class path="_Map.Map_Impl_" params="" file="/usr/lib/haxe/std/Map.hx" private="1" module="Map"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="_Map.Map_Impl_" params="" file="/usr/lib/haxe/std/Map.hx" private="1" module="Map"><meta><m n=":keep"/></meta></class>
	<class path="IMap" params="K:V" file="/usr/lib/haxe/std/Map.hx" module="Map" interface="1">
		<iterator public="1" set="method"><f a=""><t path="Iterator"><c path="IMap.V"/></t></f></iterator>
		<meta><m n=":keep"/></meta>
	</class>
	<typedef path="_Map.Hashable" params="" file="/usr/lib/haxe/std/Map.hx" private="1" module="Map"><a><hashCode set="method"><f a=""><x path="Int"/></f></hashCode></a></typedef>
	<class path="Math" params="" file="/usr/lib/haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>Represents the ratio of the circumference of a circle to its diameter, 
		specified by the constant, π. `PI` is approximately 3.141592653589793.</haxe_doc>
		</PI>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes negative infinity.

		For example, this is the result of -1.0 / 0.0.

		Operations with NEGATIVE_INFINITY as an operand may result in
		NEGATIVE_INFINITY, POSITIVE_INFINITY or NaN. 

		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.</haxe_doc>
		</NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes negative infinity.

		For example, this is the result of 1.0 / 0.0.

		Operations with POSITIVE_INFINITY as an operand may result in
		NEGATIVE_INFINITY, POSITIVE_INFINITY or NaN. 

		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.</haxe_doc>
		</POSITIVE_INFINITY>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes an invalid number.

		NaN stands for "Not a Number". It occurs when a mathematically incorrect
		operation is executed, such as taking the square root of a negative
		number: Math.sqrt(-1).

		All further operations with NaN as an operand will result in NaN.

		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.

		In order to test if a value is NaN, you should use Math.isNaN() function.

		@php In PHP versions prior to 5.3.1 VC 9 there may be unexpected
		results when performing arithmetic operations with NaN on Windows, 
		see [https://bugs.php.net/bug.php?id=42143]</haxe_doc>
		</NaN>
		<abs public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of `v`.

		If `v` is positive or 0, the result is unchanged. Otherwise the result 
		is -`v`.
		
		If `v` is NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is 
		POSITIVE_INFINITY.
		
		If `v` is NaN, the result is NaN.</haxe_doc>
		</abs>
		<min public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smaller of values `a` and `b`.

		If `a` or `b` are NaN, the result is NaN.
		If `a` or `b` are NEGATIVE_INFINITY, the result is NEGATIVE_INFINITY.
		If `a` and `b` are POSITIVE_INFINITY, the result is POSITIVE_INFINITY.</haxe_doc>
		</min>
		<max public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the greater of values `a` and `b`.

		If `a` or `b` are NaN, the result is NaN.
		If `a` or `b` are POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		If `a` and `b` are NEGATIVE_INFINITY, the result is NEGATIVE_INFINITY.</haxe_doc>
		</max>
		<sin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric sine of the specified angle `v`, in radians.
		
		If `v` is NaN or infinite, the result is NaN.</haxe_doc>
		</sin>
		<cos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric cosine of the specified angle `v`, in radians.
		
		If `v` is NaN or infinite, the result is NaN.</haxe_doc>
		</cos>
		<tan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric tangent of the specified angle `v`, in radians.
		
		If `v` is NaN or infinite, the result is NaN.</haxe_doc>
		</tan>
		<asin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc of the specified angle `v`, in radians.
		
		If `v` is NaN or infinite, the result is NaN.</haxe_doc>
		</asin>
		<acos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc cosine of the specified angle `v`, 
		in radians.
		
		If `v` is NaN or infinite, the result is NaN.</haxe_doc>
		</acos>
		<atan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent of the specified angle `v`, 
		in radians.
		
		If `v` is NaN or infinite, the result is NaN.</haxe_doc>
		</atan>
		<atan2 public="1" set="method" static="1">
			<f a="y:x">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent whose tangent is the quotient of 
		two specified numbers, in radians.
		
		If parameter `x` or `y`  is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, 
		the result is NaN.</haxe_doc>
		</atan2>
		<exp public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns Euler's number, raised to the power of `v`.
		
		exp(1.0) is approximately 2.718281828459.
		
		If `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		If `v` is NEGATIVE_INFINITY, the result is 0.0.
		If `v` is NaN, the result is NaN.</haxe_doc>
		</exp>
		<log public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of `v`.
		
		This is the mathematical inverse operation of exp, 
		i.e. `log(exp(v)) == v` always holds.
		
		If `v` is negative (including NEGATIVE_INFINITY) or NaN, the result 
		is NaN.
		If `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		If `v` is 0.0, the result is NEGATIVE_INFINITY.</haxe_doc>
		</log>
		<pow public="1" set="method" static="1">
			<f a="v:exp">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns a specified base `v` raised to the specified power `exp`.</haxe_doc>
		</pow>
		<sqrt public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of `v`.
		
		If `v` is negative (including NEGATIVE_INFINITY) or NaN, the result 
		is NaN.
		If `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		If `v` is 0.0, the result is 0.0.</haxe_doc>
		</sqrt>
		<round public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value.
		
		If `v` is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY 
		or POSITIVE_INFINITY, the result is unspecified.</haxe_doc>
		</round>
		<floor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`.

		If `v` is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY 
		or POSITIVE_INFINITY, the result is unspecified.</haxe_doc>
		</floor>
		<ceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`.

		If `v` is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY 
		or POSITIVE_INFINITY, the result is unspecified.</haxe_doc>
		</ceil>
		<random public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a pseudo-random number which is greater than or equal to 0.0, 
		and less than 1.0.</haxe_doc>
		</random>
		<ffloor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`, as a Float.

		If `v` is is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, 
		the result is unspecified.</haxe_doc>
		</ffloor>
		<fceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`, as a Float.

		If `v` is is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, 
		the result is unspecified.</haxe_doc>
		</fceil>
		<fround public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value, as a Float.

		If `v` is is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, 
		the result is unspecified.</haxe_doc>
		</fround>
		<isFinite public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is a finite number.

		If `f` is POSITIVE_INFINITY, NEGATIVE_INFINITY or NaN, the result 
		is false, otherwise the result is true.</haxe_doc>
		</isFinite>
		<isNaN public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is not a valid number.

		If `f` is NaN, the result is true, otherwise the result is false. 
		In particular, both POSITIVE_INFINITY and NEGATIVE_INFINITY are
		not considered NaN.</haxe_doc>
		</isNaN>
		<haxe_doc>This class defines mathematical functions and constants.</haxe_doc>
		<meta><m n=":include"><e>"hxMath"</e></m></meta>
	</class>
	<class path="Reflect" params="" file="/usr/lib/haxe/std/cpp/_std/Reflect.hx">
		<hasField public="1" set="method" line="24" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if structure `o` has a field named `field`.

		This is only guaranteed to work for anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</hasField>
		<field public="1" set="method" line="28" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the value of the field named `field` on object `o`.

		If `o` is not an object or has no field named `field`, the result is
		null.

		If the field is defined as a property, its accessors are ignored. Refer
		to `Reflect.getProperty` for a function supporting property accessors.

		If `field` is null, the result is unspecified.

		(As3) If used on a property field, the getter will be invoked. It is
		not possible to obtain the value directly.</haxe_doc>
		</field>
		<callMethod public="1" set="method" line="46" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>Call a method with the given object and arguments.</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="53" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the fields of structure `o`.

		This method is only guaranteed to work on anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` is null, the result is unspecified.</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="60" static="1">
			<f a="f">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if `f` is a function, false otherwise.

		If `f` is null, the result is false.</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" line="64" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Compares `a` and `b`.

		If `a` is less than `b`, the result is negative. If `b` is less than
		`a`, the result is positive. If `a` and `b` are equal, the result is 0.

		This function is only defined if `a` and `b` are of the same type.

		If that type is a function, the result is unspecified and
		`Reflect.compareMethods` should be used instead.

		For all other types, the result is 0 if `a` and `b` are equal. If they
		are not equal, the result depends on the type and is negative if:

		- Numeric types: a is less than b
		- String: a is lexicographically less than b
		- Other: unspecified

		If `a` and `b` are null, the result is 0. If only one of them is null,
		the result is unspecified.</haxe_doc>
		</compare>
		<isObject public="1" set="method" line="76" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[Tells if `v` is an object.

		The result is true if `v` is one of the following:

		- class instance
		- structure
		- Class<T>
		- Enum<T>

		Otherwise, including if `v` is null, the result is false.]]></haxe_doc>
		</isObject>
		<isEnumValue public="1" set="method" line="83" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `v` is an enum value.

		The result is true if `v` is of type EnumValue, i.e. an enum
		constructor.

		Otherwise, including if `v` is null, the result is false.</haxe_doc>
		</isEnumValue>
		<haxe_doc>The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Std" params="" file="/usr/lib/haxe/std/cpp/_std/Std.hx">
		<is public="1" set="method" line="23" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Tells if a value v is of the type t. Returns false if v or t are null.</haxe_doc>
		</is>
		<instance public="1" params="T:S" set="method" line="27" static="1">
			<f a="value:c">
				<c path="instance.T"/>
				<x path="Class"><c path="instance.S"/></x>
				<c path="instance.S"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Checks if object `value` is an instance of class `c`.

		Compiles only if the class specified by `c` can be assigned to the type
		of `value`.

		This method checks if a downcast is possible. That is, if the runtime
		type of `value` is assignable to the class specified by `c`, `value` is
		returned. Otherwise null is returned.

		This method is not guaranteed to work with interfaces or core types such
		as String, Array and Date.

		If `value` is null, the result is null. If `c` is null, the result is
		unspecified.</haxe_doc>
		</instance>
		<string public="1" set="method" line="31" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<int public="1" set="method" line="35" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Converts a `Float` to an `Int`, rounded towards 0.

		If `x` is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="39" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Converts a `String` to an `Int`.

		Leading whitespaces are ignored.

		If `x` starts with 0x or 0X, hexadecimal notation is recognized where the following digits may
		contain 0-9 and A-F.

		Otherwise `x` is read as decimal number with 0-9 being allowed characters. `x` may also start with
		a - to denote a negative value.

		In decimal mode, parsing continues until an invalid character is detected, in which case the
		result up to that point is returned. For hexadecimal notation, the effect of invalid characters
		is unspecified.

		Leading 0s that are not part of the 0x/0X hexadecimal notation are ignored, which means octal
		notation is not supported.

		If the input cannot be recognized, the result is null.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="43" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Converts a `String` to a `Float`.

		The parsing rules for `parseInt` apply here as well, with the exception of invalid input
		resulting in a NaN value instead of null.

		Additionally, decimal notation may contain a single `.` to denote the start of the fractions.</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="47" static="1">
			<f a="x">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc><![CDATA[Return a random integer between 0 included and `x` excluded.

		If `x <= 1`, the result is always 0.]]></haxe_doc>
		</random>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard Void type. Only `null` values can be of the type `Void`.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard Float type, this is a double-precision IEEE 64bit float.

	On static targets, null cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard Int type. Its precision depends on the platform.

	On static targets, null cannot be assigned to Int. If this is necessary,
	`Null<Int>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Null" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>`Null` can be useful in two cases. In order to document some methods
	that accepts or can return a `null` value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.</haxe_doc>
	</typedef>
	<abstract path="Bool" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be true or false.

	On static targets, null cannot be assigned to Bool. If this is necessary,
	`Null<Bool>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>Dynamic is a special type which is compatible with all other types.

	Use of Dynamic should be minimized as it prevents several compiler
	checks and optimizations.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the Iterator and advances to the next one.

		This method is not required to check hasNext() first. A call to this
		method while hasNext() is false yields unspecified behavior.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns false if the iteration is complete, true otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to next(). However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An Iterator is a structure that permits iteration over elements of type T.

	Any class with matching hasNext and next fields is considered an Iterator
	and can then be used e.g. in for-loops. This makes it easy to implement
	custom iterators.</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An Iterable is a data structure which has an iterator() method.
	See `Lambda` for generic functions on iterable structures.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.</haxe_doc></class>
	<class path="String" params="" file="/usr/lib/haxe/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.

		Affects the characters `a-z`. Other characters remain unchanged.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.

		Affects the characters `A-Z`. Other characters remain unchanged.</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String ""
		is returned.</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, null is returned.

		To obtain the character code of a single character, "x".code can be used
		instead to inline the character code at compile time. Note that this
		only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurence of `delimiter`.

		If `this` String is the empty String "", the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String "", `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurence of
		`delimiter`. If `this` String starts (or ends) with [delimiter}, the
		result Array contains a leading (or trailing) empty String "" element.
		Two subsequent delimiters also result in an empty String "" element.</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String "" is returned.</haxe_doc>
		</substring>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the string literal syntax "string value".

	String can be concatenated by using the + operator. If an operand is not a
	String, it is passed through Std.string() first.</haxe_doc>
	</class>
	<class path="StringBuf" params="" file="/usr/lib/haxe/std/cpp/_std/StringBuf.hx">
		<b><c path="Array"><c path="String"/></c></b>
		<add public="1" params="T" set="method" line="40">
			<f a="x">
				<c path="add.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends the representation of `x` to `this` StringBuf.

		The exact representation of `x` may vary per platform. To get more
		consistent behavior, this function should be called with
		Std.string(x).

		If `x` is null, the String "null" is appended.</haxe_doc>
		</add>
		<addChar public="1" get="inline" set="null" line="48">
			<f a="c">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends the character identified by `c` to `this` StringBuf.

		If `c` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</addChar>
		<new public="1" set="method" line="29">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringBuf instance.

		This may involve initialization of the internal buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by appending small
	elements together.

	Its cross-platform implementation uses String concatenation internally, but
	StringBuf may be optimized for different targets.

	Unlike String, an instance of StringBuf is not immutable in the sense that
	it can be passed as argument to functions which modify it by appending more
	values. However, the internal buffer cannot be modified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="StringTools" params="" file="/usr/lib/haxe/std/StringTools.hx">
		<isSpace public="1" set="method" line="165" static="1">
			<f a="s:pos">
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the character in the string `s` at position `pos` is a space.

		A character is considered to be a space character if its character code
		is 9,10,11,12,13 or 32.

		If `s` is the empty String "", or if pos is not a valid position within
		`s`, the result is false.</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="179" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading space characters of `s`.

		This function internally calls isSpace() to decide which characters to
		remove.

		If `s` is the empty String "" or consists only of space characters, the
		result is the empty String "".</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="204" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes trailing space characters of `s`.

		This function internally calls isSpace() to decide which characters to
		remove.

		If `s` is the empty String "" or consists only of space characters, the
		result is the empty String "".</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="226" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading and trailing space characters of `s`.

		This is a convenience function for ltrim(rtrim(s)).</haxe_doc>
		</trim>
		<replace public="1" set="method" line="291" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replace all occurences of the String `sub` in the String `s` by the
		String `by`.

		If `sub` is the empty String "", `by` is inserted after each character
		of `s`. If `by` is also the empty String "", `s` remains unchanged.

		This is a convenience function for `s.split(sub).join(by)`.

		If `sub` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<hex public="1" set="method" line="313" static="1">
			<f a="n:?digits" v=":null">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes `n` into a hexadecimal representation.

		If `digits` is specified, the resulting String is padded with "0" until
		its length equals `digits`.</haxe_doc>
		</hex>
		<haxe_doc>This class provides advanced methods on Strings. It is ideally used with
	'using StringTools' and then acts as an extension to the String class.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="Sys" params="" file="/usr/lib/haxe/std/cpp/_std/Sys.hx">
		<print public="1" set="method" line="24" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print any value on the standard output.</haxe_doc>
		</print>
		<println public="1" set="method" line="28" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print any value on the standard output, followed by a newline</haxe_doc>
		</println>
		<sleep public="1" set="method" line="64" static="1">
			<f a="seconds">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Suspend the current execution for the given time (in seconds).</haxe_doc>
		</sleep>
		<_sleep line="136" static="1"><f a="">
	<x path="Float"/>
	<unknown/>
</f></_sleep>
		<haxe_doc>This class gives you access to many base functionalities of system platforms. Looks in [sys] sub packages for more system APIs.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Type" params="" file="/usr/lib/haxe/std/cpp/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="35" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<x path="Class"><c path="getClass.T"/></x>
			</f>
			<haxe_doc>Returns the class of `o`, if `o` is a class instance.

		If `o` is null or of a different type, null is returned.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" line="46" static="1">
			<f a="o">
				<x path="EnumValue"/>
				<x path="Enum"><d/></x>
			</f>
			<haxe_doc><![CDATA[Returns the enum of enum instance `o`.

		An enum instance is the result of using an enum constructor. Given an
		`enum Color { Red; }`, `getEnum(Red)` returns `Enum<Color>`.

		If `o` is null, null is returned.

		In general, type parameter information cannot be obtained at runtime.]]></haxe_doc>
		</getEnum>
		<getClassName public="1" set="method" line="56" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of class `c`, including its path.

		If `c` is inside a package, the package structure is returned dot-
		separated, with another dot separating the class name:
		`pack1.pack2.(...).packN.ClassName`
		If `c` is a sub-type of a haxe module, that module is not part of the
		package structure.

		If `c` has no package, the class name is returned.

		If `c` is null, the result is unspecified.

		The class name does not include any type parameters.</haxe_doc>
		</getClassName>
		<resolveClass public="1" set="method" line="66" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<haxe_doc>Resolves a class by name.

		If `name` is the path of an existing class, that class is returned.

		Otherwise null is returned.

		If `name` is null or the path to a different type, the result is
		unspecified.

		The class name must not include any type parameters.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="73" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Enum"><d/></x>
			</f>
			<haxe_doc>Resolves an enum by name.

		If `name` is the path of an existing enum, that enum is returned.

		Otherwise null is returned.

		If `name` is null the result is unspecified.

		If `name` is the path to a different type, null is returned.

		The enum name must not include any type parameters.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="80" static="1">
			<f a="cl:args">
				<x path="Class"><c path="createInstance.T"/></x>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`, using `args` as arguments to the
		class constructor.

		This function guarantees that the class constructor is called.

		Default values of constructors arguments are not guaranteed to be
		taken into account.

		If `cl` or `args` are null, or if the number of elements in `args` does
		not match the expected number of constructor arguments, or if any
		argument has an invalid type,  or if `cl` has no own constructor, the
		result is unspecified.

		In particular, default values of constructor arguments are not
		guaranteed to be taken into account.</haxe_doc>
		</createInstance>
		<getInstanceFields public="1" set="method" line="100" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the instance fields of class `c`.

		This only includes fields which are known at compile-time. In
		particular, using getInstanceFields(getClass(obj)) will not include
		any fields which were added to obj at runtime.

		The order of the fields in the returned Array is unspecified.

		If `c` is null, the result is unspecified.

		(As3) This method only returns instance fields that are public.</haxe_doc>
		</getInstanceFields>
		<enumConstructor public="1" set="method" line="132" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" line="136" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is [].

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumParameters>
		<haxe_doc>The haxe Reflection API allows retrieval of type information at runtime.

	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="cpp.vm.Mutex" params="" file="/usr/lib/haxe/std/cpp/vm/Mutex.hx">
		<m><d/></m>
		<acquire public="1" set="method" line="30"><f a=""><x path="Void"/></f></acquire>
		<release public="1" set="method" line="36"><f a=""><x path="Void"/></f></release>
		<new public="1" set="method" line="27"><f a=""><x path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<typedef path="cpp.vm.ThreadHandle" params="" file="/usr/lib/haxe/std/cpp/vm/Thread.hx" module="cpp.vm.Thread"><d/></typedef>
	<class path="cpp.vm.Thread" params="" file="/usr/lib/haxe/std/cpp/vm/Thread.hx">
		<current public="1" set="method" line="45" static="1">
			<f a=""><c path="cpp.vm.Thread"/></f>
			<haxe_doc>Returns the current thread.</haxe_doc>
		</current>
		<create public="1" set="method" line="52" static="1">
			<f a="callb">
				<f a=""><x path="Void"/></f>
				<c path="cpp.vm.Thread"/>
			</f>
			<haxe_doc>Creates a new thread that will execute the [callb] function, then exit.</haxe_doc>
		</create>
		<readMessage public="1" set="method" line="61" static="1">
			<f a="block">
				<x path="Bool"/>
				<d/>
			</f>
			<haxe_doc>Reads a message from the thread queue. If [block] is true, the function
		blocks until a message is available. If [block] is false, the function
		returns [null] if no message is available.</haxe_doc>
		</readMessage>
		<handle public="1" set="null"><t path="cpp.vm.ThreadHandle"/></handle>
		<sendMessage public="1" set="method" line="37">
			<f a="msg">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Send a message to the thread queue. This message can be readed by using [readMessage].</haxe_doc>
		</sendMessage>
		<new set="method" line="30"><f a="h">
	<t path="cpp.vm.ThreadHandle"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<typedef path="cpp.zip.Compress" params="" file="/usr/lib/haxe/std/cpp/zip/Compress.hx"><c path="haxe.zip.Compress"/></typedef>
	<typedef path="cpp.zip.Flush" params="" file="/usr/lib/haxe/std/cpp/zip/Flush.hx"><e path="haxe.zip.FlushMode"/></typedef>
	<typedef path="cpp.zip.Uncompress" params="" file="/usr/lib/haxe/std/cpp/zip/Uncompress.hx"><c path="haxe.zip.Uncompress"/></typedef>
	<enum path="format.png.Color" params="" file="/Users/sven/dev/haxelib/format/3,0,5/format/png/Data.hx" module="format.png.Data">
		<ColGrey a="alpha"><x path="Bool"/></ColGrey>
		<ColTrue a="alpha"><x path="Bool"/></ColTrue>
		<ColIndexed/>
	</enum>
	<typedef path="format.png.Header" params="" file="/Users/sven/dev/haxelib/format/3,0,5/format/png/Data.hx" module="format.png.Data"><a>
	<width><x path="Int"/></width>
	<interlaced><x path="Bool"/></interlaced>
	<height><x path="Int"/></height>
	<color><e path="format.png.Color"/></color>
	<colbits><x path="Int"/></colbits>
</a></typedef>
	<enum path="format.png.Chunk" params="" file="/Users/sven/dev/haxelib/format/3,0,5/format/png/Data.hx" module="format.png.Data">
		<CEnd/>
		<CHeader a="h"><t path="format.png.Header"/></CHeader>
		<CData a="b"><c path="haxe.io.Bytes"/></CData>
		<CPalette a="b"><c path="haxe.io.Bytes"/></CPalette>
		<CUnknown a="id:data">
			<c path="String"/>
			<c path="haxe.io.Bytes"/>
		</CUnknown>
	</enum>
	<typedef path="format.png.Data" params="" file="/Users/sven/dev/haxelib/format/3,0,5/format/png/Data.hx"><c path="List"><e path="format.png.Chunk"/></c></typedef>
	<class path="format.png.Reader" params="" file="/Users/sven/dev/haxelib/format/3,0,5/format/png/Reader.hx">
		<i><c path="haxe.io.Input"/></i>
		<checkCRC public="1"><x path="Bool"/></checkCRC>
		<read public="1" set="method" line="41"><f a=""><t path="format.png.Data"/></f></read>
		<readHeader set="method" line="56"><f a="i">
	<c path="haxe.io.Input"/>
	<t path="format.png.Header"/>
</f></readHeader>
		<readChunk set="method" line="91"><f a=""><e path="format.png.Chunk"/></f></readChunk>
		<new public="1" set="method" line="35"><f a="i">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="format.png.Tools" params="" file="/Users/sven/dev/haxelib/format/3,0,5/format/png/Tools.hx">
		<getHeader public="1" set="method" line="35" static="1">
			<f a="d">
				<t path="format.png.Data"/>
				<t path="format.png.Header"/>
			</f>
			<haxe_doc>Returns the PNG header informations. Throws an exception if no header found.</haxe_doc>
		</getHeader>
		<getPalette public="1" set="method" line="47" static="1">
			<f a="d">
				<t path="format.png.Data"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Return the PNG palette colors, or null if no palette chunk was found</haxe_doc>
		</getPalette>
		<filter get="inline" set="null" line="56" static="1"><f a="data:x:y:stride:prev:p:?numChannels" v="::::::4">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></filter>
		<reverseBytes public="1" set="method" line="69" static="1">
			<f a="b">
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Converts from BGRA to ARGB and the other way by reversing bytes.</haxe_doc>
		</reverseBytes>
		<extractGrey public="1" set="method" line="106" static="1">
			<f a="d">
				<t path="format.png.Data"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":noDebug"/></meta>
			<haxe_doc>Decode the greyscale PNG data and apply filters, extracting only the grey channel if alpha is present.</haxe_doc>
		</extractGrey>
		<extract32 public="1" set="method" line="205" static="1">
			<f a="d:?bytes" v=":null">
				<t path="format.png.Data"/>
				<c path="haxe.io.Bytes"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":noDebug"/></meta>
			<haxe_doc>Decode the PNG data and apply filters. By default this will output BGRA low-endian format. You can use the [reverseBytes] function to inverse the bytes to ARGB big-endian format.</haxe_doc>
		</extract32>
		<buildGrey public="1" set="method" line="584" static="1">
			<f a="width:height:data">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<t path="format.png.Data"/>
			</f>
			<haxe_doc>Creates PNG data from bytes that contains one bytes (grey values) for each pixel.</haxe_doc>
		</buildGrey>
		<buildRGB public="1" set="method" line="603" static="1">
			<f a="width:height:data">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<t path="format.png.Data"/>
			</f>
			<haxe_doc>Creates PNG data from bytes that contains three bytes (R,G and B values) for each pixel.</haxe_doc>
		</buildRGB>
		<build32ARGB public="1" set="method" line="626" static="1">
			<f a="width:height:data">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<t path="format.png.Data"/>
			</f>
			<haxe_doc>Creates PNG data from bytes that contains four bytes in ARGB format for each pixel.</haxe_doc>
		</build32ARGB>
		<build32BGRA public="1" set="method" line="650" static="1">
			<f a="width:height:data">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<t path="format.png.Data"/>
			</f>
			<haxe_doc>Creates PNG data from bytes that contains four bytes in BGRA format for each pixel.</haxe_doc>
		</build32BGRA>
	</class>
	<class path="format.tools.Deflate" params="" file="/Users/sven/dev/haxelib/format/3,0,5/format/tools/Deflate.hx"><run public="1" set="method" line="31" static="1"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></run></class>
	<class path="format.tools.Inflate" params="" file="/Users/sven/dev/haxelib/format/3,0,5/format/tools/Inflate.hx"><run public="1" set="method" line="31" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></run></class>
	<enum path="haxe.StackItem" params="" file="/usr/lib/haxe/std/haxe/CallStack.hx" module="haxe.CallStack">
		<CFunction/>
		<Module a="m"><c path="String"/></Module>
		<FilePos a="s:file:line">
			<t path="Null"><e path="haxe.StackItem"/></t>
			<c path="String"/>
			<x path="Int"/>
		</FilePos>
		<Method a="classname:method">
			<c path="String"/>
			<c path="String"/>
		</Method>
		<LocalFunction a="v"><x path="Int"/></LocalFunction>
		<haxe_doc>Elements return by `CallStack` methods.</haxe_doc>
	</enum>
	<class path="haxe.CallStack" params="" file="/usr/lib/haxe/std/haxe/CallStack.hx">
		<callStack public="1" set="method" line="43" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<haxe_doc>Return the call stack elements, or an empty array if not available.</haxe_doc>
		</callStack>
		<makeStack set="method" line="206" static="1">
			<f a="s">
				<c path="Array"><c path="String"/></c>
				<c path="Array"><e path="haxe.StackItem"/></c>
			</f>
			<meta><m n=":noStack"/></meta>
		</makeStack>
		<haxe_doc>Get informations about the call stack.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.EnumTools" params="" file="/usr/lib/haxe/std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="41" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
			pack1.pack2.(...).packN.EnumName
		If `e` is a sub-type of a haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is null, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="54" static="1">
			<f a="e:constr:?params" v="::null">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="70" static="1">
			<f a="e:index:?params" v="::null">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="87" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array [] if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="99" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is null, the result is unspecified.</haxe_doc>
		</getConstructors>
	</class>
	<class path="haxe.EnumValueTools" params="" file="/usr/lib/haxe/std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="114" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.

		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="125" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="139" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is [].

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="151" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getIndex>
	</class>
	<class path="haxe.Log" params="" file="/usr/lib/haxe/std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="45" static="1">
			<f a="v:?infos" v=":null">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Outputs `v` in a platform-dependent way.

		The second parameter `infos` is injected by the compiler and contains
		information about the position where the trace() call was made.

		This method can be rebound to a custom function:
			var oldTrace = haxe.Log.trace; // store old function
			haxe.Log.trace = function(v,infos) { // handle trace }
			...
			haxe.Log.trace = oldTrace;

		If it is bound to null, subsequent calls to trace() will cause an
		exception.</haxe_doc>
		</trace>
		<haxe_doc>Log primarily provides the trace() method, which is invoked upon a call to
	trace() in haxe code.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/usr/lib/haxe/std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<c path="Array"><d/></c>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>PosInfos is a magic type which can be used to generate position information
	into the output for debugging use.

	If a function has a final optional argument of this type, i.e.
	(..., ?pos:haxe.PosInfos), each call to that function which does not assign
	a value to that argument has its position added as call argument.

	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<class path="lime.utils.Libs" params="" file="/Users/sven/dev/lime/lime/utils/Libs.hx">
		<__moduleNames line="6" static="1">
			<x path="Map">
				<c path="String"/>
				<c path="String"/>
			</x>
			<meta><m n=":noCompletion"/></meta>
		</__moduleNames>
		<tryLoad set="method" line="12" static="1"><f a="name:library:func:args">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<d/>
</f></tryLoad>
		<findHaxeLib set="method" line="68" static="1"><f a="library">
	<c path="String"/>
	<c path="String"/>
</f></findHaxeLib>
		<sysName set="method" line="112" static="1"><f a=""><c path="String"/></f></sysName>
		<load public="1" set="method" line="163" static="1"><f a="library:method:?args" v="::0">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<d/>
</f></load>
		<loaderTrace set="method" line="227" static="1"><f a="message">
	<c path="String"/>
	<x path="Void"/>
</f></loaderTrace>
	</class>
	<class path="sys.io.Process" params="" file="/usr/lib/haxe/std/cpp/_std/sys/io/Process.hx">
		<_run line="123" static="1"><f a=":">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<unknown/>
</f></_run>
		<_close line="126" static="1"><f a="">
	<d/>
	<unknown/>
</f></_close>
		<p><d/></p>
		<stdout public="1" set="null"><c path="haxe.io.Input"/></stdout>
		<stderr public="1" set="null"><c path="haxe.io.Input"/></stderr>
		<stdin public="1" set="null"><c path="haxe.io.Output"/></stdin>
		<close public="1" set="method" line="115"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="100"><f a="cmd:args">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.io.Output" params="" file="/usr/lib/haxe/std/haxe/io/Output.hx">
		<writeByte public="1" set="method" line="38"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="42"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<close public="1" set="method" line="68"><f a=""><x path="Void"/></f></close>
		<writeFullBytes public="1" set="method" line="89"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></writeFullBytes>
		<writeString public="1" set="method" line="313"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></writeString>
		<haxe_doc>An Output is an abstract write. A specific output implementation will only
	have to override the [writeChar] and maybe the [write], [flush] and [close]
	methods. See [File.write] and [String.write] for two ways of creating an
	Output.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="sys.io._Process.Stdin" params="" file="/usr/lib/haxe/std/cpp/_std/sys/io/Process.hx" private="1" module="sys.io.Process">
		<extends path="haxe.io.Output"/>
		<_stdin_write line="53" static="1"><f a=":::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></_stdin_write>
		<_stdin_close line="54" static="1"><f a="">
	<d/>
	<unknown/>
</f></_stdin_close>
		<p><d/></p>
		<buf><c path="haxe.io.Bytes"/></buf>
		<close public="1" set="method" line="34" override="1"><f a=""><x path="Void"/></f></close>
		<writeByte public="1" set="method" line="39" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="44" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<new public="1" set="method" line="29"><f a="p">
	<unknown/>
	<x path="Void"/>
</f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.Bytes" params="" file="/usr/lib/haxe/std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="357" static="1"><f a="length">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" set="method" line="382" static="1"><f a="s">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></ofString>
		<ofData public="1" set="method" line="435" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<c path="haxe.io.Bytes"/>
</f></ofData>
		<length public="1" set="null"><x path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<blit public="1" set="method" line="75"><f a="pos:src:srcpos:len">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blit>
		<sub public="1" set="method" line="127"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<getString public="1" set="method" line="261"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></getString>
		<toString public="1" set="method" line="318"><f a=""><c path="String"/></f></toString>
		<toHex public="1" set="method" line="339"><f a=""><c path="String"/></f></toHex>
		<new set="method" line="33"><f a="length:b">
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.Input" params="" file="/usr/lib/haxe/std/haxe/io/Input.hx">
		<bigEndian public="1" set="accessor"><x path="Bool"/></bigEndian>
		<readByte public="1" set="method" line="37"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="46"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<close public="1" set="method" line="67"><f a=""><x path="Void"/></f></close>
		<set_bigEndian set="method" line="70"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_bigEndian>
		<readFullBytes public="1" set="method" line="99"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></readFullBytes>
		<read public="1" set="method" line="107"><f a="nbytes">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></read>
		<readLine public="1" set="method" line="127"><f a=""><c path="String"/></f></readLine>
		<readInt32 public="1" set="method" line="310"><f a=""><x path="Int"/></f></readInt32>
		<readString public="1" set="method" line="326"><f a="len">
	<x path="Int"/>
	<c path="String"/>
</f></readString>
		<haxe_doc>An Input is an abstract reader. See other classes in the [haxe.io] package
	for several possible implementations.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="sys.io._Process.Stdout" params="" file="/usr/lib/haxe/std/cpp/_std/sys/io/Process.hx" private="1" module="sys.io.Process">
		<extends path="haxe.io.Input"/>
		<_stdout_read line="87" static="1"><f a=":::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></_stdout_read>
		<_stderr_read line="88" static="1"><f a=":::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></_stderr_read>
		<p><d/></p>
		<out><x path="Bool"/></out>
		<buf><c path="haxe.io.Bytes"/></buf>
		<readByte public="1" set="method" line="70" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="76" override="1"><f a="str:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<new public="1" set="method" line="64"><f a="p:out">
	<unknown/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.Timer" params="" file="/Users/sven/dev/lime/haxe/Timer.hx">
		<sRunningTimers line="7" static="1"><c path="Array"><c path="haxe.Timer"/></c></sRunningTimers>
		<measure public="1" params="T" set="method" line="22" static="1"><f a="f:?pos" v=":null">
	<f a=""><c path="measure.T"/></f>
	<t path="haxe.PosInfos"/>
	<c path="measure.T"/>
</f></measure>
		<__nextWake public="1" set="method" line="45" static="1">
			<f a="limit">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</__nextWake>
		<__checkTimers public="1" set="method" line="70" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</__checkTimers>
		<GetMS set="method" line="86" static="1"><f a=""><x path="Float"/></f></GetMS>
		<delay public="1" set="method" line="92" static="1"><f a="_f:_time">
	<f a=""><x path="Void"/></f>
	<x path="Int"/>
	<c path="haxe.Timer"/>
</f></delay>
		<stamp public="1" set="method" line="105" static="1"><f a=""><x path="Float"/></f></stamp>
		<lime_time_stamp line="109" static="1"><f a=""><x path="Float"/></f></lime_time_stamp>
		<time public="1">
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</time>
		<fire_at public="1">
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</fire_at>
		<running public="1">
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</running>
		<run public="1" set="dynamic" line="30"><f a=""><x path="Void"/></f></run>
		<stop public="1" set="method" line="32"><f a=""><x path="Void"/></f></stop>
		<new public="1" set="method" line="13"><f a="_time">
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="haxe.crypto.BaseCode" params="" file="/usr/lib/haxe/std/haxe/crypto/BaseCode.hx">
		<base><c path="haxe.io.Bytes"/></base>
		<nbits><x path="Int"/></nbits>
		<tbl><c path="Array"><x path="Int"/></c></tbl>
		<encodeBytes public="1" set="method" line="44"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></encodeBytes>
		<initTable set="method" line="72"><f a=""><x path="Void"/></f></initTable>
		<decodeBytes public="1" set="method" line="81"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></decodeBytes>
		<new public="1" set="method" line="33"><f a="base">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Allows to encode/decode String and bytes using a power of two base dictionnary.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.crypto.Crc32" params="" file="/usr/lib/haxe/std/haxe/crypto/Crc32.hx">
		<crc><x path="Int"/></crc>
		<byte public="1" set="method" line="32"><f a="b">
	<x path="Int"/>
	<x path="Void"/>
</f></byte>
		<update public="1" set="method" line="43"><f a="b:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></update>
		<get public="1" set="method" line="57"><f a=""><x path="Int"/></f></get>
		<new public="1" set="method" line="28"><f a=""><x path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.crypto.Md5" params="" file="/usr/lib/haxe/std/haxe/crypto/Md5.hx">
		<encode public="1" set="method" line="29" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></encode>
		<str2blks set="method" line="139" static="1"><f a="str">
	<c path="String"/>
	<c path="Array"><x path="Int"/></c>
</f></str2blks>
		<bitOR set="method" line="76"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bitOR>
		<bitXOR set="method" line="82"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bitXOR>
		<bitAND set="method" line="88"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bitAND>
		<addme set="method" line="94"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></addme>
		<hex set="method" line="100"><f a="a">
	<c path="Array"><x path="Int"/></c>
	<c path="String"/>
</f></hex>
		<rol set="method" line="168"><f a="num:cnt">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></rol>
		<cmn set="method" line="172"><f a="q:a:b:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></cmn>
		<ff set="method" line="176"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></ff>
		<gg set="method" line="180"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></gg>
		<hh set="method" line="184"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></hh>
		<ii set="method" line="188"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></ii>
		<doEncode set="method" line="192"><f a="x">
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
</f></doEncode>
		<new set="method" line="73"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Creates a MD5 of a String.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.ds.BalancedTree" params="K:V" file="/usr/lib/haxe/std/haxe/ds/BalancedTree.hx">
		<root><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
</c></root>
		<set public="1" set="method" line="50">
			<f a="key:value">
				<c path="haxe.ds.BalancedTree.K"/>
				<c path="haxe.ds.BalancedTree.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Binds `key` to `value`.

		If `key` is already bound to a value, that binding disappears.

		If `key` is null, the result is unspecified.</haxe_doc>
		</set>
		<get public="1" set="method" line="61">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<t path="Null"><c path="haxe.ds.BalancedTree.V"/></t>
			</f>
			<haxe_doc>Returns the value `key` is bound to.

		If `key` is not bound to any value, `null` is returned.

		If `key` is null, the result is unspecified.</haxe_doc>
		</get>
		<remove public="1" set="method" line="82">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the current binding of `key`.

		If `key` has no binding, `this` BalancedTree is unchanged and false is
		returned.

		Otherwise the binding of `key` is removed and true is returned.

		If `key` is null, the result is unspecified.</haxe_doc>
		</remove>
		<exists public="1" set="method" line="99">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `key` is bound to a value.

		This method returns true even if `key` is bound to null.

		If `key` is null, the result is unspecified.</haxe_doc>
		</exists>
		<iterator public="1" set="method" line="115">
			<f a=""><t path="Iterator"><c path="haxe.ds.BalancedTree.V"/></t></f>
			<haxe_doc>Iterates over the bound values of `this` BalancedTree.

		This operation is performed in-order.</haxe_doc>
		</iterator>
		<keys public="1" set="method" line="126">
			<f a=""><t path="Iterator"><c path="haxe.ds.BalancedTree.K"/></t></f>
			<haxe_doc>Iterates over the keys of `this` BalancedTree.

		This operation is performed in-order.</haxe_doc>
		</keys>
		<setLoop set="method" line="132"><f a="k:v:node">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></setLoop>
		<removeLoop set="method" line="145"><f a="k:node">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></removeLoop>
		<iteratorLoop set="method" line="153"><f a="node:acc">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="Array"><c path="haxe.ds.BalancedTree.V"/></c>
	<x path="Void"/>
</f></iteratorLoop>
		<keysLoop set="method" line="161"><f a="node:acc">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="Array"><c path="haxe.ds.BalancedTree.K"/></c>
	<x path="Void"/>
</f></keysLoop>
		<merge set="method" line="169"><f a="t1:t2">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></merge>
		<minBinding set="method" line="176"><f a="t">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></minBinding>
		<removeMinBinding set="method" line="182"><f a="t">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></removeMinBinding>
		<balance set="method" line="187"><f a="l:k:v:r">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></balance>
		<compare set="method" line="201"><f a="k1:k2">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.K"/>
	<x path="Int"/>
</f></compare>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new BalancedTree, which is initially empty.</haxe_doc>
		</new>
		<haxe_doc>BalancedTree allows key-value mapping with arbitrary keys, as long as they
	can be ordered. By default, `Reflect.compare` is used in the `compare`
	method, which can be overridden in subclasses.

	Operations have a logarithmic average and worst-case cost.

	Iteration over keys and values, using `keys` and `iterator` respectively,
	are in-order.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.ds.TreeNode" params="K:V" file="/usr/lib/haxe/std/haxe/ds/BalancedTree.hx" module="haxe.ds.BalancedTree">
		<left public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></left>
		<right public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></right>
		<key public="1"><c path="haxe.ds.TreeNode.K"/></key>
		<value public="1"><c path="haxe.ds.TreeNode.V"/></value>
		<_height><x path="Int"/></_height>
		<new public="1" set="method" line="220"><f a="l:k:v:r:?h" v="::::-1">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.TreeNode.K"/>
		<c path="haxe.ds.TreeNode.V"/>
	</c>
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.TreeNode.K"/>
		<c path="haxe.ds.TreeNode.V"/>
	</c>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.ds.EnumValueMap" params="K:V" file="/usr/lib/haxe/std/haxe/ds/EnumValueMap.hx">
		<extends path="haxe.ds.BalancedTree">
			<c path="haxe.ds.EnumValueMap.K"/>
			<c path="haxe.ds.EnumValueMap.V"/>
		</extends>
		<implements path="IMap">
			<c path="haxe.ds.EnumValueMap.K"/>
			<c path="haxe.ds.EnumValueMap.V"/>
		</implements>
		<compare set="method" line="33" override="1"><f a="k1:k2">
	<x path="EnumValue"/>
	<x path="EnumValue"/>
	<x path="Int"/>
</f></compare>
		<compareArgs set="method" line="42"><f a="a1:a2">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<x path="Int"/>
</f></compareArgs>
		<compareArg set="method" line="52"><f a="v1:v2">
	<d/>
	<d/>
	<x path="Int"/>
</f></compareArg>
		<new public="1" set="method" line="31"><f a=""><x path="Void"/></f></new>
		<haxe_doc>EnumValueMap allows mapping of enum value keys to arbitrary values.

	Keys are compared by value and recursively over their parameters. If any
	parameter is not an enum value, `Reflect.compare` is used to compare them.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<abstract path="haxe.ds.HashMap" params="K:V" file="/usr/lib/haxe/std/haxe/ds/HashMap.hx">
		<this><a>
	<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
	<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
</a></this>
		<impl><class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="/usr/lib/haxe/std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.IntMap" params="T" file="/usr/lib/haxe/std/cpp/_std/haxe/ds/IntMap.hx">
		<implements path="IMap">
			<x path="Int"/>
			<c path="haxe.ds.IntMap.T"/>
		</implements>
		<h><d/></h>
		<set public="1" set="method" line="32">
			<f a="key:value">
				<x path="Int"/>
				<c path="haxe.ds.IntMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method" line="36">
			<f a="key">
				<x path="Int"/>
				<t path="Null"><c path="haxe.ds.IntMap.T"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method" line="40">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="44">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<iterator public="1" set="method" line="53">
			<f a=""><t path="Iterator"><c path="haxe.ds.IntMap.T"/></t></f>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<new public="1" set="method" line="28">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new IntMap.</haxe_doc>
		</new>
		<haxe_doc>IntMap allows mapping of Int keys to arbitrary values.

	See `Map` for documentation details.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.ds.ObjectMap" params="K:V" file="/usr/lib/haxe/std/cpp/_std/haxe/ds/ObjectMap.hx">
		<implements path="IMap">
			<c path="haxe.ds.ObjectMap.K"/>
			<c path="haxe.ds.ObjectMap.V"/>
		</implements>
		<__Internal><c path="haxe.ds.IntMap"><c path="haxe.ds.ObjectMap.V"/></c></__Internal>
		<__KeyRefs><c path="haxe.ds.IntMap"><c path="haxe.ds.ObjectMap.K"/></c></__KeyRefs>
		<set public="1" set="method" line="34">
			<f a="key:value">
				<c path="haxe.ds.ObjectMap.K"/>
				<c path="haxe.ds.ObjectMap.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method" line="40">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<t path="Null"><c path="haxe.ds.ObjectMap.V"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<remove public="1" set="method" line="48">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method" line="54">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.K"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="58">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.V"/></t></f>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<new public="1" set="method" line="29">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new ObjectMap.</haxe_doc>
		</new>
		<haxe_doc>ObjectMap allows mapping of object keys to arbitrary values.

	On static targets, the keys are considered to be strong references. Refer
	to `haxe.ds.WeakMap` for a weak reference version.

	See `Map` for documentation details.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.ds.StringMap" params="T" file="/usr/lib/haxe/std/cpp/_std/haxe/ds/StringMap.hx">
		<implements path="IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<__Internal><d/></__Internal>
		<set public="1" set="method" line="31">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method" line="35">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="haxe.ds.StringMap.T"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method" line="39">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="43">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method" line="47">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="53">
			<f a=""><t path="Iterator"><c path="haxe.ds.StringMap.T"/></t></f>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<new public="1" set="method" line="27">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringMap.</haxe_doc>
		</new>
		<haxe_doc>StringMap allows mapping of String keys to arbitrary values.

	See `Map` for documentation details.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.io.BytesBuffer" params="" file="/usr/lib/haxe/std/haxe/io/BytesBuffer.hx">
		<b><t path="haxe.io.BytesData"/></b>
		<getBytes public="1" set="method" line="173">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>Returns either a copy or a reference of the current bytes.
		Once called, the buffer can no longer be used.</haxe_doc>
		</getBytes>
		<new public="1" set="method" line="45"><f a=""><x path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.Unsigned_char__" params="" file="/usr/lib/haxe/std/haxe/io/BytesData.hx" module="haxe.io.BytesData" extern="1"/>
	<typedef path="haxe.io.BytesData" params="" file="/usr/lib/haxe/std/haxe/io/BytesData.hx"><c path="Array"><c path="haxe.io.Unsigned_char__"/></c></typedef>
	<class path="haxe.io.BytesInput" params="" file="/usr/lib/haxe/std/haxe/io/BytesInput.hx">
		<extends path="haxe.io.Input"/>
		<b><t path="haxe.io.BytesData"/></b>
		<pos><x path="Int"/></pos>
		<len><x path="Int"/></len>
		<totlen><x path="Int"/></totlen>
		<readByte public="1" set="method" line="87" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="108" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<new public="1" set="method" line="38"><f a="b:?pos:?len" v=":null:null">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.Eof" params="" file="/usr/lib/haxe/std/haxe/io/Eof.hx">
		<toString set="method" line="30">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<new public="1" set="method" line="28"><f a=""><x path="Void"/></f></new>
		<haxe_doc>This exception is raised when reading while data is no longer available in the [Input].</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<enum path="haxe.io.Error" params="" file="/usr/lib/haxe/std/haxe/io/Error.hx">
		<Blocked><haxe_doc>The IO is set into nonblocking mode and some data cannot be read or written</haxe_doc></Blocked>
		<Overflow><haxe_doc>An integer value is outside its allowed range</haxe_doc></Overflow>
		<OutsideBounds><haxe_doc>An operation on Bytes is outside of its valid range</haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc>Other errors</haxe_doc>
		</Custom>
		<haxe_doc>The possible IO errors that can occur</haxe_doc>
	</enum>
	<class path="haxe.io.Path" params="" file="/usr/lib/haxe/std/haxe/io/Path.hx">
		<directory public="1" set="method" line="141" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the directory of `path`.

		If the directory is null, the empty String "" is returned.

		If `path` is null, the result is unspecified.</haxe_doc>
		</directory>
		<addTrailingSlash public="1" set="method" line="268" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Adds a trailing slash to `path`, if it does not have one already.

		If the last slash in `path` is a backslash, a backslash is appended to
		`path`.

		If the last slash in `path` is a slash, or if no slash is found, a slash
		is appended to `path`. In particular, this applies to the empty String
		"".

		If `path` is null, the result is unspecified.</haxe_doc>
		</addTrailingSlash>
		<removeTrailingSlashes public="1" set="method" line="293" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":require"><e><![CDATA[haxe_ver>=3.1]]></e></m></meta>
			<haxe_doc>Removes trailing slashes from `path`.

		If `path` does not end with a `/` or `\`, `path` is returned unchanged.

		Otherwise the substring of `path` excluding the trailing slashes or
		backslashes is returned.

		If `path` is null, the result is unspecified.</haxe_doc>
		</removeTrailingSlashes>
		<dir public="1">
			<c path="String"/>
			<haxe_doc>The directory.

		This is the leading part of the path that is not part of the file name
		and the extension.

		Does not end with a `/` or `\` separator.

		If the path has no directory, the value is null.</haxe_doc>
		</dir>
		<file public="1">
			<c path="String"/>
			<haxe_doc>The file name.

		This is the part of the part between the directory and the extension.

		If there is no file name, e.g. for ".htaccess" or "/dir/", the value
		is the empty String "".</haxe_doc>
		</file>
		<ext public="1">
			<c path="String"/>
			<haxe_doc>The file extension.

		It is separated from the file name by a dot. This dot is not part of
		the extension.

		If the path has no extension, the value is null.</haxe_doc>
		</ext>
		<backslash public="1">
			<x path="Bool"/>
			<haxe_doc>True if the last directory separator is a backslash, false otherwise.</haxe_doc>
		</backslash>
		<new public="1" set="method" line="76">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Path instance by parsing `path`.

		Path information can be retrieved by accessing the dir, file and ext
		properties.</haxe_doc>
		</new>
		<haxe_doc>This class provides a convenient way of working with paths. It supports the
	common path formats:

	- directory1/directory2/filename.extension
	- directory1\directory2\filename.excention</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.zip.Compress" params="" file="/usr/lib/haxe/std/cpp/_std/haxe/zip/Compress.hx">
		<run public="1" set="method" line="45" static="1"><f a="s:level">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></run>
		<_deflate_init line="56" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></_deflate_init>
		<_deflate_bound line="57" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
</f></_deflate_bound>
		<_deflate_buffer line="58" static="1"><f a="::::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<a>
		<write><x path="Int"/></write>
		<read><x path="Int"/></read>
		<done><x path="Bool"/></done>
	</a>
</f></_deflate_buffer>
		<_deflate_end line="59" static="1"><f a="">
	<d/>
	<unknown/>
</f></_deflate_end>
		<_set_flush_mode line="60" static="1"><f a=":">
	<d/>
	<c path="String"/>
	<unknown/>
</f></_set_flush_mode>
		<s><d/></s>
		<execute public="1" set="method" line="33"><f a="src:srcPos:dst:dstPos">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<a>
		<write><x path="Int"/></write>
		<read><x path="Int"/></read>
		<done><x path="Bool"/></done>
	</a>
</f></execute>
		<setFlushMode public="1" set="method" line="37"><f a="f">
	<e path="haxe.zip.FlushMode"/>
	<x path="Void"/>
</f></setFlushMode>
		<close public="1" set="method" line="41"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="29"><f a="level">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<enum path="haxe.zip.FlushMode" params="" file="/usr/lib/haxe/std/haxe/zip/FlushMode.hx">
		<NO/>
		<SYNC/>
		<FULL/>
		<FINISH/>
		<BLOCK/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="haxe.zip.Uncompress" params="" file="/usr/lib/haxe/std/cpp/_std/haxe/zip/Uncompress.hx">
		<run public="1" set="method" line="44" static="1"><f a="src:?bufsize" v=":null">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></run>
		<_inflate_init line="62" static="1"><f a="">
	<t path="Null"><x path="Int"/></t>
	<unknown/>
</f></_inflate_init>
		<_inflate_buffer line="63" static="1"><f a="::::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<a>
		<write><x path="Int"/></write>
		<read><x path="Int"/></read>
		<done><x path="Bool"/></done>
	</a>
</f></_inflate_buffer>
		<_inflate_end line="64" static="1"><f a="">
	<d/>
	<unknown/>
</f></_inflate_end>
		<_set_flush_mode line="65" static="1"><f a=":">
	<d/>
	<unknown/>
	<unknown/>
</f></_set_flush_mode>
		<s><d/></s>
		<execute public="1" set="method" line="32"><f a="src:srcPos:dst:dstPos">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<a>
		<write><x path="Int"/></write>
		<read><x path="Int"/></read>
		<done><x path="Bool"/></done>
	</a>
</f></execute>
		<setFlushMode public="1" set="method" line="36"><f a="f">
	<e path="haxe.zip.FlushMode"/>
	<x path="Void"/>
</f></setFlushMode>
		<close public="1" set="method" line="40"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="28"><f a="?windowBits" v="null">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="lime.AssetData" params="" file="bin/mac64/cpp/haxe/lime/AssetData.hx">
		<initialized line="8" static="1"><x path="Bool"/></initialized>
		<library public="1" line="10" static="1"><x path="Map">
	<c path="String"/>
	<e path="lime.utils.LibraryType"/>
</x></library>
		<path public="1" line="11" static="1"><x path="Map">
	<c path="String"/>
	<c path="String"/>
</x></path>
		<type public="1" line="12" static="1"><x path="Map">
	<c path="String"/>
	<e path="lime.utils.AssetType"/>
</x></type>
		<initialize public="1" set="method" line="14" static="1"><f a=""><x path="Void"/></f></initialize>
	</class>
	<class path="lime.AudioHandler" params="" file="/Users/sven/dev/lime/lime/AudioHandler.hx">
		<lib public="1"><c path="lime.Lime"/></lib>
		<sounds public="1"><x path="Map">
	<c path="String"/>
	<c path="lime.helpers.Sound"/>
</x></sounds>
		<helper public="1"><t path="lime.helpers.AudioHelper"/></helper>
		<startup public="1" set="method" line="20"><f a=""><x path="Void"/></f></startup>
		<shutdown public="1" set="method" line="28">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</shutdown>
		<update public="1" set="method" line="34">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</update>
		<create public="1" set="method" line="48"><f a="_name:_file:?_music" v="::false">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="lime.helpers.Sound"/>
</f></create>
		<sound public="1" set="method" line="65"><f a="_name">
	<c path="String"/>
	<c path="lime.helpers.Sound"/>
</f></sound>
		<loop public="1" set="method" line="71"><f a="_name">
	<c path="String"/>
	<x path="Void"/>
</f></loop>
		<stop public="1" set="method" line="87"><f a="_name">
	<c path="String"/>
	<x path="Void"/>
</f></stop>
		<play public="1" set="method" line="99"><f a="_name:?_number_of_times:?_start_position_in_ms" v=":1:0">
	<c path="String"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></play>
		<playing public="1" set="method" line="112"><f a="_name">
	<c path="String"/>
	<x path="Bool"/>
</f></playing>
		<exists public="1" set="method" line="123"><f a="_name">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<volume public="1" set="method" line="131"><f a="_name:?_volume" v=":null">
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
</f></volume>
		<pan public="1" set="method" line="149"><f a="_name:?_pan" v=":null">
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
</f></pan>
		<position public="1" set="method" line="167"><f a="_name:?_pos" v=":null">
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
</f></position>
		<new public="1" set="method" line="14"><f a="_lib">
	<c path="lime.Lime"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.Window" params="" file="/Users/sven/dev/lime/lime/Constants.hx" module="lime.Constants">
		<FULLSCREEN public="1" line="6" static="1"><x path="Int"/></FULLSCREEN>
		<BORDERLESS public="1" line="7" static="1"><x path="Int"/></BORDERLESS>
		<RESIZABLE public="1" line="8" static="1"><x path="Int"/></RESIZABLE>
		<HARDWARE public="1" line="9" static="1"><x path="Int"/></HARDWARE>
		<VSYNC public="1" line="10" static="1"><x path="Int"/></VSYNC>
		<HW_AA public="1" line="11" static="1"><x path="Int"/></HW_AA>
		<HW_AA_HIRES public="1" line="12" static="1"><x path="Int"/></HW_AA_HIRES>
		<ALLOW_SHADERS public="1" line="13" static="1"><x path="Int"/></ALLOW_SHADERS>
		<REQUIRE_SHADERS public="1" line="14" static="1"><x path="Int"/></REQUIRE_SHADERS>
		<DEPTH_BUFFER public="1" line="15" static="1"><x path="Int"/></DEPTH_BUFFER>
		<STENCIL_BUFFER public="1" line="16" static="1"><x path="Int"/></STENCIL_BUFFER>
	</class>
	<class path="lime.SystemEvents" params="" file="/Users/sven/dev/lime/lime/Constants.hx" module="lime.Constants">
		<char public="1" line="22" static="1"><x path="Int"/></char>
		<keydown public="1" line="23" static="1"><x path="Int"/></keydown>
		<keyup public="1" line="24" static="1"><x path="Int"/></keyup>
		<mousemove public="1" line="25" static="1"><x path="Int"/></mousemove>
		<mousedown public="1" line="26" static="1"><x path="Int"/></mousedown>
		<mouseclick public="1" line="27" static="1"><x path="Int"/></mouseclick>
		<mouseup public="1" line="28" static="1"><x path="Int"/></mouseup>
		<resize public="1" line="29" static="1"><x path="Int"/></resize>
		<poll public="1" line="30" static="1"><x path="Int"/></poll>
		<quit public="1" line="31" static="1"><x path="Int"/></quit>
		<focus public="1" line="32" static="1"><x path="Int"/></focus>
		<shouldrotate public="1" line="33" static="1"><x path="Int"/></shouldrotate>
		<redraw public="1" line="35" static="1"><x path="Int"/></redraw>
		<touchbegin public="1" line="36" static="1"><x path="Int"/></touchbegin>
		<touchmove public="1" line="37" static="1"><x path="Int"/></touchmove>
		<touchend public="1" line="38" static="1"><x path="Int"/></touchend>
		<touchtap public="1" line="39" static="1"><x path="Int"/></touchtap>
		<change public="1" line="40" static="1"><x path="Int"/></change>
		<activate public="1" line="41" static="1"><x path="Int"/></activate>
		<deactivate public="1" line="42" static="1"><x path="Int"/></deactivate>
		<gotinputfocus public="1" line="43" static="1"><x path="Int"/></gotinputfocus>
		<lostinputfocus public="1" line="44" static="1"><x path="Int"/></lostinputfocus>
		<joyaxismove public="1" line="45" static="1"><x path="Int"/></joyaxismove>
		<joyballmove public="1" line="46" static="1"><x path="Int"/></joyballmove>
		<joyhatmove public="1" line="47" static="1"><x path="Int"/></joyhatmove>
		<joybuttondown public="1" line="48" static="1"><x path="Int"/></joybuttondown>
		<joybuttonup public="1" line="49" static="1"><x path="Int"/></joybuttonup>
		<joydeviceadded public="1" line="50" static="1"><x path="Int"/></joydeviceadded>
		<joydeviceremoved public="1" line="51" static="1"><x path="Int"/></joydeviceremoved>
		<syswm public="1" line="52" static="1"><x path="Int"/></syswm>
	</class>
	<class path="lime.InputHandler" params="" file="/Users/sven/dev/lime/lime/InputHandler.hx">
		<efLeftDown line="612" static="1"><x path="Int"/></efLeftDown>
		<efShiftDown line="613" static="1"><x path="Int"/></efShiftDown>
		<efCtrlDown line="614" static="1"><x path="Int"/></efCtrlDown>
		<efAltDown line="615" static="1"><x path="Int"/></efAltDown>
		<efCommandDown line="616" static="1"><x path="Int"/></efCommandDown>
		<lib public="1"><c path="lime.Lime"/></lib>
		<touches_active public="1"><x path="Map">
	<x path="Int"/>
	<d/>
</x></touches_active>
		<keys_down public="1"><x path="Map">
	<x path="Int"/>
	<x path="Bool"/>
</x></keys_down>
		<key_value_down public="1"><x path="Map">
	<e path="lime.helpers.KeyValue"/>
	<x path="Bool"/>
</x></key_value_down>
		<key_value_pressed public="1"><x path="Map">
	<e path="lime.helpers.KeyValue"/>
	<x path="Bool"/>
</x></key_value_pressed>
		<key_value_released public="1"><x path="Map">
	<e path="lime.helpers.KeyValue"/>
	<x path="Bool"/>
</x></key_value_released>
		<last_mouse_x public="1"><x path="Int"/></last_mouse_x>
		<last_mouse_y public="1"><x path="Int"/></last_mouse_y>
		<helper public="1"><t path="lime.helpers.InputHelper"/></helper>
		<keypressed public="1" set="method" line="40"><f a="_value">
	<e path="lime.helpers.KeyValue"/>
	<x path="Bool"/>
</f></keypressed>
		<keyreleased public="1" set="method" line="44"><f a="_value">
	<e path="lime.helpers.KeyValue"/>
	<x path="Bool"/>
</f></keyreleased>
		<keydown public="1" set="method" line="48"><f a="_value">
	<e path="lime.helpers.KeyValue"/>
	<x path="Bool"/>
</f></keydown>
		<startup public="1" set="method" line="54">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</startup>
		<shutdown public="1" set="method" line="71">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</shutdown>
		<update public="1" set="method" line="79">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</update>
		<lime_onchar public="1" set="method" line="116">
			<f a="_event">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</lime_onchar>
		<lime_onkeydown public="1" set="method" line="136">
			<f a="_event">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</lime_onkeydown>
		<lime_onkeyup public="1" set="method" line="173">
			<f a="_event">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</lime_onkeyup>
		<lime_gotinputfocus public="1" set="method" line="205">
			<f a="_event">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</lime_gotinputfocus>
		<lime_lostinputfocus public="1" set="method" line="227">
			<f a="_event">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</lime_lostinputfocus>
		<mouse_button_from_id public="1" set="method" line="251">
			<f a="id">
				<x path="Int"/>
				<d/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</mouse_button_from_id>
		<lime_mousemove public="1" set="method" line="267">
			<f a="_event:?_pass_through" v=":false">
				<d/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</lime_mousemove>
		<lime_mousedown public="1" set="method" line="312">
			<f a="_event:?_pass_through" v=":false">
				<d/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</lime_mousedown>
		<lime_mouseclick public="1" set="method" line="341">
			<f a="_event:?_pass_through" v=":false">
				<d/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</lime_mouseclick>
		<lime_mouseup public="1" set="method" line="370">
			<f a="_event:?_pass_through" v=":false">
				<d/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</lime_mouseup>
		<lime_mousewheel public="1" set="method" line="410">
			<f a="_event:?_pass_through" v=":false">
				<d/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</lime_mousewheel>
		<lime_touchbegin public="1" set="method" line="441">
			<f a="_event">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</lime_touchbegin>
		<lime_touchmove public="1" set="method" line="466">
			<f a="_event">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</lime_touchmove>
		<lime_touchend public="1" set="method" line="483">
			<f a="_event">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</lime_touchend>
		<lime_touchtap public="1" set="method" line="507">
			<f a="_event">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</lime_touchtap>
		<lime_gamepadaxis public="1" set="method" line="517">
			<f a="_event:?_pass_through" v=":false">
				<d/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</lime_gamepadaxis>
		<lime_gamepadbuttondown public="1" set="method" line="540">
			<f a="_event:?_pass_through" v=":false">
				<d/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</lime_gamepadbuttondown>
		<lime_gamepadbuttonup public="1" set="method" line="564">
			<f a="_event:?_pass_through" v=":false">
				<d/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</lime_gamepadbuttonup>
		<lime_gamepadball public="1" set="method" line="588">
			<f a="_event">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</lime_gamepadball>
		<lime_gamepadhat public="1" set="method" line="594">
			<f a="_event">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</lime_gamepadhat>
		<lime_gamepaddeviceadded public="1" set="method" line="600"><f a="_event">
	<d/>
	<x path="Void"/>
</f></lime_gamepaddeviceadded>
		<lime_gamepaddeviceremoved public="1" set="method" line="606"><f a="_event">
	<d/>
	<x path="Void"/>
</f></lime_gamepaddeviceremoved>
		<new public="1" set="method" line="28"><f a="_lib">
	<c path="lime.Lime"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="lime.TouchState" params="" file="/Users/sven/dev/lime/lime/InputHandler.hx" module="lime.InputHandler">
		<begin/>
		<move/>
		<end/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="lime.MouseState" params="" file="/Users/sven/dev/lime/lime/InputHandler.hx" module="lime.InputHandler">
		<down/>
		<move/>
		<wheel/>
		<up/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="lime.ButtonState" params="" file="/Users/sven/dev/lime/lime/InputHandler.hx" module="lime.InputHandler">
		<down/>
		<up/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="lime.MouseButton" params="" file="/Users/sven/dev/lime/lime/InputHandler.hx" module="lime.InputHandler">
		<move/>
		<left/>
		<middle/>
		<right/>
		<wheel_up/>
		<wheel_down/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<typedef path="lime.KeyEvent" params="" file="/Users/sven/dev/lime/lime/InputHandler.hx" module="lime.InputHandler"><a>
	<value><x path="Int"/></value>
	<shift_down><x path="Bool"/></shift_down>
	<raw><d/></raw>
	<meta_down><x path="Bool"/></meta_down>
	<key><e path="lime.helpers.KeyValue"/></key>
	<flags><x path="Int"/></flags>
	<ctrl_down><x path="Bool"/></ctrl_down>
	<code><x path="Int"/></code>
	<char><x path="Int"/></char>
	<alt_down><x path="Bool"/></alt_down>
</a></typedef>
	<typedef path="lime.TouchEvent" params="" file="/Users/sven/dev/lime/lime/InputHandler.hx" module="lime.InputHandler"><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
	<state><e path="lime.TouchState"/></state>
	<raw><d/></raw>
	<flags><x path="Int"/></flags>
	<ID><x path="Int"/></ID>
</a></typedef>
	<typedef path="lime.MouseEvent" params="" file="/Users/sven/dev/lime/lime/InputHandler.hx" module="lime.InputHandler"><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
	<state><e path="lime.MouseState"/></state>
	<shift_down><x path="Bool"/></shift_down>
	<raw><d/></raw>
	<meta_down><x path="Bool"/></meta_down>
	<flags><x path="Int"/></flags>
	<deltaY><x path="Float"/></deltaY>
	<deltaX><x path="Float"/></deltaX>
	<ctrl_down><x path="Bool"/></ctrl_down>
	<button><e path="lime.MouseButton"/></button>
	<alt_down><x path="Bool"/></alt_down>
</a></typedef>
	<typedef path="lime.GamepadEvent" params="" file="/Users/sven/dev/lime/lime/InputHandler.hx" module="lime.InputHandler"><a>
	<raw><d/></raw>
	<gamepad><x path="Int"/></gamepad>
</a></typedef>
	<typedef path="lime.GamepadButtonEvent" params="" file="/Users/sven/dev/lime/lime/InputHandler.hx" module="lime.InputHandler"><a>
	<value><x path="Float"/></value>
	<state><e path="lime.ButtonState"/></state>
	<raw><d/></raw>
	<gamepad><x path="Int"/></gamepad>
	<button><x path="Int"/></button>
</a></typedef>
	<typedef path="lime.GamepadAxisEvent" params="" file="/Users/sven/dev/lime/lime/InputHandler.hx" module="lime.InputHandler"><a>
	<value><x path="Float"/></value>
	<raw><d/></raw>
	<gamepad><x path="Int"/></gamepad>
	<axis><x path="Int"/></axis>
</a></typedef>
	<typedef path="lime.LimeConfig" params="" file="/Users/sven/dev/lime/lime/Lime.hx" module="lime.Lime"><a>
	<width>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</width>
	<vsync>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</vsync>
	<title>
		<c path="String"/>
		<meta><m n=":optional"/></meta>
	</title>
	<stencil_buffer>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</stencil_buffer>
	<resizable>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</resizable>
	<orientation>
		<c path="String"/>
		<meta><m n=":optional"/></meta>
	</orientation>
	<multitouch_supported>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</multitouch_supported>
	<multitouch>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</multitouch>
	<host>
		<d/>
		<meta><m n=":optional"/></meta>
	</host>
	<height>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</height>
	<fullscreen>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</fullscreen>
	<fps>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</fps>
	<depth_buffer>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</depth_buffer>
	<borderless>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</borderless>
	<antialiasing>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</antialiasing>
</a></typedef>
	<class path="lime.Lime" params="" file="/Users/sven/dev/lime/lime/Lime.hx">
		<early_wakeup public="1" line="58" static="1">
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</early_wakeup>
		<lime_stage_request_render line="466" static="1"><unknown/></lime_stage_request_render>
		<lime_stage_set_next_wake line="467" static="1"><f a=":">
	<d/>
	<x path="Float"/>
	<unknown/>
</f></lime_stage_set_next_wake>
		<host public="1"><d/></host>
		<config public="1"><t path="lime.LimeConfig"/></config>
		<audio public="1"><c path="lime.AudioHandler"/></audio>
		<input public="1"><c path="lime.InputHandler"/></input>
		<render public="1"><c path="lime.RenderHandler"/></render>
		<window public="1"><c path="lime.WindowHandler"/></window>
		<window_handle public="1"><d/></window_handle>
		<view_handle public="1"><d/></view_handle>
		<frame_rate public="1" set="accessor"><x path="Float"/></frame_rate>
		<render_request_function public="1"><f a=""><x path="Void"/></f></render_request_function>
		<frame_period><x path="Float"/></frame_period>
		<last_render_time><x path="Float"/></last_render_time>
		<set_frame_rate set="method" line="59"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_frame_rate>
		<shutting_down public="1"><x path="Bool"/></shutting_down>
		<has_shutdown public="1"><x path="Bool"/></has_shutdown>
		<init public="1" set="method" line="82"><f a="_main_:_config">
	<c path="luxe.Core"/>
	<t path="lime.LimeConfig"/>
	<x path="Void"/>
</f></init>
		<on_window_ready public="1" set="method" line="116"><f a="handle">
	<d/>
	<x path="Void"/>
</f></on_window_ready>
		<shutdown public="1" set="method" line="157"><f a=""><x path="Void"/></f></shutdown>
		<cleanup public="1" set="method" line="183"><f a=""><x path="Void"/></f></cleanup>
		<on_lime_event public="1" set="method" line="189"><f a="_event">
	<d/>
	<d/>
</f></on_lime_event>
		<on_syswm public="1" set="method" line="326"><f a="ev">
	<d/>
	<x path="Void"/>
</f></on_syswm>
		<on_change public="1" set="method" line="332"><f a="ev">
	<d/>
	<x path="Void"/>
</f></on_change>
		<on_update public="1" set="method" line="339"><f a="_event">
	<unknown/>
	<x path="Bool"/>
</f></on_update>
		<perform_render public="1" set="method" line="382"><f a=""><x path="Void"/></f></perform_render>
		<__checkRender set="method" line="392">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__checkRender>
		<__updateNextWake public="1" set="method" line="421">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__updateNextWake>
		<__nextFrameDue set="method" line="439">
			<f a="_otherTimers">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__nextFrameDue>
		<new public="1" set="method" line="79"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="lime.RenderHandler" params="" file="/Users/sven/dev/lime/lime/RenderHandler.hx">
		<lime_get_frame_stage line="259" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_get_frame_stage>
		<lime_stage_request_render line="260" static="1"><f a=""><unknown/></f></lime_stage_request_render>
		<lime_render_stage line="261" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_render_stage>
		<lime_doc_add_child line="262" static="1"><f a=":">
	<d/>
	<d/>
	<unknown/>
</f></lime_doc_add_child>
		<lime_direct_renderer_create line="263" static="1"><f a=""><unknown/></f></lime_direct_renderer_create>
		<lime_direct_renderer_set line="264" static="1"><f a=":">
	<d/>
	<f a="rect">
		<d/>
		<x path="Void"/>
	</f>
	<unknown/>
</f></lime_direct_renderer_set>
		<lime_stage_set_next_wake line="265" static="1"><unknown/></lime_stage_set_next_wake>
		<lib public="1"><c path="lime.Lime"/></lib>
		<__handle public="1"><d/></__handle>
		<direct_renderer_handle public="1"><d/></direct_renderer_handle>
		<__onRender set="method" line="53">
			<f a="rect">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__onRender>
		<startup public="1" set="method" line="58"><f a=""><x path="Void"/></f></startup>
		<shutdown public="1" set="method" line="123"><f a=""><x path="Void"/></f></shutdown>
		<on_resize public="1" set="method" line="129"><f a="_event">
	<d/>
	<x path="Void"/>
</f></on_resize>
		<request_render public="1" set="method" line="220"><f a=""><x path="Void"/></f></request_render>
		<render public="1" set="method" line="227"><f a=""><x path="Bool"/></f></render>
		<on_render public="1" set="method" line="248"><f a="rect">
	<d/>
	<x path="Void"/>
</f></on_render>
		<new public="1" set="method" line="39"><f a="_lib">
	<c path="lime.Lime"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.WindowHandler" params="" file="/Users/sven/dev/lime/lime/WindowHandler.hx">
		<lime_stage_set_scale_mode line="321" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<unknown/>
</f></lime_stage_set_scale_mode>
		<lime_stage_get_stage_width line="322" static="1"><f a="">
	<d/>
	<t path="Null"><x path="Int"/></t>
</f></lime_stage_get_stage_width>
		<lime_stage_get_stage_height line="323" static="1"><f a="">
	<d/>
	<t path="Null"><x path="Int"/></t>
</f></lime_stage_get_stage_height>
		<lime_set_stage_handler line="324" static="1"><f a=":::">
	<d/>
	<f a="_event">
		<d/>
		<d/>
	</f>
	<t path="Null"><x path="Int"/></t>
	<t path="Null"><x path="Int"/></t>
	<unknown/>
</f></lime_set_stage_handler>
		<lime_get_frame_stage line="325" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_get_frame_stage>
		<lime_create_main_frame line="326" static="1"><f a=":::::">
	<f a="handle">
		<d/>
		<x path="Void"/>
	</f>
	<t path="Null"><x path="Int"/></t>
	<t path="Null"><x path="Int"/></t>
	<x path="Int"/>
	<c path="String"/>
	<unknown/>
	<unknown/>
</f></lime_create_main_frame>
		<lime_pause_animation line="327" static="1"><f a=""><unknown/></f></lime_pause_animation>
		<lime_resume_animation line="328" static="1"><f a=""><unknown/></f></lime_resume_animation>
		<lime_terminate line="329" static="1"><f a=""><unknown/></f></lime_terminate>
		<lime_close line="330" static="1"><f a=""><unknown/></f></lime_close>
		<lime_get_url line="331" static="1"><f a="">
	<c path="String"/>
	<unknown/>
</f></lime_get_url>
		<lime_file_dialog_save line="334" static="1"><f a="::">
	<c path="String"/>
	<c path="String"/>
	<c path="Array"><unknown/></c>
	<c path="String"/>
</f></lime_file_dialog_save>
		<lime_file_dialog_open line="335" static="1"><f a="::">
	<c path="String"/>
	<c path="String"/>
	<c path="Array"><unknown/></c>
	<c path="String"/>
</f></lime_file_dialog_open>
		<lime_file_dialog_folder line="336" static="1"><f a=":">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></lime_file_dialog_folder>
		<lime_stage_set_window_position line="339" static="1"><f a="::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_stage_set_window_position>
		<lime_stage_show_cursor line="340" static="1"><f a=":">
	<d/>
	<x path="Bool"/>
	<unknown/>
</f></lime_stage_show_cursor>
		<lime_stage_constrain_cursor_to_window_frame line="341" static="1"><f a=":">
	<d/>
	<x path="Bool"/>
	<unknown/>
</f></lime_stage_constrain_cursor_to_window_frame>
		<lime_stage_set_cursor_position_in_window line="342" static="1"><f a="::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_stage_set_cursor_position_in_window>
		<lime_stage_get_multitouch_supported line="345" static="1"><f a="">
	<d/>
	<t path="Null"><x path="Bool"/></t>
</f></lime_stage_get_multitouch_supported>
		<lime_stage_set_multitouch_active line="346" static="1"><f a=":">
	<d/>
	<x path="Bool"/>
	<unknown/>
</f></lime_stage_set_multitouch_active>
		<lib public="1"><c path="lime.Lime"/></lib>
		<active public="1"><x path="Bool"/></active>
		<invalidated public="1"><x path="Bool"/></invalidated>
		<cursor_locked public="1"><x path="Bool"/></cursor_locked>
		<cursor_visible public="1"><x path="Bool"/></cursor_visible>
		<startup public="1" set="method" line="22"><f a=""><x path="Void"/></f></startup>
		<shutdown public="1" set="method" line="75"><f a=""><x path="Void"/></f></shutdown>
		<ready public="1" set="method" line="86"><f a=""><x path="Void"/></f></ready>
		<post_ready public="1" set="method" line="113"><f a=""><x path="Void"/></f></post_ready>
		<invalidate public="1" set="method" line="132"><f a=""><x path="Void"/></f></invalidate>
		<set_active public="1" set="method" line="136"><f a="_active">
	<x path="Bool"/>
	<x path="Void"/>
</f></set_active>
		<set_cursor_visible public="1" set="method" line="153"><f a="?val" v="true">
	<x path="Bool"/>
	<x path="Void"/>
</f></set_cursor_visible>
		<constrain_cursor_to_window_frame public="1" set="method" line="164"><f a="?val" v="false">
	<x path="Bool"/>
	<x path="Void"/>
</f></constrain_cursor_to_window_frame>
		<set_window_position public="1" set="method" line="179"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set_window_position>
		<set_cursor_position_in_window public="1" set="method" line="222"><f a="?_x:?_y" v="0:0">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set_cursor_position_in_window>
		<on_redraw public="1" set="method" line="232"><f a="_event">
	<d/>
	<x path="Void"/>
</f></on_redraw>
		<on_resize public="1" set="method" line="237"><f a="_event">
	<d/>
	<x path="Void"/>
</f></on_resize>
		<on_should_rotate public="1" set="method" line="249"><f a="_event">
	<d/>
	<x path="Void"/>
</f></on_should_rotate>
		<on_focus public="1" set="method" line="254"><f a="_event">
	<d/>
	<x path="Void"/>
</f></on_focus>
		<on_pause public="1" set="method" line="260"><f a=""><x path="Void"/></f></on_pause>
		<on_resume public="1" set="method" line="267"><f a=""><x path="Void"/></f></on_resume>
		<on_force_close public="1" set="method" line="274"><f a=""><x path="Void"/></f></on_force_close>
		<openURL public="1" set="method" line="280"><f a="_url">
	<c path="String"/>
	<x path="Void"/>
</f></openURL>
		<fileDialogOpen public="1" set="method" line="297"><f a="_title:_text">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></fileDialogOpen>
		<fileDialogSave public="1" set="method" line="304"><f a="_title:_text">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></fileDialogSave>
		<fileDialogFolder public="1" set="method" line="311"><f a="_title:_text">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></fileDialogFolder>
		<new public="1" set="method" line="11"><f a="_lib">
	<c path="lime.Lime"/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="lime.gl.GL" params="" file="/Users/sven/dev/lime/lime/gl/GL.hx"><c path="lime.gl.native.GL"/></typedef>
	<typedef path="lime.gl.Ext" params="" file="/Users/sven/dev/lime/lime/gl/GL.hx" module="lime.gl.GL"><c path="lime.gl.native.Ext"/></typedef>
	<typedef path="lime.gl.GLActiveInfo" params="" file="/Users/sven/dev/lime/lime/gl/GLActiveInfo.hx"><a>
	<type><x path="Int"/></type>
	<size><x path="Int"/></size>
	<name><c path="String"/></name>
</a></typedef>
	<class path="lime.gl.GLObject" params="" file="/Users/sven/dev/lime/lime/gl/GLObject.hx">
		<id public="1"><d/></id>
		<invalidated public="1" get="accessor" set="null"><x path="Bool"/></invalidated>
		<valid public="1" get="accessor" set="null"><x path="Bool"/></valid>
		<version><x path="Int"/></version>
		<getType set="method" line="25"><f a=""><c path="String"/></f></getType>
		<invalidate public="1" set="method" line="29"><f a=""><x path="Void"/></f></invalidate>
		<isValid public="1" set="method" line="33"><f a=""><x path="Bool"/></f></isValid>
		<isInvalid public="1" set="method" line="37"><f a=""><x path="Bool"/></f></isInvalid>
		<toString public="1" set="method" line="41"><f a=""><c path="String"/></f></toString>
		<get_invalidated set="method" line="47"><f a=""><x path="Bool"/></f></get_invalidated>
		<get_valid set="method" line="51"><f a=""><x path="Bool"/></f></get_valid>
		<new set="method" line="18"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.gl.GLBuffer" params="" file="/Users/sven/dev/lime/lime/gl/GLBuffer.hx">
		<extends path="lime.gl.GLObject"/>
		<getType set="method" line="13" override="1"><f a=""><c path="String"/></f></getType>
		<new public="1" set="method" line="10"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="lime.gl.GLContextAttributes" params="" file="/Users/sven/dev/lime/lime/gl/GLContextAttributes.hx"><a>
	<stencil><x path="Bool"/></stencil>
	<preserveDrawingBuffer><x path="Bool"/></preserveDrawingBuffer>
	<premultipliedAlpha><x path="Bool"/></premultipliedAlpha>
	<depth><x path="Bool"/></depth>
	<antialias><x path="Bool"/></antialias>
	<alpha><x path="Bool"/></alpha>
</a></typedef>
	<class path="lime.gl.GLFramebuffer" params="" file="/Users/sven/dev/lime/lime/gl/GLFramebuffer.hx">
		<extends path="lime.gl.GLObject"/>
		<getType set="method" line="16" override="1"><f a=""><c path="String"/></f></getType>
		<new public="1" set="method" line="12"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.gl.GLProgram" params="" file="/Users/sven/dev/lime/lime/gl/GLProgram.hx">
		<extends path="lime.gl.GLObject"/>
		<shaders public="1"><c path="Array"><c path="lime.gl.GLShader"/></c></shaders>
		<attach public="1" set="method" line="20"><f a="shader">
	<c path="lime.gl.GLShader"/>
	<x path="Void"/>
</f></attach>
		<getShaders public="1" set="method" line="24"><f a=""><c path="Array"><c path="lime.gl.GLShader"/></c></f></getShaders>
		<getType set="method" line="28" override="1"><f a=""><c path="String"/></f></getType>
		<new public="1" set="method" line="15"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.gl.GLRenderbuffer" params="" file="/Users/sven/dev/lime/lime/gl/GLRenderbuffer.hx">
		<extends path="lime.gl.GLObject"/>
		<getType set="method" line="15" override="1"><f a=""><c path="String"/></f></getType>
		<new public="1" set="method" line="11"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.gl.GLShader" params="" file="/Users/sven/dev/lime/lime/gl/GLShader.hx">
		<extends path="lime.gl.GLObject"/>
		<getType set="method" line="16" override="1"><f a=""><c path="String"/></f></getType>
		<new public="1" set="method" line="12"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.gl.GLTexture" params="" file="/Users/sven/dev/lime/lime/gl/GLTexture.hx">
		<extends path="lime.gl.GLObject"/>
		<getType set="method" line="16" override="1"><f a=""><c path="String"/></f></getType>
		<new public="1" set="method" line="12"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="lime.gl.GLUniformLocation" params="" file="/Users/sven/dev/lime/lime/gl/GLUniformLocation.hx"><d/></typedef>
	<class path="lime.gl.native.Ext" params="" file="/Users/sven/dev/lime/lime/gl/native/Ext.hx">
		<drawBuffers public="1" set="method" line="7" static="1"><f a="n:buffers">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawBuffers>
		<load set="method" line="13" static="1"><f a="inName:inArgCount">
	<c path="String"/>
	<x path="Int"/>
	<d/>
</f></load>
		<COLOR_ATTACHMENT0 public="1" get="inline" set="null" line="21" static="1"><x path="Int"/></COLOR_ATTACHMENT0>
		<COLOR_ATTACHMENT1 public="1" get="inline" set="null" line="22" static="1"><x path="Int"/></COLOR_ATTACHMENT1>
		<COLOR_ATTACHMENT2 public="1" get="inline" set="null" line="23" static="1"><x path="Int"/></COLOR_ATTACHMENT2>
		<COLOR_ATTACHMENT3 public="1" get="inline" set="null" line="24" static="1"><x path="Int"/></COLOR_ATTACHMENT3>
		<COLOR_ATTACHMENT4 public="1" get="inline" set="null" line="25" static="1"><x path="Int"/></COLOR_ATTACHMENT4>
		<COLOR_ATTACHMENT5 public="1" get="inline" set="null" line="26" static="1"><x path="Int"/></COLOR_ATTACHMENT5>
		<COLOR_ATTACHMENT6 public="1" get="inline" set="null" line="27" static="1"><x path="Int"/></COLOR_ATTACHMENT6>
		<COLOR_ATTACHMENT7 public="1" get="inline" set="null" line="28" static="1"><x path="Int"/></COLOR_ATTACHMENT7>
		<COLOR_ATTACHMENT8 public="1" get="inline" set="null" line="29" static="1"><x path="Int"/></COLOR_ATTACHMENT8>
		<COLOR_ATTACHMENT9 public="1" get="inline" set="null" line="30" static="1"><x path="Int"/></COLOR_ATTACHMENT9>
		<COLOR_ATTACHMENT10 public="1" get="inline" set="null" line="31" static="1"><x path="Int"/></COLOR_ATTACHMENT10>
		<COLOR_ATTACHMENT11 public="1" get="inline" set="null" line="32" static="1"><x path="Int"/></COLOR_ATTACHMENT11>
		<COLOR_ATTACHMENT12 public="1" get="inline" set="null" line="33" static="1"><x path="Int"/></COLOR_ATTACHMENT12>
		<COLOR_ATTACHMENT13 public="1" get="inline" set="null" line="34" static="1"><x path="Int"/></COLOR_ATTACHMENT13>
		<COLOR_ATTACHMENT14 public="1" get="inline" set="null" line="35" static="1"><x path="Int"/></COLOR_ATTACHMENT14>
		<COLOR_ATTACHMENT15 public="1" get="inline" set="null" line="36" static="1"><x path="Int"/></COLOR_ATTACHMENT15>
		<DRAW_BUFFER0 public="1" get="inline" set="null" line="38" static="1"><x path="Int"/></DRAW_BUFFER0>
		<DRAW_BUFFER1 public="1" get="inline" set="null" line="39" static="1"><x path="Int"/></DRAW_BUFFER1>
		<DRAW_BUFFER2 public="1" get="inline" set="null" line="40" static="1"><x path="Int"/></DRAW_BUFFER2>
		<DRAW_BUFFER3 public="1" get="inline" set="null" line="41" static="1"><x path="Int"/></DRAW_BUFFER3>
		<DRAW_BUFFER4 public="1" get="inline" set="null" line="42" static="1"><x path="Int"/></DRAW_BUFFER4>
		<DRAW_BUFFER5 public="1" get="inline" set="null" line="43" static="1"><x path="Int"/></DRAW_BUFFER5>
		<DRAW_BUFFER6 public="1" get="inline" set="null" line="44" static="1"><x path="Int"/></DRAW_BUFFER6>
		<DRAW_BUFFER7 public="1" get="inline" set="null" line="45" static="1"><x path="Int"/></DRAW_BUFFER7>
		<DRAW_BUFFER8 public="1" get="inline" set="null" line="46" static="1"><x path="Int"/></DRAW_BUFFER8>
		<DRAW_BUFFER9 public="1" get="inline" set="null" line="47" static="1"><x path="Int"/></DRAW_BUFFER9>
		<DRAW_BUFFER10 public="1" get="inline" set="null" line="48" static="1"><x path="Int"/></DRAW_BUFFER10>
		<DRAW_BUFFER11 public="1" get="inline" set="null" line="49" static="1"><x path="Int"/></DRAW_BUFFER11>
		<DRAW_BUFFER12 public="1" get="inline" set="null" line="50" static="1"><x path="Int"/></DRAW_BUFFER12>
		<DRAW_BUFFER13 public="1" get="inline" set="null" line="51" static="1"><x path="Int"/></DRAW_BUFFER13>
		<DRAW_BUFFER14 public="1" get="inline" set="null" line="52" static="1"><x path="Int"/></DRAW_BUFFER14>
		<DRAW_BUFFER15 public="1" get="inline" set="null" line="53" static="1"><x path="Int"/></DRAW_BUFFER15>
		<MAX_COLOR_ATTACHMENTS public="1" get="inline" set="null" line="55" static="1"><x path="Int"/></MAX_COLOR_ATTACHMENTS>
		<MAX_DRAW_BUFFERS public="1" get="inline" set="null" line="56" static="1"><x path="Int"/></MAX_DRAW_BUFFERS>
	</class>
	<abstract path="lime.gl.native.LimeFloats" params="" file="/Users/sven/dev/lime/lime/gl/native/GL.hx" module="lime.gl.native.GL">
		<from>
			<icast field="fromFloat32Array"><c path="lime.utils.Float32Array"/></icast>
			<icast field="fromArrayFloat"><c path="Array"><x path="Float"/></c></icast>
		</from>
		<this><d/></this>
		<to><icast field="toDynamic"><c path="Array"><x path="Float"/></c></icast></to>
		<impl><class path="lime.gl.native._GL.LimeFloats_Impl_" params="" file="/Users/sven/dev/lime/lime/gl/native/GL.hx" private="1" module="lime.gl.native.GL">
	<_new public="1" get="inline" set="null" line="12" static="1">
		<f a="d">
			<d/>
			<d/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<toDynamic get="inline" set="null" line="16" static="1">
		<f a="this">
			<d/>
			<c path="Array"><x path="Float"/></c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toDynamic>
	<fromFloat32Array get="inline" set="null" line="20" static="1">
		<f a="f">
			<c path="lime.utils.Float32Array"/>
			<x path="lime.gl.native.LimeFloats"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromFloat32Array>
	<fromArrayFloat get="inline" set="null" line="24" static="1">
		<f a="f">
			<c path="Array"><x path="Float"/></c>
			<x path="lime.gl.native.LimeFloats"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromArrayFloat>
</class></impl>
	</abstract>
	<class path="lime.gl.native._GL.LimeFloats_Impl_" params="" file="/Users/sven/dev/lime/lime/gl/native/GL.hx" private="1" module="lime.gl.native.GL">
		<_new public="1" get="inline" set="null" line="12" static="1">
			<f a="d">
				<d/>
				<d/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<toDynamic get="inline" set="null" line="16" static="1">
			<f a="this">
				<d/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toDynamic>
		<fromFloat32Array get="inline" set="null" line="20" static="1">
			<f a="f">
				<c path="lime.utils.Float32Array"/>
				<x path="lime.gl.native.LimeFloats"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromFloat32Array>
		<fromArrayFloat get="inline" set="null" line="24" static="1">
			<f a="f">
				<c path="Array"><x path="Float"/></c>
				<x path="lime.gl.native.LimeFloats"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromArrayFloat>
	</class>
	<class path="lime.gl.native.GL" params="" file="/Users/sven/dev/lime/lime/gl/native/GL.hx">
		<DEPTH_BUFFER_BIT public="1" get="inline" set="null" line="33" static="1"><x path="Int"/></DEPTH_BUFFER_BIT>
		<STENCIL_BUFFER_BIT public="1" get="inline" set="null" line="34" static="1"><x path="Int"/></STENCIL_BUFFER_BIT>
		<COLOR_BUFFER_BIT public="1" get="inline" set="null" line="35" static="1"><x path="Int"/></COLOR_BUFFER_BIT>
		<POINTS public="1" get="inline" set="null" line="38" static="1"><x path="Int"/></POINTS>
		<LINES public="1" get="inline" set="null" line="39" static="1"><x path="Int"/></LINES>
		<LINE_LOOP public="1" get="inline" set="null" line="40" static="1"><x path="Int"/></LINE_LOOP>
		<LINE_STRIP public="1" get="inline" set="null" line="41" static="1"><x path="Int"/></LINE_STRIP>
		<TRIANGLES public="1" get="inline" set="null" line="42" static="1"><x path="Int"/></TRIANGLES>
		<TRIANGLE_STRIP public="1" get="inline" set="null" line="43" static="1"><x path="Int"/></TRIANGLE_STRIP>
		<TRIANGLE_FAN public="1" get="inline" set="null" line="44" static="1"><x path="Int"/></TRIANGLE_FAN>
		<ZERO public="1" get="inline" set="null" line="56" static="1"><x path="Int"/></ZERO>
		<ONE public="1" get="inline" set="null" line="57" static="1"><x path="Int"/></ONE>
		<SRC_COLOR public="1" get="inline" set="null" line="58" static="1"><x path="Int"/></SRC_COLOR>
		<ONE_MINUS_SRC_COLOR public="1" get="inline" set="null" line="59" static="1"><x path="Int"/></ONE_MINUS_SRC_COLOR>
		<SRC_ALPHA public="1" get="inline" set="null" line="60" static="1"><x path="Int"/></SRC_ALPHA>
		<ONE_MINUS_SRC_ALPHA public="1" get="inline" set="null" line="61" static="1"><x path="Int"/></ONE_MINUS_SRC_ALPHA>
		<DST_ALPHA public="1" get="inline" set="null" line="62" static="1"><x path="Int"/></DST_ALPHA>
		<ONE_MINUS_DST_ALPHA public="1" get="inline" set="null" line="63" static="1"><x path="Int"/></ONE_MINUS_DST_ALPHA>
		<DST_COLOR public="1" get="inline" set="null" line="68" static="1"><x path="Int"/></DST_COLOR>
		<ONE_MINUS_DST_COLOR public="1" get="inline" set="null" line="69" static="1"><x path="Int"/></ONE_MINUS_DST_COLOR>
		<SRC_ALPHA_SATURATE public="1" get="inline" set="null" line="70" static="1"><x path="Int"/></SRC_ALPHA_SATURATE>
		<FUNC_ADD public="1" get="inline" set="null" line="76" static="1"><x path="Int"/></FUNC_ADD>
		<BLEND_EQUATION public="1" get="inline" set="null" line="77" static="1"><x path="Int"/></BLEND_EQUATION>
		<BLEND_EQUATION_RGB public="1" get="inline" set="null" line="78" static="1"><x path="Int"/></BLEND_EQUATION_RGB>
		<BLEND_EQUATION_ALPHA public="1" get="inline" set="null" line="79" static="1"><x path="Int"/></BLEND_EQUATION_ALPHA>
		<FUNC_SUBTRACT public="1" get="inline" set="null" line="82" static="1"><x path="Int"/></FUNC_SUBTRACT>
		<FUNC_REVERSE_SUBTRACT public="1" get="inline" set="null" line="83" static="1"><x path="Int"/></FUNC_REVERSE_SUBTRACT>
		<BLEND_DST_RGB public="1" get="inline" set="null" line="86" static="1"><x path="Int"/></BLEND_DST_RGB>
		<BLEND_SRC_RGB public="1" get="inline" set="null" line="87" static="1"><x path="Int"/></BLEND_SRC_RGB>
		<BLEND_DST_ALPHA public="1" get="inline" set="null" line="88" static="1"><x path="Int"/></BLEND_DST_ALPHA>
		<BLEND_SRC_ALPHA public="1" get="inline" set="null" line="89" static="1"><x path="Int"/></BLEND_SRC_ALPHA>
		<CONSTANT_COLOR public="1" get="inline" set="null" line="90" static="1"><x path="Int"/></CONSTANT_COLOR>
		<ONE_MINUS_CONSTANT_COLOR public="1" get="inline" set="null" line="91" static="1"><x path="Int"/></ONE_MINUS_CONSTANT_COLOR>
		<CONSTANT_ALPHA public="1" get="inline" set="null" line="92" static="1"><x path="Int"/></CONSTANT_ALPHA>
		<ONE_MINUS_CONSTANT_ALPHA public="1" get="inline" set="null" line="93" static="1"><x path="Int"/></ONE_MINUS_CONSTANT_ALPHA>
		<BLEND_COLOR public="1" get="inline" set="null" line="94" static="1"><x path="Int"/></BLEND_COLOR>
		<ARRAY_BUFFER public="1" get="inline" set="null" line="97" static="1"><x path="Int"/></ARRAY_BUFFER>
		<ELEMENT_ARRAY_BUFFER public="1" get="inline" set="null" line="98" static="1"><x path="Int"/></ELEMENT_ARRAY_BUFFER>
		<ARRAY_BUFFER_BINDING public="1" get="inline" set="null" line="99" static="1"><x path="Int"/></ARRAY_BUFFER_BINDING>
		<ELEMENT_ARRAY_BUFFER_BINDING public="1" get="inline" set="null" line="100" static="1"><x path="Int"/></ELEMENT_ARRAY_BUFFER_BINDING>
		<STREAM_DRAW public="1" get="inline" set="null" line="102" static="1"><x path="Int"/></STREAM_DRAW>
		<STATIC_DRAW public="1" get="inline" set="null" line="103" static="1"><x path="Int"/></STATIC_DRAW>
		<DYNAMIC_DRAW public="1" get="inline" set="null" line="104" static="1"><x path="Int"/></DYNAMIC_DRAW>
		<BUFFER_SIZE public="1" get="inline" set="null" line="106" static="1"><x path="Int"/></BUFFER_SIZE>
		<BUFFER_USAGE public="1" get="inline" set="null" line="107" static="1"><x path="Int"/></BUFFER_USAGE>
		<CURRENT_VERTEX_ATTRIB public="1" get="inline" set="null" line="109" static="1"><x path="Int"/></CURRENT_VERTEX_ATTRIB>
		<FRONT public="1" get="inline" set="null" line="112" static="1"><x path="Int"/></FRONT>
		<BACK public="1" get="inline" set="null" line="113" static="1"><x path="Int"/></BACK>
		<FRONT_AND_BACK public="1" get="inline" set="null" line="114" static="1"><x path="Int"/></FRONT_AND_BACK>
		<CULL_FACE public="1" get="inline" set="null" line="127" static="1"><x path="Int"/></CULL_FACE>
		<BLEND public="1" get="inline" set="null" line="128" static="1"><x path="Int"/></BLEND>
		<DITHER public="1" get="inline" set="null" line="129" static="1"><x path="Int"/></DITHER>
		<STENCIL_TEST public="1" get="inline" set="null" line="130" static="1"><x path="Int"/></STENCIL_TEST>
		<DEPTH_TEST public="1" get="inline" set="null" line="131" static="1"><x path="Int"/></DEPTH_TEST>
		<SCISSOR_TEST public="1" get="inline" set="null" line="132" static="1"><x path="Int"/></SCISSOR_TEST>
		<POLYGON_OFFSET_FILL public="1" get="inline" set="null" line="133" static="1"><x path="Int"/></POLYGON_OFFSET_FILL>
		<SAMPLE_ALPHA_TO_COVERAGE public="1" get="inline" set="null" line="134" static="1"><x path="Int"/></SAMPLE_ALPHA_TO_COVERAGE>
		<SAMPLE_COVERAGE public="1" get="inline" set="null" line="135" static="1"><x path="Int"/></SAMPLE_COVERAGE>
		<NO_ERROR public="1" get="inline" set="null" line="138" static="1"><x path="Int"/></NO_ERROR>
		<INVALID_ENUM public="1" get="inline" set="null" line="139" static="1"><x path="Int"/></INVALID_ENUM>
		<INVALID_VALUE public="1" get="inline" set="null" line="140" static="1"><x path="Int"/></INVALID_VALUE>
		<INVALID_OPERATION public="1" get="inline" set="null" line="141" static="1"><x path="Int"/></INVALID_OPERATION>
		<OUT_OF_MEMORY public="1" get="inline" set="null" line="142" static="1"><x path="Int"/></OUT_OF_MEMORY>
		<CW public="1" get="inline" set="null" line="145" static="1"><x path="Int"/></CW>
		<CCW public="1" get="inline" set="null" line="146" static="1"><x path="Int"/></CCW>
		<LINE_WIDTH public="1" get="inline" set="null" line="149" static="1"><x path="Int"/></LINE_WIDTH>
		<ALIASED_POINT_SIZE_RANGE public="1" get="inline" set="null" line="150" static="1"><x path="Int"/></ALIASED_POINT_SIZE_RANGE>
		<ALIASED_LINE_WIDTH_RANGE public="1" get="inline" set="null" line="151" static="1"><x path="Int"/></ALIASED_LINE_WIDTH_RANGE>
		<CULL_FACE_MODE public="1" get="inline" set="null" line="152" static="1"><x path="Int"/></CULL_FACE_MODE>
		<FRONT_FACE public="1" get="inline" set="null" line="153" static="1"><x path="Int"/></FRONT_FACE>
		<DEPTH_RANGE public="1" get="inline" set="null" line="154" static="1"><x path="Int"/></DEPTH_RANGE>
		<DEPTH_WRITEMASK public="1" get="inline" set="null" line="155" static="1"><x path="Int"/></DEPTH_WRITEMASK>
		<DEPTH_CLEAR_VALUE public="1" get="inline" set="null" line="156" static="1"><x path="Int"/></DEPTH_CLEAR_VALUE>
		<DEPTH_FUNC public="1" get="inline" set="null" line="157" static="1"><x path="Int"/></DEPTH_FUNC>
		<STENCIL_CLEAR_VALUE public="1" get="inline" set="null" line="158" static="1"><x path="Int"/></STENCIL_CLEAR_VALUE>
		<STENCIL_FUNC public="1" get="inline" set="null" line="159" static="1"><x path="Int"/></STENCIL_FUNC>
		<STENCIL_FAIL public="1" get="inline" set="null" line="160" static="1"><x path="Int"/></STENCIL_FAIL>
		<STENCIL_PASS_DEPTH_FAIL public="1" get="inline" set="null" line="161" static="1"><x path="Int"/></STENCIL_PASS_DEPTH_FAIL>
		<STENCIL_PASS_DEPTH_PASS public="1" get="inline" set="null" line="162" static="1"><x path="Int"/></STENCIL_PASS_DEPTH_PASS>
		<STENCIL_REF public="1" get="inline" set="null" line="163" static="1"><x path="Int"/></STENCIL_REF>
		<STENCIL_VALUE_MASK public="1" get="inline" set="null" line="164" static="1"><x path="Int"/></STENCIL_VALUE_MASK>
		<STENCIL_WRITEMASK public="1" get="inline" set="null" line="165" static="1"><x path="Int"/></STENCIL_WRITEMASK>
		<STENCIL_BACK_FUNC public="1" get="inline" set="null" line="166" static="1"><x path="Int"/></STENCIL_BACK_FUNC>
		<STENCIL_BACK_FAIL public="1" get="inline" set="null" line="167" static="1"><x path="Int"/></STENCIL_BACK_FAIL>
		<STENCIL_BACK_PASS_DEPTH_FAIL public="1" get="inline" set="null" line="168" static="1"><x path="Int"/></STENCIL_BACK_PASS_DEPTH_FAIL>
		<STENCIL_BACK_PASS_DEPTH_PASS public="1" get="inline" set="null" line="169" static="1"><x path="Int"/></STENCIL_BACK_PASS_DEPTH_PASS>
		<STENCIL_BACK_REF public="1" get="inline" set="null" line="170" static="1"><x path="Int"/></STENCIL_BACK_REF>
		<STENCIL_BACK_VALUE_MASK public="1" get="inline" set="null" line="171" static="1"><x path="Int"/></STENCIL_BACK_VALUE_MASK>
		<STENCIL_BACK_WRITEMASK public="1" get="inline" set="null" line="172" static="1"><x path="Int"/></STENCIL_BACK_WRITEMASK>
		<VIEWPORT public="1" get="inline" set="null" line="173" static="1"><x path="Int"/></VIEWPORT>
		<SCISSOR_BOX public="1" get="inline" set="null" line="174" static="1"><x path="Int"/></SCISSOR_BOX>
		<COLOR_CLEAR_VALUE public="1" get="inline" set="null" line="176" static="1"><x path="Int"/></COLOR_CLEAR_VALUE>
		<COLOR_WRITEMASK public="1" get="inline" set="null" line="177" static="1"><x path="Int"/></COLOR_WRITEMASK>
		<UNPACK_ALIGNMENT public="1" get="inline" set="null" line="178" static="1"><x path="Int"/></UNPACK_ALIGNMENT>
		<PACK_ALIGNMENT public="1" get="inline" set="null" line="179" static="1"><x path="Int"/></PACK_ALIGNMENT>
		<MAX_TEXTURE_SIZE public="1" get="inline" set="null" line="180" static="1"><x path="Int"/></MAX_TEXTURE_SIZE>
		<MAX_VIEWPORT_DIMS public="1" get="inline" set="null" line="181" static="1"><x path="Int"/></MAX_VIEWPORT_DIMS>
		<SUBPIXEL_BITS public="1" get="inline" set="null" line="182" static="1"><x path="Int"/></SUBPIXEL_BITS>
		<RED_BITS public="1" get="inline" set="null" line="183" static="1"><x path="Int"/></RED_BITS>
		<GREEN_BITS public="1" get="inline" set="null" line="184" static="1"><x path="Int"/></GREEN_BITS>
		<BLUE_BITS public="1" get="inline" set="null" line="185" static="1"><x path="Int"/></BLUE_BITS>
		<ALPHA_BITS public="1" get="inline" set="null" line="186" static="1"><x path="Int"/></ALPHA_BITS>
		<DEPTH_BITS public="1" get="inline" set="null" line="187" static="1"><x path="Int"/></DEPTH_BITS>
		<STENCIL_BITS public="1" get="inline" set="null" line="188" static="1"><x path="Int"/></STENCIL_BITS>
		<POLYGON_OFFSET_UNITS public="1" get="inline" set="null" line="189" static="1"><x path="Int"/></POLYGON_OFFSET_UNITS>
		<POLYGON_OFFSET_FACTOR public="1" get="inline" set="null" line="191" static="1"><x path="Int"/></POLYGON_OFFSET_FACTOR>
		<TEXTURE_BINDING_2D public="1" get="inline" set="null" line="192" static="1"><x path="Int"/></TEXTURE_BINDING_2D>
		<SAMPLE_BUFFERS public="1" get="inline" set="null" line="193" static="1"><x path="Int"/></SAMPLE_BUFFERS>
		<SAMPLES public="1" get="inline" set="null" line="194" static="1"><x path="Int"/></SAMPLES>
		<SAMPLE_COVERAGE_VALUE public="1" get="inline" set="null" line="195" static="1"><x path="Int"/></SAMPLE_COVERAGE_VALUE>
		<SAMPLE_COVERAGE_INVERT public="1" get="inline" set="null" line="196" static="1"><x path="Int"/></SAMPLE_COVERAGE_INVERT>
		<COMPRESSED_TEXTURE_FORMATS public="1" get="inline" set="null" line="203" static="1"><x path="Int"/></COMPRESSED_TEXTURE_FORMATS>
		<DONT_CARE public="1" get="inline" set="null" line="206" static="1"><x path="Int"/></DONT_CARE>
		<FASTEST public="1" get="inline" set="null" line="207" static="1"><x path="Int"/></FASTEST>
		<NICEST public="1" get="inline" set="null" line="208" static="1"><x path="Int"/></NICEST>
		<GENERATE_MIPMAP_HINT public="1" get="inline" set="null" line="211" static="1"><x path="Int"/></GENERATE_MIPMAP_HINT>
		<BYTE public="1" get="inline" set="null" line="214" static="1"><x path="Int"/></BYTE>
		<UNSIGNED_BYTE public="1" get="inline" set="null" line="215" static="1"><x path="Int"/></UNSIGNED_BYTE>
		<SHORT public="1" get="inline" set="null" line="216" static="1"><x path="Int"/></SHORT>
		<UNSIGNED_SHORT public="1" get="inline" set="null" line="217" static="1"><x path="Int"/></UNSIGNED_SHORT>
		<INT public="1" get="inline" set="null" line="218" static="1"><x path="Int"/></INT>
		<UNSIGNED_INT public="1" get="inline" set="null" line="219" static="1"><x path="Int"/></UNSIGNED_INT>
		<FLOAT public="1" get="inline" set="null" line="220" static="1"><x path="Int"/></FLOAT>
		<DEPTH_COMPONENT public="1" get="inline" set="null" line="223" static="1"><x path="Int"/></DEPTH_COMPONENT>
		<ALPHA public="1" get="inline" set="null" line="224" static="1"><x path="Int"/></ALPHA>
		<RGB public="1" get="inline" set="null" line="225" static="1"><x path="Int"/></RGB>
		<RGBA public="1" get="inline" set="null" line="226" static="1"><x path="Int"/></RGBA>
		<LUMINANCE public="1" get="inline" set="null" line="227" static="1"><x path="Int"/></LUMINANCE>
		<LUMINANCE_ALPHA public="1" get="inline" set="null" line="228" static="1"><x path="Int"/></LUMINANCE_ALPHA>
		<UNSIGNED_SHORT_4_4_4_4 public="1" get="inline" set="null" line="232" static="1"><x path="Int"/></UNSIGNED_SHORT_4_4_4_4>
		<UNSIGNED_SHORT_5_5_5_1 public="1" get="inline" set="null" line="233" static="1"><x path="Int"/></UNSIGNED_SHORT_5_5_5_1>
		<UNSIGNED_SHORT_5_6_5 public="1" get="inline" set="null" line="234" static="1"><x path="Int"/></UNSIGNED_SHORT_5_6_5>
		<FRAGMENT_SHADER public="1" get="inline" set="null" line="237" static="1"><x path="Int"/></FRAGMENT_SHADER>
		<VERTEX_SHADER public="1" get="inline" set="null" line="238" static="1"><x path="Int"/></VERTEX_SHADER>
		<MAX_VERTEX_ATTRIBS public="1" get="inline" set="null" line="239" static="1"><x path="Int"/></MAX_VERTEX_ATTRIBS>
		<MAX_VERTEX_UNIFORM_VECTORS public="1" get="inline" set="null" line="240" static="1"><x path="Int"/></MAX_VERTEX_UNIFORM_VECTORS>
		<MAX_VARYING_VECTORS public="1" get="inline" set="null" line="241" static="1"><x path="Int"/></MAX_VARYING_VECTORS>
		<MAX_COMBINED_TEXTURE_IMAGE_UNITS public="1" get="inline" set="null" line="242" static="1"><x path="Int"/></MAX_COMBINED_TEXTURE_IMAGE_UNITS>
		<MAX_VERTEX_TEXTURE_IMAGE_UNITS public="1" get="inline" set="null" line="243" static="1"><x path="Int"/></MAX_VERTEX_TEXTURE_IMAGE_UNITS>
		<MAX_TEXTURE_IMAGE_UNITS public="1" get="inline" set="null" line="244" static="1"><x path="Int"/></MAX_TEXTURE_IMAGE_UNITS>
		<MAX_FRAGMENT_UNIFORM_VECTORS public="1" get="inline" set="null" line="245" static="1"><x path="Int"/></MAX_FRAGMENT_UNIFORM_VECTORS>
		<SHADER_TYPE public="1" get="inline" set="null" line="246" static="1"><x path="Int"/></SHADER_TYPE>
		<DELETE_STATUS public="1" get="inline" set="null" line="247" static="1"><x path="Int"/></DELETE_STATUS>
		<LINK_STATUS public="1" get="inline" set="null" line="248" static="1"><x path="Int"/></LINK_STATUS>
		<VALIDATE_STATUS public="1" get="inline" set="null" line="249" static="1"><x path="Int"/></VALIDATE_STATUS>
		<ATTACHED_SHADERS public="1" get="inline" set="null" line="250" static="1"><x path="Int"/></ATTACHED_SHADERS>
		<ACTIVE_UNIFORMS public="1" get="inline" set="null" line="251" static="1"><x path="Int"/></ACTIVE_UNIFORMS>
		<ACTIVE_ATTRIBUTES public="1" get="inline" set="null" line="252" static="1"><x path="Int"/></ACTIVE_ATTRIBUTES>
		<SHADING_LANGUAGE_VERSION public="1" get="inline" set="null" line="253" static="1"><x path="Int"/></SHADING_LANGUAGE_VERSION>
		<CURRENT_PROGRAM public="1" get="inline" set="null" line="254" static="1"><x path="Int"/></CURRENT_PROGRAM>
		<NEVER public="1" get="inline" set="null" line="257" static="1"><x path="Int"/></NEVER>
		<LESS public="1" get="inline" set="null" line="258" static="1"><x path="Int"/></LESS>
		<EQUAL public="1" get="inline" set="null" line="259" static="1"><x path="Int"/></EQUAL>
		<LEQUAL public="1" get="inline" set="null" line="260" static="1"><x path="Int"/></LEQUAL>
		<GREATER public="1" get="inline" set="null" line="261" static="1"><x path="Int"/></GREATER>
		<NOTEQUAL public="1" get="inline" set="null" line="262" static="1"><x path="Int"/></NOTEQUAL>
		<GEQUAL public="1" get="inline" set="null" line="263" static="1"><x path="Int"/></GEQUAL>
		<ALWAYS public="1" get="inline" set="null" line="264" static="1"><x path="Int"/></ALWAYS>
		<KEEP public="1" get="inline" set="null" line="268" static="1"><x path="Int"/></KEEP>
		<REPLACE public="1" get="inline" set="null" line="269" static="1"><x path="Int"/></REPLACE>
		<INCR public="1" get="inline" set="null" line="270" static="1"><x path="Int"/></INCR>
		<DECR public="1" get="inline" set="null" line="271" static="1"><x path="Int"/></DECR>
		<INVERT public="1" get="inline" set="null" line="272" static="1"><x path="Int"/></INVERT>
		<INCR_WRAP public="1" get="inline" set="null" line="273" static="1"><x path="Int"/></INCR_WRAP>
		<DECR_WRAP public="1" get="inline" set="null" line="274" static="1"><x path="Int"/></DECR_WRAP>
		<VENDOR public="1" get="inline" set="null" line="277" static="1"><x path="Int"/></VENDOR>
		<RENDERER public="1" get="inline" set="null" line="278" static="1"><x path="Int"/></RENDERER>
		<VERSION public="1" get="inline" set="null" line="279" static="1"><x path="Int"/></VERSION>
		<NEAREST public="1" get="inline" set="null" line="282" static="1"><x path="Int"/></NEAREST>
		<LINEAR public="1" get="inline" set="null" line="283" static="1"><x path="Int"/></LINEAR>
		<NEAREST_MIPMAP_NEAREST public="1" get="inline" set="null" line="288" static="1"><x path="Int"/></NEAREST_MIPMAP_NEAREST>
		<LINEAR_MIPMAP_NEAREST public="1" get="inline" set="null" line="289" static="1"><x path="Int"/></LINEAR_MIPMAP_NEAREST>
		<NEAREST_MIPMAP_LINEAR public="1" get="inline" set="null" line="290" static="1"><x path="Int"/></NEAREST_MIPMAP_LINEAR>
		<LINEAR_MIPMAP_LINEAR public="1" get="inline" set="null" line="291" static="1"><x path="Int"/></LINEAR_MIPMAP_LINEAR>
		<TEXTURE_MAG_FILTER public="1" get="inline" set="null" line="294" static="1"><x path="Int"/></TEXTURE_MAG_FILTER>
		<TEXTURE_MIN_FILTER public="1" get="inline" set="null" line="295" static="1"><x path="Int"/></TEXTURE_MIN_FILTER>
		<TEXTURE_WRAP_S public="1" get="inline" set="null" line="296" static="1"><x path="Int"/></TEXTURE_WRAP_S>
		<TEXTURE_WRAP_T public="1" get="inline" set="null" line="297" static="1"><x path="Int"/></TEXTURE_WRAP_T>
		<TEXTURE_2D public="1" get="inline" set="null" line="300" static="1"><x path="Int"/></TEXTURE_2D>
		<TEXTURE public="1" get="inline" set="null" line="301" static="1"><x path="Int"/></TEXTURE>
		<TEXTURE_CUBE_MAP public="1" get="inline" set="null" line="303" static="1"><x path="Int"/></TEXTURE_CUBE_MAP>
		<TEXTURE_BINDING_CUBE_MAP public="1" get="inline" set="null" line="304" static="1"><x path="Int"/></TEXTURE_BINDING_CUBE_MAP>
		<TEXTURE_CUBE_MAP_POSITIVE_X public="1" get="inline" set="null" line="305" static="1"><x path="Int"/></TEXTURE_CUBE_MAP_POSITIVE_X>
		<TEXTURE_CUBE_MAP_NEGATIVE_X public="1" get="inline" set="null" line="306" static="1"><x path="Int"/></TEXTURE_CUBE_MAP_NEGATIVE_X>
		<TEXTURE_CUBE_MAP_POSITIVE_Y public="1" get="inline" set="null" line="307" static="1"><x path="Int"/></TEXTURE_CUBE_MAP_POSITIVE_Y>
		<TEXTURE_CUBE_MAP_NEGATIVE_Y public="1" get="inline" set="null" line="308" static="1"><x path="Int"/></TEXTURE_CUBE_MAP_NEGATIVE_Y>
		<TEXTURE_CUBE_MAP_POSITIVE_Z public="1" get="inline" set="null" line="309" static="1"><x path="Int"/></TEXTURE_CUBE_MAP_POSITIVE_Z>
		<TEXTURE_CUBE_MAP_NEGATIVE_Z public="1" get="inline" set="null" line="310" static="1"><x path="Int"/></TEXTURE_CUBE_MAP_NEGATIVE_Z>
		<MAX_CUBE_MAP_TEXTURE_SIZE public="1" get="inline" set="null" line="311" static="1"><x path="Int"/></MAX_CUBE_MAP_TEXTURE_SIZE>
		<TEXTURE0 public="1" get="inline" set="null" line="314" static="1"><x path="Int"/></TEXTURE0>
		<TEXTURE1 public="1" get="inline" set="null" line="315" static="1"><x path="Int"/></TEXTURE1>
		<TEXTURE2 public="1" get="inline" set="null" line="316" static="1"><x path="Int"/></TEXTURE2>
		<TEXTURE3 public="1" get="inline" set="null" line="317" static="1"><x path="Int"/></TEXTURE3>
		<TEXTURE4 public="1" get="inline" set="null" line="318" static="1"><x path="Int"/></TEXTURE4>
		<TEXTURE5 public="1" get="inline" set="null" line="319" static="1"><x path="Int"/></TEXTURE5>
		<TEXTURE6 public="1" get="inline" set="null" line="320" static="1"><x path="Int"/></TEXTURE6>
		<TEXTURE7 public="1" get="inline" set="null" line="321" static="1"><x path="Int"/></TEXTURE7>
		<TEXTURE8 public="1" get="inline" set="null" line="322" static="1"><x path="Int"/></TEXTURE8>
		<TEXTURE9 public="1" get="inline" set="null" line="323" static="1"><x path="Int"/></TEXTURE9>
		<TEXTURE10 public="1" get="inline" set="null" line="324" static="1"><x path="Int"/></TEXTURE10>
		<TEXTURE11 public="1" get="inline" set="null" line="325" static="1"><x path="Int"/></TEXTURE11>
		<TEXTURE12 public="1" get="inline" set="null" line="326" static="1"><x path="Int"/></TEXTURE12>
		<TEXTURE13 public="1" get="inline" set="null" line="327" static="1"><x path="Int"/></TEXTURE13>
		<TEXTURE14 public="1" get="inline" set="null" line="328" static="1"><x path="Int"/></TEXTURE14>
		<TEXTURE15 public="1" get="inline" set="null" line="329" static="1"><x path="Int"/></TEXTURE15>
		<TEXTURE16 public="1" get="inline" set="null" line="330" static="1"><x path="Int"/></TEXTURE16>
		<TEXTURE17 public="1" get="inline" set="null" line="331" static="1"><x path="Int"/></TEXTURE17>
		<TEXTURE18 public="1" get="inline" set="null" line="332" static="1"><x path="Int"/></TEXTURE18>
		<TEXTURE19 public="1" get="inline" set="null" line="333" static="1"><x path="Int"/></TEXTURE19>
		<TEXTURE20 public="1" get="inline" set="null" line="334" static="1"><x path="Int"/></TEXTURE20>
		<TEXTURE21 public="1" get="inline" set="null" line="335" static="1"><x path="Int"/></TEXTURE21>
		<TEXTURE22 public="1" get="inline" set="null" line="336" static="1"><x path="Int"/></TEXTURE22>
		<TEXTURE23 public="1" get="inline" set="null" line="337" static="1"><x path="Int"/></TEXTURE23>
		<TEXTURE24 public="1" get="inline" set="null" line="338" static="1"><x path="Int"/></TEXTURE24>
		<TEXTURE25 public="1" get="inline" set="null" line="339" static="1"><x path="Int"/></TEXTURE25>
		<TEXTURE26 public="1" get="inline" set="null" line="340" static="1"><x path="Int"/></TEXTURE26>
		<TEXTURE27 public="1" get="inline" set="null" line="341" static="1"><x path="Int"/></TEXTURE27>
		<TEXTURE28 public="1" get="inline" set="null" line="342" static="1"><x path="Int"/></TEXTURE28>
		<TEXTURE29 public="1" get="inline" set="null" line="343" static="1"><x path="Int"/></TEXTURE29>
		<TEXTURE30 public="1" get="inline" set="null" line="344" static="1"><x path="Int"/></TEXTURE30>
		<TEXTURE31 public="1" get="inline" set="null" line="345" static="1"><x path="Int"/></TEXTURE31>
		<ACTIVE_TEXTURE public="1" get="inline" set="null" line="346" static="1"><x path="Int"/></ACTIVE_TEXTURE>
		<REPEAT public="1" get="inline" set="null" line="349" static="1"><x path="Int"/></REPEAT>
		<CLAMP_TO_EDGE public="1" get="inline" set="null" line="350" static="1"><x path="Int"/></CLAMP_TO_EDGE>
		<MIRRORED_REPEAT public="1" get="inline" set="null" line="351" static="1"><x path="Int"/></MIRRORED_REPEAT>
		<FLOAT_VEC2 public="1" get="inline" set="null" line="354" static="1"><x path="Int"/></FLOAT_VEC2>
		<FLOAT_VEC3 public="1" get="inline" set="null" line="355" static="1"><x path="Int"/></FLOAT_VEC3>
		<FLOAT_VEC4 public="1" get="inline" set="null" line="356" static="1"><x path="Int"/></FLOAT_VEC4>
		<INT_VEC2 public="1" get="inline" set="null" line="357" static="1"><x path="Int"/></INT_VEC2>
		<INT_VEC3 public="1" get="inline" set="null" line="358" static="1"><x path="Int"/></INT_VEC3>
		<INT_VEC4 public="1" get="inline" set="null" line="359" static="1"><x path="Int"/></INT_VEC4>
		<BOOL public="1" get="inline" set="null" line="360" static="1"><x path="Int"/></BOOL>
		<BOOL_VEC2 public="1" get="inline" set="null" line="361" static="1"><x path="Int"/></BOOL_VEC2>
		<BOOL_VEC3 public="1" get="inline" set="null" line="362" static="1"><x path="Int"/></BOOL_VEC3>
		<BOOL_VEC4 public="1" get="inline" set="null" line="363" static="1"><x path="Int"/></BOOL_VEC4>
		<FLOAT_MAT2 public="1" get="inline" set="null" line="364" static="1"><x path="Int"/></FLOAT_MAT2>
		<FLOAT_MAT3 public="1" get="inline" set="null" line="365" static="1"><x path="Int"/></FLOAT_MAT3>
		<FLOAT_MAT4 public="1" get="inline" set="null" line="366" static="1"><x path="Int"/></FLOAT_MAT4>
		<SAMPLER_2D public="1" get="inline" set="null" line="367" static="1"><x path="Int"/></SAMPLER_2D>
		<SAMPLER_CUBE public="1" get="inline" set="null" line="368" static="1"><x path="Int"/></SAMPLER_CUBE>
		<VERTEX_ATTRIB_ARRAY_ENABLED public="1" get="inline" set="null" line="371" static="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_ENABLED>
		<VERTEX_ATTRIB_ARRAY_SIZE public="1" get="inline" set="null" line="372" static="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_SIZE>
		<VERTEX_ATTRIB_ARRAY_STRIDE public="1" get="inline" set="null" line="373" static="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_STRIDE>
		<VERTEX_ATTRIB_ARRAY_TYPE public="1" get="inline" set="null" line="374" static="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_TYPE>
		<VERTEX_ATTRIB_ARRAY_NORMALIZED public="1" get="inline" set="null" line="375" static="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_NORMALIZED>
		<VERTEX_ATTRIB_ARRAY_POINTER public="1" get="inline" set="null" line="376" static="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_POINTER>
		<VERTEX_ATTRIB_ARRAY_BUFFER_BINDING public="1" get="inline" set="null" line="377" static="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_BUFFER_BINDING>
		<VERTEX_PROGRAM_POINT_SIZE public="1" get="inline" set="null" line="380" static="1"><x path="Int"/></VERTEX_PROGRAM_POINT_SIZE>
		<POINT_SPRITE public="1" get="inline" set="null" line="381" static="1"><x path="Int"/></POINT_SPRITE>
		<COMPILE_STATUS public="1" get="inline" set="null" line="384" static="1"><x path="Int"/></COMPILE_STATUS>
		<LOW_FLOAT public="1" get="inline" set="null" line="387" static="1"><x path="Int"/></LOW_FLOAT>
		<MEDIUM_FLOAT public="1" get="inline" set="null" line="388" static="1"><x path="Int"/></MEDIUM_FLOAT>
		<HIGH_FLOAT public="1" get="inline" set="null" line="389" static="1"><x path="Int"/></HIGH_FLOAT>
		<LOW_INT public="1" get="inline" set="null" line="390" static="1"><x path="Int"/></LOW_INT>
		<MEDIUM_INT public="1" get="inline" set="null" line="391" static="1"><x path="Int"/></MEDIUM_INT>
		<HIGH_INT public="1" get="inline" set="null" line="392" static="1"><x path="Int"/></HIGH_INT>
		<FRAMEBUFFER public="1" get="inline" set="null" line="395" static="1"><x path="Int"/></FRAMEBUFFER>
		<RENDERBUFFER public="1" get="inline" set="null" line="396" static="1"><x path="Int"/></RENDERBUFFER>
		<RGBA4 public="1" get="inline" set="null" line="398" static="1"><x path="Int"/></RGBA4>
		<RGB5_A1 public="1" get="inline" set="null" line="399" static="1"><x path="Int"/></RGB5_A1>
		<RGB565 public="1" get="inline" set="null" line="400" static="1"><x path="Int"/></RGB565>
		<DEPTH_COMPONENT16 public="1" get="inline" set="null" line="401" static="1"><x path="Int"/></DEPTH_COMPONENT16>
		<STENCIL_INDEX public="1" get="inline" set="null" line="402" static="1"><x path="Int"/></STENCIL_INDEX>
		<STENCIL_INDEX8 public="1" get="inline" set="null" line="403" static="1"><x path="Int"/></STENCIL_INDEX8>
		<DEPTH_STENCIL public="1" get="inline" set="null" line="404" static="1"><x path="Int"/></DEPTH_STENCIL>
		<RENDERBUFFER_WIDTH public="1" get="inline" set="null" line="406" static="1"><x path="Int"/></RENDERBUFFER_WIDTH>
		<RENDERBUFFER_HEIGHT public="1" get="inline" set="null" line="407" static="1"><x path="Int"/></RENDERBUFFER_HEIGHT>
		<RENDERBUFFER_INTERNAL_FORMAT public="1" get="inline" set="null" line="408" static="1"><x path="Int"/></RENDERBUFFER_INTERNAL_FORMAT>
		<RENDERBUFFER_RED_SIZE public="1" get="inline" set="null" line="409" static="1"><x path="Int"/></RENDERBUFFER_RED_SIZE>
		<RENDERBUFFER_GREEN_SIZE public="1" get="inline" set="null" line="410" static="1"><x path="Int"/></RENDERBUFFER_GREEN_SIZE>
		<RENDERBUFFER_BLUE_SIZE public="1" get="inline" set="null" line="411" static="1"><x path="Int"/></RENDERBUFFER_BLUE_SIZE>
		<RENDERBUFFER_ALPHA_SIZE public="1" get="inline" set="null" line="412" static="1"><x path="Int"/></RENDERBUFFER_ALPHA_SIZE>
		<RENDERBUFFER_DEPTH_SIZE public="1" get="inline" set="null" line="413" static="1"><x path="Int"/></RENDERBUFFER_DEPTH_SIZE>
		<RENDERBUFFER_STENCIL_SIZE public="1" get="inline" set="null" line="414" static="1"><x path="Int"/></RENDERBUFFER_STENCIL_SIZE>
		<FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE public="1" get="inline" set="null" line="416" static="1"><x path="Int"/></FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE>
		<FRAMEBUFFER_ATTACHMENT_OBJECT_NAME public="1" get="inline" set="null" line="417" static="1"><x path="Int"/></FRAMEBUFFER_ATTACHMENT_OBJECT_NAME>
		<FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL public="1" get="inline" set="null" line="418" static="1"><x path="Int"/></FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL>
		<FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE public="1" get="inline" set="null" line="419" static="1"><x path="Int"/></FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE>
		<COLOR_ATTACHMENT0 public="1" get="inline" set="null" line="421" static="1"><x path="Int"/></COLOR_ATTACHMENT0>
		<DEPTH_ATTACHMENT public="1" get="inline" set="null" line="422" static="1"><x path="Int"/></DEPTH_ATTACHMENT>
		<STENCIL_ATTACHMENT public="1" get="inline" set="null" line="423" static="1"><x path="Int"/></STENCIL_ATTACHMENT>
		<DEPTH_STENCIL_ATTACHMENT public="1" get="inline" set="null" line="424" static="1"><x path="Int"/></DEPTH_STENCIL_ATTACHMENT>
		<NONE public="1" get="inline" set="null" line="426" static="1"><x path="Int"/></NONE>
		<FRAMEBUFFER_COMPLETE public="1" get="inline" set="null" line="428" static="1"><x path="Int"/></FRAMEBUFFER_COMPLETE>
		<FRAMEBUFFER_INCOMPLETE_ATTACHMENT public="1" get="inline" set="null" line="429" static="1"><x path="Int"/></FRAMEBUFFER_INCOMPLETE_ATTACHMENT>
		<FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT public="1" get="inline" set="null" line="430" static="1"><x path="Int"/></FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT>
		<FRAMEBUFFER_INCOMPLETE_DIMENSIONS public="1" get="inline" set="null" line="431" static="1"><x path="Int"/></FRAMEBUFFER_INCOMPLETE_DIMENSIONS>
		<FRAMEBUFFER_UNSUPPORTED public="1" get="inline" set="null" line="432" static="1"><x path="Int"/></FRAMEBUFFER_UNSUPPORTED>
		<FRAMEBUFFER_BINDING public="1" get="inline" set="null" line="434" static="1"><x path="Int"/></FRAMEBUFFER_BINDING>
		<RENDERBUFFER_BINDING public="1" get="inline" set="null" line="435" static="1"><x path="Int"/></RENDERBUFFER_BINDING>
		<MAX_RENDERBUFFER_SIZE public="1" get="inline" set="null" line="436" static="1"><x path="Int"/></MAX_RENDERBUFFER_SIZE>
		<INVALID_FRAMEBUFFER_OPERATION public="1" get="inline" set="null" line="438" static="1"><x path="Int"/></INVALID_FRAMEBUFFER_OPERATION>
		<UNPACK_FLIP_Y_WEBGL public="1" get="inline" set="null" line="441" static="1"><x path="Int"/></UNPACK_FLIP_Y_WEBGL>
		<UNPACK_PREMULTIPLY_ALPHA_WEBGL public="1" get="inline" set="null" line="442" static="1"><x path="Int"/></UNPACK_PREMULTIPLY_ALPHA_WEBGL>
		<CONTEXT_LOST_WEBGL public="1" get="inline" set="null" line="443" static="1"><x path="Int"/></CONTEXT_LOST_WEBGL>
		<UNPACK_COLORSPACE_CONVERSION_WEBGL public="1" get="inline" set="null" line="444" static="1"><x path="Int"/></UNPACK_COLORSPACE_CONVERSION_WEBGL>
		<BROWSER_DEFAULT_WEBGL public="1" get="inline" set="null" line="445" static="1"><x path="Int"/></BROWSER_DEFAULT_WEBGL>
		<drawingBufferHeight public="1" get="accessor" set="null" static="1"><x path="Int"/></drawingBufferHeight>
		<drawingBufferWidth public="1" get="accessor" set="null" static="1"><x path="Int"/></drawingBufferWidth>
		<version public="1" get="accessor" set="null" static="1"><x path="Int"/></version>
		<activeTexture public="1" set="method" line="451" static="1"><f a="texture">
	<x path="Int"/>
	<x path="Void"/>
</f></activeTexture>
		<attachShader public="1" set="method" line="453" static="1"><f a="program:shader">
	<c path="lime.gl.GLProgram"/>
	<c path="lime.gl.GLShader"/>
	<x path="Void"/>
</f></attachShader>
		<bindAttribLocation public="1" set="method" line="459" static="1"><f a="program:index:name">
	<c path="lime.gl.GLProgram"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></bindAttribLocation>
		<bindBuffer public="1" set="method" line="472" static="1"><f a="target:buffer">
	<x path="Int"/>
	<c path="lime.gl.GLBuffer"/>
	<x path="Void"/>
</f></bindBuffer>
		<bindFramebuffer public="1" set="method" line="477" static="1"><f a="target:framebuffer">
	<x path="Int"/>
	<c path="lime.gl.GLFramebuffer"/>
	<x path="Void"/>
</f></bindFramebuffer>
		<bindRenderbuffer public="1" set="method" line="482" static="1"><f a="target:renderbuffer">
	<x path="Int"/>
	<c path="lime.gl.GLRenderbuffer"/>
	<x path="Void"/>
</f></bindRenderbuffer>
		<bindTexture public="1" set="method" line="487" static="1"><f a="target:texture">
	<x path="Int"/>
	<c path="lime.gl.GLTexture"/>
	<x path="Void"/>
</f></bindTexture>
		<blendColor public="1" set="method" line="492" static="1"><f a="red:green:blue:alpha">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></blendColor>
		<blendEquation public="1" set="method" line="497" static="1"><f a="mode">
	<x path="Int"/>
	<x path="Void"/>
</f></blendEquation>
		<blendEquationSeparate public="1" set="method" line="502" static="1"><f a="modeRGB:modeAlpha">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blendEquationSeparate>
		<blendFunc public="1" set="method" line="507" static="1"><f a="sfactor:dfactor">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blendFunc>
		<blendFuncSeparate public="1" set="method" line="512" static="1"><f a="srcRGB:dstRGB:srcAlpha:dstAlpha">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blendFuncSeparate>
		<bufferData public="1" set="method" line="517" static="1"><f a="target:data:usage">
	<x path="Int"/>
	<c path="lime.utils.IMemoryRange"/>
	<x path="Int"/>
	<x path="Void"/>
</f></bufferData>
		<bufferSubData public="1" set="method" line="522" static="1"><f a="target:offset:data">
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.IMemoryRange"/>
	<x path="Void"/>
</f></bufferSubData>
		<checkFramebufferStatus public="1" set="method" line="527" static="1"><f a="target">
	<x path="Int"/>
	<x path="Int"/>
</f></checkFramebufferStatus>
		<clear public="1" set="method" line="532" static="1"><f a="mask">
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
		<clearColor public="1" set="method" line="537" static="1"><f a="red:green:blue:alpha">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></clearColor>
		<clearDepth public="1" set="method" line="542" static="1"><f a="depth">
	<x path="Float"/>
	<x path="Void"/>
</f></clearDepth>
		<clearStencil public="1" set="method" line="547" static="1"><f a="s">
	<x path="Int"/>
	<x path="Void"/>
</f></clearStencil>
		<colorMask public="1" set="method" line="552" static="1"><f a="red:green:blue:alpha">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></colorMask>
		<compileShader public="1" set="method" line="557" static="1"><f a="shader">
	<c path="lime.gl.GLShader"/>
	<x path="Void"/>
</f></compileShader>
		<compressedTexImage2D public="1" set="method" line="562" static="1"><f a="target:level:internalformat:width:height:border:data">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.IMemoryRange"/>
	<x path="Void"/>
</f></compressedTexImage2D>
		<compressedTexSubImage2D public="1" set="method" line="567" static="1"><f a="target:level:xoffset:yoffset:width:height:format:data">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.IMemoryRange"/>
	<x path="Void"/>
</f></compressedTexSubImage2D>
		<copyTexImage2D public="1" set="method" line="572" static="1"><f a="target:level:internalformat:x:y:width:height:border">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></copyTexImage2D>
		<copyTexSubImage2D public="1" set="method" line="577" static="1"><f a="target:level:xoffset:yoffset:x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></copyTexSubImage2D>
		<createBuffer public="1" set="method" line="582" static="1"><f a=""><c path="lime.gl.GLBuffer"/></f></createBuffer>
		<createFramebuffer public="1" set="method" line="587" static="1"><f a=""><c path="lime.gl.GLFramebuffer"/></f></createFramebuffer>
		<createProgram public="1" set="method" line="592" static="1"><f a=""><c path="lime.gl.GLProgram"/></f></createProgram>
		<createRenderbuffer public="1" set="method" line="597" static="1"><f a=""><c path="lime.gl.GLRenderbuffer"/></f></createRenderbuffer>
		<createShader public="1" set="method" line="602" static="1"><f a="type">
	<x path="Int"/>
	<c path="lime.gl.GLShader"/>
</f></createShader>
		<createTexture public="1" set="method" line="607" static="1"><f a=""><c path="lime.gl.GLTexture"/></f></createTexture>
		<cullFace public="1" set="method" line="612" static="1"><f a="mode">
	<x path="Int"/>
	<x path="Void"/>
</f></cullFace>
		<deleteBuffer public="1" set="method" line="617" static="1"><f a="buffer">
	<c path="lime.gl.GLBuffer"/>
	<x path="Void"/>
</f></deleteBuffer>
		<deleteFramebuffer public="1" set="method" line="623" static="1"><f a="framebuffer">
	<c path="lime.gl.GLFramebuffer"/>
	<x path="Void"/>
</f></deleteFramebuffer>
		<deleteProgram public="1" set="method" line="629" static="1"><f a="program">
	<c path="lime.gl.GLProgram"/>
	<x path="Void"/>
</f></deleteProgram>
		<deleteRenderbuffer public="1" set="method" line="635" static="1"><f a="renderbuffer">
	<c path="lime.gl.GLRenderbuffer"/>
	<x path="Void"/>
</f></deleteRenderbuffer>
		<deleteShader public="1" set="method" line="641" static="1"><f a="shader">
	<c path="lime.gl.GLShader"/>
	<x path="Void"/>
</f></deleteShader>
		<deleteTexture public="1" set="method" line="647" static="1"><f a="texture">
	<c path="lime.gl.GLTexture"/>
	<x path="Void"/>
</f></deleteTexture>
		<depthFunc public="1" set="method" line="653" static="1"><f a="func">
	<x path="Int"/>
	<x path="Void"/>
</f></depthFunc>
		<depthMask public="1" set="method" line="658" static="1"><f a="flag">
	<x path="Bool"/>
	<x path="Void"/>
</f></depthMask>
		<depthRange public="1" set="method" line="663" static="1"><f a="zNear:zFar">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></depthRange>
		<detachShader public="1" set="method" line="668" static="1"><f a="program:shader">
	<c path="lime.gl.GLProgram"/>
	<c path="lime.gl.GLShader"/>
	<x path="Void"/>
</f></detachShader>
		<disable public="1" set="method" line="673" static="1"><f a="cap">
	<x path="Int"/>
	<x path="Void"/>
</f></disable>
		<disableVertexAttribArray public="1" set="method" line="678" static="1"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></disableVertexAttribArray>
		<drawArrays public="1" set="method" line="683" static="1"><f a="mode:first:count">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawArrays>
		<drawElements public="1" set="method" line="688" static="1"><f a="mode:count:type:offset">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawElements>
		<enable public="1" set="method" line="693" static="1"><f a="cap">
	<x path="Int"/>
	<x path="Void"/>
</f></enable>
		<enableVertexAttribArray public="1" set="method" line="698" static="1"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></enableVertexAttribArray>
		<finish public="1" set="method" line="703" static="1"><f a=""><x path="Void"/></f></finish>
		<flush public="1" set="method" line="708" static="1"><f a=""><x path="Void"/></f></flush>
		<framebufferRenderbuffer public="1" set="method" line="713" static="1"><f a="target:attachment:renderbuffertarget:renderbuffer">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.gl.GLRenderbuffer"/>
	<x path="Void"/>
</f></framebufferRenderbuffer>
		<framebufferTexture2D public="1" set="method" line="718" static="1"><f a="target:attachment:textarget:texture:level">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.gl.GLTexture"/>
	<x path="Int"/>
	<x path="Void"/>
</f></framebufferTexture2D>
		<frontFace public="1" set="method" line="723" static="1"><f a="mode">
	<x path="Int"/>
	<x path="Void"/>
</f></frontFace>
		<generateMipmap public="1" set="method" line="728" static="1"><f a="target">
	<x path="Int"/>
	<x path="Void"/>
</f></generateMipmap>
		<getActiveAttrib public="1" set="method" line="733" static="1"><f a="program:index">
	<c path="lime.gl.GLProgram"/>
	<x path="Int"/>
	<t path="lime.gl.GLActiveInfo"/>
</f></getActiveAttrib>
		<getActiveUniform public="1" set="method" line="738" static="1"><f a="program:index">
	<c path="lime.gl.GLProgram"/>
	<x path="Int"/>
	<t path="lime.gl.GLActiveInfo"/>
</f></getActiveUniform>
		<getAttachedShaders public="1" set="method" line="743" static="1"><f a="program">
	<c path="lime.gl.GLProgram"/>
	<c path="Array"><c path="lime.gl.GLShader"/></c>
</f></getAttachedShaders>
		<getAttribLocation public="1" set="method" line="748" static="1"><f a="program:name">
	<c path="lime.gl.GLProgram"/>
	<c path="String"/>
	<x path="Int"/>
</f></getAttribLocation>
		<getBufferParameter public="1" set="method" line="753" static="1"><f a="target:pname">
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></getBufferParameter>
		<getContextAttributes public="1" set="method" line="758" static="1"><f a=""><t path="lime.gl.GLContextAttributes"/></f></getContextAttributes>
		<getError public="1" set="method" line="766" static="1"><f a=""><x path="Int"/></f></getError>
		<getExtension public="1" set="method" line="771" static="1"><f a="name">
	<c path="String"/>
	<d/>
</f></getExtension>
		<getFramebufferAttachmentParameter public="1" set="method" line="778" static="1"><f a="target:attachment:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></getFramebufferAttachmentParameter>
		<getParameter public="1" set="method" line="783" static="1"><f a="pname">
	<x path="Int"/>
	<d/>
</f></getParameter>
		<getProgramInfoLog public="1" set="method" line="788" static="1"><f a="program">
	<c path="lime.gl.GLProgram"/>
	<c path="String"/>
</f></getProgramInfoLog>
		<getProgramParameter public="1" set="method" line="793" static="1"><f a="program:pname">
	<c path="lime.gl.GLProgram"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getProgramParameter>
		<getRenderbufferParameter public="1" set="method" line="798" static="1"><f a="target:pname">
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></getRenderbufferParameter>
		<getShaderInfoLog public="1" set="method" line="803" static="1"><f a="shader">
	<c path="lime.gl.GLShader"/>
	<c path="String"/>
</f></getShaderInfoLog>
		<getShaderParameter public="1" set="method" line="808" static="1"><f a="shader:pname">
	<c path="lime.gl.GLShader"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getShaderParameter>
		<getShaderPrecisionFormat public="1" set="method" line="813" static="1"><f a="shadertype:precisiontype">
	<x path="Int"/>
	<x path="Int"/>
	<t path="lime.gl.native.ShaderPrecisionFormat"/>
</f></getShaderPrecisionFormat>
		<getShaderSource public="1" set="method" line="818" static="1"><f a="shader">
	<c path="lime.gl.GLShader"/>
	<c path="String"/>
</f></getShaderSource>
		<getSupportedExtensions public="1" set="method" line="823" static="1"><f a=""><c path="Array"><c path="String"/></c></f></getSupportedExtensions>
		<getTexParameter public="1" set="method" line="830" static="1"><f a="target:pname">
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></getTexParameter>
		<getUniform public="1" set="method" line="835" static="1"><f a="program:location">
	<c path="lime.gl.GLProgram"/>
	<t path="lime.gl.GLUniformLocation"/>
	<d/>
</f></getUniform>
		<getUniformLocation public="1" set="method" line="840" static="1"><f a="program:name">
	<c path="lime.gl.GLProgram"/>
	<c path="String"/>
	<d/>
</f></getUniformLocation>
		<getVertexAttrib public="1" set="method" line="845" static="1"><f a="index:pname">
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></getVertexAttrib>
		<getVertexAttribOffset public="1" set="method" line="850" static="1"><f a="index:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getVertexAttribOffset>
		<hint public="1" set="method" line="855" static="1"><f a="target:mode">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></hint>
		<isBuffer public="1" set="method" line="860" static="1"><f a="buffer">
	<c path="lime.gl.GLBuffer"/>
	<x path="Bool"/>
</f></isBuffer>
		<isEnabled public="1" set="method" line="867" static="1"><f a="cap">
	<x path="Int"/>
	<x path="Bool"/>
</f></isEnabled>
		<isFramebuffer public="1" set="method" line="872" static="1"><f a="framebuffer">
	<c path="lime.gl.GLFramebuffer"/>
	<x path="Bool"/>
</f></isFramebuffer>
		<isProgram public="1" set="method" line="877" static="1"><f a="program">
	<c path="lime.gl.GLProgram"/>
	<x path="Bool"/>
</f></isProgram>
		<isRenderbuffer public="1" set="method" line="882" static="1"><f a="renderbuffer">
	<c path="lime.gl.GLRenderbuffer"/>
	<x path="Bool"/>
</f></isRenderbuffer>
		<isShader public="1" set="method" line="887" static="1"><f a="shader">
	<c path="lime.gl.GLShader"/>
	<x path="Bool"/>
</f></isShader>
		<isTexture public="1" set="method" line="892" static="1"><f a="texture">
	<c path="lime.gl.GLTexture"/>
	<x path="Bool"/>
</f></isTexture>
		<lineWidth public="1" set="method" line="897" static="1"><f a="width">
	<x path="Float"/>
	<x path="Void"/>
</f></lineWidth>
		<linkProgram public="1" set="method" line="902" static="1"><f a="program">
	<c path="lime.gl.GLProgram"/>
	<x path="Void"/>
</f></linkProgram>
		<load set="method" line="907" static="1"><f a="inName:inArgCount">
	<c path="String"/>
	<x path="Int"/>
	<d/>
</f></load>
		<pixelStorei public="1" set="method" line="920" static="1"><f a="pname:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></pixelStorei>
		<polygonOffset public="1" set="method" line="925" static="1"><f a="factor:units">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></polygonOffset>
		<renderbufferStorage public="1" set="method" line="935" static="1"><f a="target:internalformat:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></renderbufferStorage>
		<sampleCoverage public="1" set="method" line="940" static="1"><f a="value:invert">
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></sampleCoverage>
		<scissor public="1" set="method" line="945" static="1"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></scissor>
		<shaderSource public="1" set="method" line="950" static="1"><f a="shader:source">
	<c path="lime.gl.GLShader"/>
	<c path="String"/>
	<x path="Void"/>
</f></shaderSource>
		<stencilFunc public="1" set="method" line="955" static="1"><f a="func:ref:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilFunc>
		<stencilFuncSeparate public="1" set="method" line="960" static="1"><f a="face:func:ref:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilFuncSeparate>
		<stencilMask public="1" set="method" line="965" static="1"><f a="mask">
	<x path="Int"/>
	<x path="Void"/>
</f></stencilMask>
		<stencilMaskSeparate public="1" set="method" line="970" static="1"><f a="face:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilMaskSeparate>
		<stencilOp public="1" set="method" line="975" static="1"><f a="fail:zfail:zpass">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilOp>
		<stencilOpSeparate public="1" set="method" line="980" static="1"><f a="face:fail:zfail:zpass">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilOpSeparate>
		<texImage2D public="1" set="method" line="985" static="1"><f a="target:level:internalformat:width:height:border:format:type:pixels">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Void"/>
</f></texImage2D>
		<texParameterf public="1" set="method" line="990" static="1"><f a="target:pname:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></texParameterf>
		<texParameteri public="1" set="method" line="995" static="1"><f a="target:pname:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></texParameteri>
		<texSubImage2D public="1" set="method" line="1000" static="1"><f a="target:level:xoffset:yoffset:width:height:format:type:pixels">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Void"/>
</f></texSubImage2D>
		<uniform1f public="1" set="method" line="1005" static="1"><f a="location:x">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform1f>
		<uniform1fv public="1" set="method" line="1010" static="1"><f a="location:x">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="lime.gl.native.LimeFloats"/>
	<x path="Void"/>
</f></uniform1fv>
		<uniform1i public="1" set="method" line="1015" static="1"><f a="location:x">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform1i>
		<uniform1iv public="1" set="method" line="1020" static="1"><f a="location:v">
	<t path="lime.gl.GLUniformLocation"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></uniform1iv>
		<uniform2f public="1" set="method" line="1025" static="1"><f a="location:x:y">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform2f>
		<uniform2fv public="1" set="method" line="1030" static="1"><f a="location:v">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="lime.gl.native.LimeFloats"/>
	<x path="Void"/>
</f></uniform2fv>
		<uniform2i public="1" set="method" line="1035" static="1"><f a="location:x:y">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform2i>
		<uniform2iv public="1" set="method" line="1040" static="1"><f a="location:v">
	<t path="lime.gl.GLUniformLocation"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></uniform2iv>
		<uniform3f public="1" set="method" line="1045" static="1"><f a="location:x:y:z">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform3f>
		<uniform3fv public="1" set="method" line="1050" static="1"><f a="location:v">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="lime.gl.native.LimeFloats"/>
	<x path="Void"/>
</f></uniform3fv>
		<uniform3i public="1" set="method" line="1055" static="1"><f a="location:x:y:z">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform3i>
		<uniform3iv public="1" set="method" line="1060" static="1"><f a="location:v">
	<t path="lime.gl.GLUniformLocation"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></uniform3iv>
		<uniform4f public="1" set="method" line="1065" static="1"><f a="location:x:y:z:w">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform4f>
		<uniform4fv public="1" set="method" line="1070" static="1"><f a="location:v">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="lime.gl.native.LimeFloats"/>
	<x path="Void"/>
</f></uniform4fv>
		<uniform4i public="1" set="method" line="1075" static="1"><f a="location:x:y:z:w">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform4i>
		<uniform4iv public="1" set="method" line="1080" static="1"><f a="location:v">
	<t path="lime.gl.GLUniformLocation"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></uniform4iv>
		<uniformMatrix2fv public="1" set="method" line="1085" static="1"><f a="location:transpose:v">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Bool"/>
	<c path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniformMatrix2fv>
		<uniformMatrix3fv public="1" set="method" line="1090" static="1"><f a="location:transpose:v">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Bool"/>
	<c path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniformMatrix3fv>
		<uniformMatrix4fv public="1" set="method" line="1095" static="1"><f a="location:transpose:v">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Bool"/>
	<c path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniformMatrix4fv>
		<uniformMatrix3D public="1" set="method" line="1100" static="1"><f a="location:transpose:matrix">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Bool"/>
	<c path="lime.utils.Matrix3D"/>
	<x path="Void"/>
</f></uniformMatrix3D>
		<useProgram public="1" set="method" line="1105" static="1"><f a="program">
	<c path="lime.gl.GLProgram"/>
	<x path="Void"/>
</f></useProgram>
		<validateProgram public="1" set="method" line="1110" static="1"><f a="program">
	<c path="lime.gl.GLProgram"/>
	<x path="Void"/>
</f></validateProgram>
		<vertexAttrib1f public="1" set="method" line="1115" static="1"><f a="indx:x">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib1f>
		<vertexAttrib1fv public="1" set="method" line="1120" static="1"><f a="indx:values">
	<x path="Int"/>
	<x path="lime.gl.native.LimeFloats"/>
	<x path="Void"/>
</f></vertexAttrib1fv>
		<vertexAttrib2f public="1" set="method" line="1125" static="1"><f a="indx:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib2f>
		<vertexAttrib2fv public="1" set="method" line="1130" static="1"><f a="indx:values">
	<x path="Int"/>
	<x path="lime.gl.native.LimeFloats"/>
	<x path="Void"/>
</f></vertexAttrib2fv>
		<vertexAttrib3f public="1" set="method" line="1135" static="1"><f a="indx:x:y:z">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib3f>
		<vertexAttrib3fv public="1" set="method" line="1140" static="1"><f a="indx:values">
	<x path="Int"/>
	<x path="lime.gl.native.LimeFloats"/>
	<x path="Void"/>
</f></vertexAttrib3fv>
		<vertexAttrib4f public="1" set="method" line="1145" static="1"><f a="indx:x:y:z:w">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib4f>
		<vertexAttrib4fv public="1" set="method" line="1150" static="1"><f a="indx:values">
	<x path="Int"/>
	<x path="lime.gl.native.LimeFloats"/>
	<x path="Void"/>
</f></vertexAttrib4fv>
		<vertexAttribPointer public="1" set="method" line="1155" static="1"><f a="indx:size:type:normalized:stride:offset">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></vertexAttribPointer>
		<viewport public="1" set="method" line="1160" static="1"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></viewport>
		<get_drawingBufferHeight set="method" line="1173" static="1"><f a=""><x path="Int"/></f></get_drawingBufferHeight>
		<get_drawingBufferWidth set="method" line="1174" static="1"><f a=""><x path="Int"/></f></get_drawingBufferWidth>
		<get_version set="method" line="1175" static="1"><f a=""><x path="Int"/></f></get_version>
		<lime_gl_active_texture line="1185" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></lime_gl_active_texture>
		<lime_gl_attach_shader line="1186" static="1"><f a=":">
	<d/>
	<d/>
	<unknown/>
</f></lime_gl_attach_shader>
		<lime_gl_bind_attrib_location line="1187" static="1"><f a="::">
	<d/>
	<x path="Int"/>
	<c path="String"/>
	<unknown/>
</f></lime_gl_bind_attrib_location>
		<lime_gl_bind_bitmap_data_texture line="1188" static="1"><unknown/></lime_gl_bind_bitmap_data_texture>
		<lime_gl_bind_buffer line="1189" static="1"><f a=":">
	<x path="Int"/>
	<t path="Null"><unknown/></t>
	<unknown/>
</f></lime_gl_bind_buffer>
		<lime_gl_bind_framebuffer line="1190" static="1"><f a=":">
	<x path="Int"/>
	<t path="Null"><unknown/></t>
	<unknown/>
</f></lime_gl_bind_framebuffer>
		<lime_gl_bind_renderbuffer line="1191" static="1"><f a=":">
	<x path="Int"/>
	<t path="Null"><unknown/></t>
	<unknown/>
</f></lime_gl_bind_renderbuffer>
		<lime_gl_bind_texture line="1192" static="1"><f a=":">
	<x path="Int"/>
	<t path="Null"><unknown/></t>
	<unknown/>
</f></lime_gl_bind_texture>
		<lime_gl_blend_color line="1193" static="1"><f a=":::">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gl_blend_color>
		<lime_gl_blend_equation line="1194" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></lime_gl_blend_equation>
		<lime_gl_blend_equation_separate line="1195" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_blend_equation_separate>
		<lime_gl_blend_func line="1196" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_blend_func>
		<lime_gl_blend_func_separate line="1197" static="1"><f a=":::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_blend_func_separate>
		<lime_gl_buffer_data line="1198" static="1"><f a="::::">
	<x path="Int"/>
	<t path="lime.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_buffer_data>
		<lime_gl_buffer_sub_data line="1199" static="1"><f a="::::">
	<x path="Int"/>
	<x path="Int"/>
	<t path="lime.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_buffer_sub_data>
		<lime_gl_check_framebuffer_status line="1200" static="1"><f a="">
	<x path="Int"/>
	<x path="Int"/>
</f></lime_gl_check_framebuffer_status>
		<lime_gl_clear line="1201" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></lime_gl_clear>
		<lime_gl_clear_color line="1202" static="1"><f a=":::">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gl_clear_color>
		<lime_gl_clear_depth line="1203" static="1"><f a="">
	<x path="Float"/>
	<unknown/>
</f></lime_gl_clear_depth>
		<lime_gl_clear_stencil line="1204" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></lime_gl_clear_stencil>
		<lime_gl_color_mask line="1205" static="1"><f a=":::">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<unknown/>
</f></lime_gl_color_mask>
		<lime_gl_compile_shader line="1206" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_gl_compile_shader>
		<lime_gl_compressed_tex_image_2d line="1207" static="1"><f a=":::::::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<t path="Null"><c path="lime.utils.native.ByteArray"/></t>
	<t path="Null"><x path="Int"/></t>
	<unknown/>
</f></lime_gl_compressed_tex_image_2d>
		<lime_gl_compressed_tex_sub_image_2d line="1208" static="1"><f a="::::::::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<t path="Null"><c path="lime.utils.native.ByteArray"/></t>
	<t path="Null"><x path="Int"/></t>
	<unknown/>
</f></lime_gl_compressed_tex_sub_image_2d>
		<lime_gl_copy_tex_image_2d line="1209" static="1"><f a=":::::::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_copy_tex_image_2d>
		<lime_gl_copy_tex_sub_image_2d line="1210" static="1"><f a=":::::::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_copy_tex_sub_image_2d>
		<lime_gl_create_buffer line="1211" static="1"><f a=""><unknown/></f></lime_gl_create_buffer>
		<lime_gl_create_framebuffer line="1212" static="1"><f a=""><unknown/></f></lime_gl_create_framebuffer>
		<lime_gl_create_program line="1213" static="1"><f a=""><unknown/></f></lime_gl_create_program>
		<lime_gl_create_render_buffer line="1214" static="1"><f a=""><unknown/></f></lime_gl_create_render_buffer>
		<lime_gl_create_shader line="1215" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></lime_gl_create_shader>
		<lime_gl_create_texture line="1216" static="1"><f a=""><unknown/></f></lime_gl_create_texture>
		<lime_gl_cull_face line="1217" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></lime_gl_cull_face>
		<lime_gl_delete_buffer line="1218" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_gl_delete_buffer>
		<lime_gl_delete_framebuffer line="1219" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_gl_delete_framebuffer>
		<lime_gl_delete_program line="1220" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_gl_delete_program>
		<lime_gl_delete_render_buffer line="1221" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_gl_delete_render_buffer>
		<lime_gl_delete_shader line="1222" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_gl_delete_shader>
		<lime_gl_delete_texture line="1223" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_gl_delete_texture>
		<lime_gl_depth_func line="1224" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></lime_gl_depth_func>
		<lime_gl_depth_mask line="1225" static="1"><f a="">
	<x path="Bool"/>
	<unknown/>
</f></lime_gl_depth_mask>
		<lime_gl_depth_range line="1226" static="1"><f a=":">
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gl_depth_range>
		<lime_gl_detach_shader line="1227" static="1"><f a=":">
	<d/>
	<d/>
	<unknown/>
</f></lime_gl_detach_shader>
		<lime_gl_disable line="1228" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></lime_gl_disable>
		<lime_gl_disable_vertex_attrib_array line="1229" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></lime_gl_disable_vertex_attrib_array>
		<lime_gl_draw_arrays line="1230" static="1"><f a="::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_draw_arrays>
		<lime_gl_draw_elements line="1231" static="1"><f a=":::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_draw_elements>
		<lime_gl_enable line="1232" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></lime_gl_enable>
		<lime_gl_enable_vertex_attrib_array line="1233" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></lime_gl_enable_vertex_attrib_array>
		<lime_gl_finish line="1234" static="1"><f a=""><unknown/></f></lime_gl_finish>
		<lime_gl_flush line="1235" static="1"><f a=""><unknown/></f></lime_gl_flush>
		<lime_gl_framebuffer_renderbuffer line="1236" static="1"><f a=":::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<d/>
	<unknown/>
</f></lime_gl_framebuffer_renderbuffer>
		<lime_gl_framebuffer_texture2D line="1237" static="1"><f a="::::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<d/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_framebuffer_texture2D>
		<lime_gl_front_face line="1238" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></lime_gl_front_face>
		<lime_gl_generate_mipmap line="1239" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></lime_gl_generate_mipmap>
		<lime_gl_get_active_attrib line="1240" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<t path="lime.gl.GLActiveInfo"/>
</f></lime_gl_get_active_attrib>
		<lime_gl_get_active_uniform line="1241" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<t path="lime.gl.GLActiveInfo"/>
</f></lime_gl_get_active_uniform>
		<lime_gl_get_attrib_location line="1242" static="1"><f a=":">
	<d/>
	<c path="String"/>
	<x path="Int"/>
</f></lime_gl_get_attrib_location>
		<lime_gl_get_buffer_paramerter line="1243" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_get_buffer_paramerter>
		<lime_gl_get_context_attributes line="1244" static="1"><f a=""><a>
	<stencil><x path="Bool"/></stencil>
	<preserveDrawingBuffer><x path="Bool"/></preserveDrawingBuffer>
	<premultipliedAlpha><x path="Bool"/></premultipliedAlpha>
	<depth><x path="Bool"/></depth>
	<antialias><x path="Bool"/></antialias>
	<alpha><x path="Bool"/></alpha>
</a></f></lime_gl_get_context_attributes>
		<lime_gl_get_error line="1245" static="1"><f a=""><x path="Int"/></f></lime_gl_get_error>
		<lime_gl_get_framebuffer_attachment_parameter line="1246" static="1"><f a="::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_get_framebuffer_attachment_parameter>
		<lime_gl_get_parameter line="1247" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></lime_gl_get_parameter>
		<lime_gl_get_program_info_log line="1249" static="1"><f a="">
	<d/>
	<c path="String"/>
</f></lime_gl_get_program_info_log>
		<lime_gl_get_program_parameter line="1250" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
</f></lime_gl_get_program_parameter>
		<lime_gl_get_render_buffer_parameter line="1251" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_get_render_buffer_parameter>
		<lime_gl_get_shader_info_log line="1252" static="1"><f a="">
	<d/>
	<c path="String"/>
</f></lime_gl_get_shader_info_log>
		<lime_gl_get_shader_parameter line="1253" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
</f></lime_gl_get_shader_parameter>
		<lime_gl_get_shader_precision_format line="1254" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<t path="lime.gl.native.ShaderPrecisionFormat"/>
</f></lime_gl_get_shader_precision_format>
		<lime_gl_get_shader_source line="1255" static="1"><f a="">
	<d/>
	<c path="String"/>
</f></lime_gl_get_shader_source>
		<lime_gl_get_supported_extensions line="1256" static="1"><f a="">
	<c path="Array"><c path="String"/></c>
	<unknown/>
</f></lime_gl_get_supported_extensions>
		<lime_gl_get_tex_parameter line="1257" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_get_tex_parameter>
		<lime_gl_get_uniform line="1258" static="1"><f a=":">
	<d/>
	<t path="lime.gl.GLUniformLocation"/>
	<unknown/>
</f></lime_gl_get_uniform>
		<lime_gl_get_uniform_location line="1259" static="1"><f a=":">
	<d/>
	<c path="String"/>
	<unknown/>
</f></lime_gl_get_uniform_location>
		<lime_gl_get_vertex_attrib line="1260" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_get_vertex_attrib>
		<lime_gl_get_vertex_attrib_offset line="1261" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lime_gl_get_vertex_attrib_offset>
		<lime_gl_hint line="1262" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_hint>
		<lime_gl_is_buffer line="1263" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_gl_is_buffer>
		<lime_gl_is_enabled line="1264" static="1"><f a="">
	<x path="Int"/>
	<x path="Bool"/>
</f></lime_gl_is_enabled>
		<lime_gl_is_framebuffer line="1265" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_gl_is_framebuffer>
		<lime_gl_is_program line="1266" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_gl_is_program>
		<lime_gl_is_renderbuffer line="1267" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_gl_is_renderbuffer>
		<lime_gl_is_shader line="1268" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_gl_is_shader>
		<lime_gl_is_texture line="1269" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_gl_is_texture>
		<lime_gl_line_width line="1270" static="1"><f a="">
	<x path="Float"/>
	<unknown/>
</f></lime_gl_line_width>
		<lime_gl_link_program line="1271" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_gl_link_program>
		<lime_gl_pixel_storei line="1272" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_pixel_storei>
		<lime_gl_polygon_offset line="1273" static="1"><f a=":">
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gl_polygon_offset>
		<lime_gl_renderbuffer_storage line="1274" static="1"><f a=":::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_renderbuffer_storage>
		<lime_gl_sample_coverage line="1275" static="1"><f a=":">
	<x path="Float"/>
	<x path="Bool"/>
	<unknown/>
</f></lime_gl_sample_coverage>
		<lime_gl_scissor line="1276" static="1"><f a=":::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_scissor>
		<lime_gl_shader_source line="1277" static="1"><f a=":">
	<d/>
	<c path="String"/>
	<unknown/>
</f></lime_gl_shader_source>
		<lime_gl_stencil_func line="1278" static="1"><f a="::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_stencil_func>
		<lime_gl_stencil_func_separate line="1279" static="1"><f a=":::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_stencil_func_separate>
		<lime_gl_stencil_mask line="1280" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></lime_gl_stencil_mask>
		<lime_gl_stencil_mask_separate line="1281" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_stencil_mask_separate>
		<lime_gl_stencil_op line="1282" static="1"><f a="::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_stencil_op>
		<lime_gl_stencil_op_separate line="1283" static="1"><f a=":::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_stencil_op_separate>
		<lime_gl_tex_image_2d line="1284" static="1"><f a=":::::::::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<t path="Null"><c path="lime.utils.native.ByteArray"/></t>
	<t path="Null"><x path="Int"/></t>
	<unknown/>
</f></lime_gl_tex_image_2d>
		<lime_gl_tex_parameterf line="1285" static="1"><f a="::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gl_tex_parameterf>
		<lime_gl_tex_parameteri line="1286" static="1"><f a="::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_tex_parameteri>
		<lime_gl_tex_sub_image_2d line="1287" static="1"><f a=":::::::::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<t path="Null"><c path="lime.utils.native.ByteArray"/></t>
	<t path="Null"><x path="Int"/></t>
	<unknown/>
</f></lime_gl_tex_sub_image_2d>
		<lime_gl_uniform1f line="1288" static="1"><f a=":">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gl_uniform1f>
		<lime_gl_uniform1fv line="1289" static="1"><f a=":">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="lime.gl.native.LimeFloats"/>
	<unknown/>
</f></lime_gl_uniform1fv>
		<lime_gl_uniform1i line="1290" static="1"><f a=":">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_uniform1i>
		<lime_gl_uniform1iv line="1291" static="1"><f a=":">
	<t path="lime.gl.GLUniformLocation"/>
	<c path="Array"><x path="Int"/></c>
	<unknown/>
</f></lime_gl_uniform1iv>
		<lime_gl_uniform2f line="1292" static="1"><f a="::">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gl_uniform2f>
		<lime_gl_uniform2fv line="1293" static="1"><f a=":">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="lime.gl.native.LimeFloats"/>
	<unknown/>
</f></lime_gl_uniform2fv>
		<lime_gl_uniform2i line="1294" static="1"><f a="::">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_uniform2i>
		<lime_gl_uniform2iv line="1295" static="1"><f a=":">
	<t path="lime.gl.GLUniformLocation"/>
	<c path="Array"><x path="Int"/></c>
	<unknown/>
</f></lime_gl_uniform2iv>
		<lime_gl_uniform3f line="1296" static="1"><f a=":::">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gl_uniform3f>
		<lime_gl_uniform3fv line="1297" static="1"><f a=":">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="lime.gl.native.LimeFloats"/>
	<unknown/>
</f></lime_gl_uniform3fv>
		<lime_gl_uniform3i line="1298" static="1"><f a=":::">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_uniform3i>
		<lime_gl_uniform3iv line="1299" static="1"><f a=":">
	<t path="lime.gl.GLUniformLocation"/>
	<c path="Array"><x path="Int"/></c>
	<unknown/>
</f></lime_gl_uniform3iv>
		<lime_gl_uniform4f line="1300" static="1"><f a="::::">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gl_uniform4f>
		<lime_gl_uniform4fv line="1301" static="1"><f a=":">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="lime.gl.native.LimeFloats"/>
	<unknown/>
</f></lime_gl_uniform4fv>
		<lime_gl_uniform4i line="1302" static="1"><f a="::::">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_uniform4i>
		<lime_gl_uniform4iv line="1303" static="1"><f a=":">
	<t path="lime.gl.GLUniformLocation"/>
	<c path="Array"><x path="Int"/></c>
	<unknown/>
</f></lime_gl_uniform4iv>
		<lime_gl_uniform_matrix line="1304" static="1"><f a=":::">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Bool"/>
	<t path="lime.utils.ByteArray"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_uniform_matrix>
		<lime_gl_use_program line="1305" static="1"><f a="">
	<t path="Null"><unknown/></t>
	<unknown/>
</f></lime_gl_use_program>
		<lime_gl_validate_program line="1306" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_gl_validate_program>
		<lime_gl_version line="1307" static="1"><f a=""><x path="Int"/></f></lime_gl_version>
		<lime_gl_vertex_attrib1f line="1308" static="1"><f a=":">
	<x path="Int"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gl_vertex_attrib1f>
		<lime_gl_vertex_attrib1fv line="1309" static="1"><f a=":">
	<x path="Int"/>
	<x path="lime.gl.native.LimeFloats"/>
	<unknown/>
</f></lime_gl_vertex_attrib1fv>
		<lime_gl_vertex_attrib2f line="1310" static="1"><f a="::">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gl_vertex_attrib2f>
		<lime_gl_vertex_attrib2fv line="1311" static="1"><f a=":">
	<x path="Int"/>
	<x path="lime.gl.native.LimeFloats"/>
	<unknown/>
</f></lime_gl_vertex_attrib2fv>
		<lime_gl_vertex_attrib3f line="1312" static="1"><f a=":::">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gl_vertex_attrib3f>
		<lime_gl_vertex_attrib3fv line="1313" static="1"><f a=":">
	<x path="Int"/>
	<x path="lime.gl.native.LimeFloats"/>
	<unknown/>
</f></lime_gl_vertex_attrib3fv>
		<lime_gl_vertex_attrib4f line="1314" static="1"><f a="::::">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></lime_gl_vertex_attrib4f>
		<lime_gl_vertex_attrib4fv line="1315" static="1"><f a=":">
	<x path="Int"/>
	<x path="lime.gl.native.LimeFloats"/>
	<unknown/>
</f></lime_gl_vertex_attrib4fv>
		<lime_gl_vertex_attrib_pointer line="1316" static="1"><f a=":::::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_vertex_attrib_pointer>
		<lime_gl_viewport line="1317" static="1"><f a=":::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_gl_viewport>
	</class>
	<typedef path="lime.gl.native.ShaderPrecisionFormat" params="" file="/Users/sven/dev/lime/lime/gl/native/GL.hx" module="lime.gl.native.GL"><a>
	<rangeMin><x path="Int"/></rangeMin>
	<rangeMax><x path="Int"/></rangeMax>
	<precision><x path="Int"/></precision>
</a></typedef>
	<typedef path="lime.helpers.AudioHelper" params="" file="/Users/sven/dev/lime/lime/helpers/AudioHelper.hx"><c path="lime.helpers.native.AudioHelper"/></typedef>
	<class path="lime.helpers.Sound" params="" file="/Users/sven/dev/lime/lime/helpers/AudioHelper.hx" module="lime.helpers.AudioHelper">
		<lime_sound_channel_is_complete line="266" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_sound_channel_is_complete>
		<lime_sound_channel_create line="267" static="1"><f a=":::">
	<d/>
	<t path="Null"><x path="Float"/></t>
	<x path="Int"/>
	<c path="lime.helpers.SoundTransform"/>
	<unknown/>
</f></lime_sound_channel_create>
		<lime_sound_channel_stop line="268" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_sound_channel_stop>
		<lime_sound_channel_set_transform line="269" static="1"><f a=":">
	<d/>
	<c path="lime.helpers.SoundTransform"/>
	<unknown/>
</f></lime_sound_channel_set_transform>
		<lime_sound_channel_get_position line="270" static="1"><f a="">
	<d/>
	<x path="Float"/>
</f></lime_sound_channel_get_position>
		<lime_sound_channel_set_position line="271" static="1"><f a=":">
	<d/>
	<x path="Float"/>
	<unknown/>
</f></lime_sound_channel_set_position>
		<name public="1"><c path="String"/></name>
		<handle public="1"><d/></handle>
		<channel public="1"><d/></channel>
		<looping public="1"><x path="Bool"/></looping>
		<playing public="1"><x path="Bool"/></playing>
		<ismusic public="1"><x path="Bool"/></ismusic>
		<on_complete_handler><f a="">
	<c path="lime.helpers.Sound"/>
	<x path="Void"/>
</f></on_complete_handler>
		<volume public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</volume>
		<pan public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</pan>
		<position public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</position>
		<plays_total><x path="Int"/></plays_total>
		<plays_remain><x path="Int"/></plays_remain>
		<added_to_thread>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</added_to_thread>
		<transform><c path="lime.helpers.SoundTransform"/></transform>
		<play public="1" set="method" line="49"><f a="?_number_of_times:?_start" v="1:0.0f">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></play>
		<stop public="1" set="method" line="91"><f a=""><x path="Void"/></f></stop>
		<do_on_complete public="1" set="method" line="121">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</do_on_complete>
		<on_complete public="1" set="method" line="153"><f a="_function">
	<f a="">
		<c path="lime.helpers.Sound"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></on_complete>
		<do_check_complete public="1" set="method" line="157">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</do_check_complete>
		<check_complete public="1" set="method" line="171">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</check_complete>
		<set_volume set="method" line="208"><f a="_v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_volume>
		<set_pan set="method" line="223"><f a="_p">
	<x path="Float"/>
	<x path="Float"/>
</f></set_pan>
		<set_position set="method" line="238"><f a="_p">
	<x path="Float"/>
	<x path="Float"/>
</f></set_position>
		<get_position set="method" line="251"><f a=""><x path="Float"/></f></get_position>
		<new public="1" set="method" line="37"><f a="_name:_handle:?_music:?_sound" v="::false:null">
	<c path="String"/>
	<d/>
	<x path="Bool"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.helpers.SoundTransform" params="" file="/Users/sven/dev/lime/lime/helpers/AudioHelper.hx" module="lime.helpers.AudioHelper">
		<pan public="1"><x path="Float"/></pan>
		<volume public="1"><x path="Float"/></volume>
		<clone public="1" set="method" line="287"><f a=""><c path="lime.helpers.SoundTransform"/></f></clone>
		<new public="1" set="method" line="282"><f a="?vol:?panning" v="1.0f:0.0f">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.helpers.Gamepad" params="" file="/Users/sven/dev/lime/lime/helpers/Gamepad.hx">
		<max_buttons public="1"><x path="Int"/></max_buttons>
		<max_axis public="1"><x path="Int"/></max_axis>
		<max_hats public="1"><x path="Int"/></max_hats>
		<button0 public="1"><x path="Int"/></button0>
		<button1 public="1"><x path="Int"/></button1>
		<button2 public="1"><x path="Int"/></button2>
		<button3 public="1"><x path="Int"/></button3>
		<button4 public="1"><x path="Int"/></button4>
		<button5 public="1"><x path="Int"/></button5>
		<button6 public="1"><x path="Int"/></button6>
		<button7 public="1"><x path="Int"/></button7>
		<button8 public="1"><x path="Int"/></button8>
		<button9 public="1"><x path="Int"/></button9>
		<button10 public="1"><x path="Int"/></button10>
		<button11 public="1"><x path="Int"/></button11>
		<button12 public="1"><x path="Int"/></button12>
		<button13 public="1"><x path="Int"/></button13>
		<button14 public="1"><x path="Int"/></button14>
		<button15 public="1"><x path="Int"/></button15>
		<axis0 public="1"><x path="Int"/></axis0>
		<axis1 public="1"><x path="Int"/></axis1>
		<axis2 public="1"><x path="Int"/></axis2>
		<axis3 public="1"><x path="Int"/></axis3>
		<axis4 public="1"><x path="Int"/></axis4>
		<axis5 public="1"><x path="Int"/></axis5>
		<axis6 public="1"><x path="Int"/></axis6>
		<axis7 public="1"><x path="Int"/></axis7>
		<hat0 public="1"><x path="Int"/></hat0>
		<hat1 public="1"><x path="Int"/></hat1>
		<hat2 public="1"><x path="Int"/></hat2>
		<hat3 public="1"><x path="Int"/></hat3>
		<hat4 public="1"><x path="Int"/></hat4>
		<hat5 public="1"><x path="Int"/></hat5>
		<hat6 public="1"><x path="Int"/></hat6>
		<hat7 public="1"><x path="Int"/></hat7>
		<set_profile public="1" set="method" line="45"><f a="buttons:axis:hats">
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></set_profile>
		<apply_360_profile public="1" set="method" line="61"><f a=""><x path="Void"/></f></apply_360_profile>
		<new public="1" set="method" line="44"><f a=""><x path="Void"/></f></new>
	</class>
	<typedef path="lime.helpers.InputHelper" params="" file="/Users/sven/dev/lime/lime/helpers/InputHelper.hx"><c path="lime.helpers.native.InputHelper"/></typedef>
	<enum path="lime.helpers.KeyValue" params="" file="/Users/sven/dev/lime/lime/helpers/Keys.hx" module="lime.helpers.Keys">
		<unknown/>
		<backspace/>
		<tab/>
		<enter/>
		<meta/>
		<shift/>
		<ctrl/>
		<alt/>
		<capslock/>
		<escape/>
		<space/>
		<left/>
		<up/>
		<right/>
		<down/>
		<key_0/>
		<key_1/>
		<key_2/>
		<key_3/>
		<key_4/>
		<key_5/>
		<key_6/>
		<key_7/>
		<key_8/>
		<key_9/>
		<key_A/>
		<key_B/>
		<key_C/>
		<key_D/>
		<key_E/>
		<key_F/>
		<key_G/>
		<key_H/>
		<key_I/>
		<key_J/>
		<key_K/>
		<key_L/>
		<key_M/>
		<key_N/>
		<key_O/>
		<key_P/>
		<key_Q/>
		<key_R/>
		<key_S/>
		<key_T/>
		<key_U/>
		<key_V/>
		<key_W/>
		<key_X/>
		<key_Y/>
		<key_Z/>
		<equals/>
		<minus/>
		<tilde/>
		<forward_slash/>
		<back_slash/>
		<semicolon/>
		<single_quote/>
		<comma/>
		<period/>
		<open_square_brace/>
		<close_square_brace/>
		<f1/>
		<f2/>
		<f3/>
		<f4/>
		<f5/>
		<f6/>
		<f7/>
		<f8/>
		<f9/>
		<f10/>
		<f11/>
		<f12/>
		<f13/>
		<f14/>
		<f15/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="lime.helpers.Keys" params="" file="/Users/sven/dev/lime/lime/helpers/Keys.hx">
		<_backspace get="inline" set="null" line="90" static="1"><x path="Int"/></_backspace>
		<_tab get="inline" set="null" line="91" static="1"><x path="Int"/></_tab>
		<_enter get="inline" set="null" line="92" static="1"><x path="Int"/></_enter>
		<_meta get="inline" set="null" line="93" static="1"><x path="Int"/></_meta>
		<_shift get="inline" set="null" line="94" static="1"><x path="Int"/></_shift>
		<_ctrl get="inline" set="null" line="95" static="1"><x path="Int"/></_ctrl>
		<_alt get="inline" set="null" line="96" static="1"><x path="Int"/></_alt>
		<_capslock get="inline" set="null" line="97" static="1"><x path="Int"/></_capslock>
		<_escape get="inline" set="null" line="98" static="1"><x path="Int"/></_escape>
		<_space get="inline" set="null" line="99" static="1"><x path="Int"/></_space>
		<_left get="inline" set="null" line="101" static="1"><x path="Int"/></_left>
		<_up get="inline" set="null" line="102" static="1"><x path="Int"/></_up>
		<_right get="inline" set="null" line="103" static="1"><x path="Int"/></_right>
		<_down get="inline" set="null" line="104" static="1"><x path="Int"/></_down>
		<_key_0 get="inline" set="null" line="106" static="1"><x path="Int"/></_key_0>
		<_key_1 get="inline" set="null" line="107" static="1"><x path="Int"/></_key_1>
		<_key_2 get="inline" set="null" line="108" static="1"><x path="Int"/></_key_2>
		<_key_3 get="inline" set="null" line="109" static="1"><x path="Int"/></_key_3>
		<_key_4 get="inline" set="null" line="110" static="1"><x path="Int"/></_key_4>
		<_key_5 get="inline" set="null" line="111" static="1"><x path="Int"/></_key_5>
		<_key_6 get="inline" set="null" line="112" static="1"><x path="Int"/></_key_6>
		<_key_7 get="inline" set="null" line="113" static="1"><x path="Int"/></_key_7>
		<_key_8 get="inline" set="null" line="114" static="1"><x path="Int"/></_key_8>
		<_key_9 get="inline" set="null" line="115" static="1"><x path="Int"/></_key_9>
		<_key_A get="inline" set="null" line="117" static="1"><x path="Int"/></_key_A>
		<_key_B get="inline" set="null" line="118" static="1"><x path="Int"/></_key_B>
		<_key_C get="inline" set="null" line="119" static="1"><x path="Int"/></_key_C>
		<_key_D get="inline" set="null" line="120" static="1"><x path="Int"/></_key_D>
		<_key_E get="inline" set="null" line="121" static="1"><x path="Int"/></_key_E>
		<_key_F get="inline" set="null" line="122" static="1"><x path="Int"/></_key_F>
		<_key_G get="inline" set="null" line="123" static="1"><x path="Int"/></_key_G>
		<_key_H get="inline" set="null" line="124" static="1"><x path="Int"/></_key_H>
		<_key_I get="inline" set="null" line="125" static="1"><x path="Int"/></_key_I>
		<_key_J get="inline" set="null" line="126" static="1"><x path="Int"/></_key_J>
		<_key_K get="inline" set="null" line="127" static="1"><x path="Int"/></_key_K>
		<_key_L get="inline" set="null" line="128" static="1"><x path="Int"/></_key_L>
		<_key_M get="inline" set="null" line="129" static="1"><x path="Int"/></_key_M>
		<_key_N get="inline" set="null" line="130" static="1"><x path="Int"/></_key_N>
		<_key_O get="inline" set="null" line="131" static="1"><x path="Int"/></_key_O>
		<_key_P get="inline" set="null" line="132" static="1"><x path="Int"/></_key_P>
		<_key_Q get="inline" set="null" line="133" static="1"><x path="Int"/></_key_Q>
		<_key_R get="inline" set="null" line="134" static="1"><x path="Int"/></_key_R>
		<_key_S get="inline" set="null" line="135" static="1"><x path="Int"/></_key_S>
		<_key_T get="inline" set="null" line="136" static="1"><x path="Int"/></_key_T>
		<_key_U get="inline" set="null" line="137" static="1"><x path="Int"/></_key_U>
		<_key_V get="inline" set="null" line="138" static="1"><x path="Int"/></_key_V>
		<_key_W get="inline" set="null" line="139" static="1"><x path="Int"/></_key_W>
		<_key_X get="inline" set="null" line="140" static="1"><x path="Int"/></_key_X>
		<_key_Y get="inline" set="null" line="141" static="1"><x path="Int"/></_key_Y>
		<_key_Z get="inline" set="null" line="142" static="1"><x path="Int"/></_key_Z>
		<_equals get="inline" set="null" line="144" static="1"><x path="Int"/></_equals>
		<_minus get="inline" set="null" line="145" static="1"><x path="Int"/></_minus>
		<_tilde get="inline" set="null" line="146" static="1"><x path="Int"/></_tilde>
		<_forward_slash get="inline" set="null" line="147" static="1"><x path="Int"/></_forward_slash>
		<_back_slash get="inline" set="null" line="148" static="1"><x path="Int"/></_back_slash>
		<_semicolon get="inline" set="null" line="149" static="1"><x path="Int"/></_semicolon>
		<_single_quote get="inline" set="null" line="150" static="1"><x path="Int"/></_single_quote>
		<_comma get="inline" set="null" line="151" static="1"><x path="Int"/></_comma>
		<_period get="inline" set="null" line="152" static="1"><x path="Int"/></_period>
		<_open_square_brace get="inline" set="null" line="153" static="1"><x path="Int"/></_open_square_brace>
		<_close_square_brace get="inline" set="null" line="154" static="1"><x path="Int"/></_close_square_brace>
		<_f1 get="inline" set="null" line="156" static="1"><x path="Int"/></_f1>
		<_f2 get="inline" set="null" line="157" static="1"><x path="Int"/></_f2>
		<_f3 get="inline" set="null" line="158" static="1"><x path="Int"/></_f3>
		<_f4 get="inline" set="null" line="159" static="1"><x path="Int"/></_f4>
		<_f5 get="inline" set="null" line="160" static="1"><x path="Int"/></_f5>
		<_f6 get="inline" set="null" line="161" static="1"><x path="Int"/></_f6>
		<_f7 get="inline" set="null" line="162" static="1"><x path="Int"/></_f7>
		<_f8 get="inline" set="null" line="163" static="1"><x path="Int"/></_f8>
		<_f9 get="inline" set="null" line="164" static="1"><x path="Int"/></_f9>
		<_f10 get="inline" set="null" line="165" static="1"><x path="Int"/></_f10>
		<_f11 get="inline" set="null" line="166" static="1"><x path="Int"/></_f11>
		<_f12 get="inline" set="null" line="167" static="1"><x path="Int"/></_f12>
		<_f13 get="inline" set="null" line="168" static="1"><x path="Int"/></_f13>
		<_f14 get="inline" set="null" line="169" static="1"><x path="Int"/></_f14>
		<_f15 get="inline" set="null" line="170" static="1"><x path="Int"/></_f15>
		<toKeyValue public="1" set="method" line="254" static="1"><f a="_event">
	<d/>
	<e path="lime.helpers.KeyValue"/>
</f></toKeyValue>
		<tab public="1"><x path="Int"/></tab>
		<enter public="1"><x path="Int"/></enter>
		<meta public="1"><x path="Int"/></meta>
		<shift public="1"><x path="Int"/></shift>
		<ctrl public="1"><x path="Int"/></ctrl>
		<alt public="1"><x path="Int"/></alt>
		<capslock public="1"><x path="Int"/></capslock>
		<escape public="1"><x path="Int"/></escape>
		<space public="1"><x path="Int"/></space>
		<left public="1"><x path="Int"/></left>
		<up public="1"><x path="Int"/></up>
		<right public="1"><x path="Int"/></right>
		<down public="1"><x path="Int"/></down>
		<key_0 public="1"><x path="Int"/></key_0>
		<key_1 public="1"><x path="Int"/></key_1>
		<key_2 public="1"><x path="Int"/></key_2>
		<key_3 public="1"><x path="Int"/></key_3>
		<key_4 public="1"><x path="Int"/></key_4>
		<key_5 public="1"><x path="Int"/></key_5>
		<key_6 public="1"><x path="Int"/></key_6>
		<key_7 public="1"><x path="Int"/></key_7>
		<key_8 public="1"><x path="Int"/></key_8>
		<key_9 public="1"><x path="Int"/></key_9>
		<key_A public="1"><x path="Int"/></key_A>
		<key_B public="1"><x path="Int"/></key_B>
		<key_C public="1"><x path="Int"/></key_C>
		<key_D public="1"><x path="Int"/></key_D>
		<key_E public="1"><x path="Int"/></key_E>
		<key_F public="1"><x path="Int"/></key_F>
		<key_G public="1"><x path="Int"/></key_G>
		<key_H public="1"><x path="Int"/></key_H>
		<key_I public="1"><x path="Int"/></key_I>
		<key_J public="1"><x path="Int"/></key_J>
		<key_K public="1"><x path="Int"/></key_K>
		<key_L public="1"><x path="Int"/></key_L>
		<key_M public="1"><x path="Int"/></key_M>
		<key_N public="1"><x path="Int"/></key_N>
		<key_O public="1"><x path="Int"/></key_O>
		<key_P public="1"><x path="Int"/></key_P>
		<key_Q public="1"><x path="Int"/></key_Q>
		<key_R public="1"><x path="Int"/></key_R>
		<key_S public="1"><x path="Int"/></key_S>
		<key_T public="1"><x path="Int"/></key_T>
		<key_U public="1"><x path="Int"/></key_U>
		<key_V public="1"><x path="Int"/></key_V>
		<key_W public="1"><x path="Int"/></key_W>
		<key_X public="1"><x path="Int"/></key_X>
		<key_Y public="1"><x path="Int"/></key_Y>
		<key_Z public="1"><x path="Int"/></key_Z>
		<equals public="1"><x path="Int"/></equals>
		<minus public="1"><x path="Int"/></minus>
		<tilde public="1"><x path="Int"/></tilde>
		<forward_slash public="1"><x path="Int"/></forward_slash>
		<back_slash public="1"><x path="Int"/></back_slash>
		<semicolon public="1"><x path="Int"/></semicolon>
		<single_quote public="1"><x path="Int"/></single_quote>
		<comma public="1"><x path="Int"/></comma>
		<period public="1"><x path="Int"/></period>
		<open_square_brace public="1"><x path="Int"/></open_square_brace>
		<close_square_brace public="1"><x path="Int"/></close_square_brace>
		<f1 public="1"><x path="Int"/></f1>
		<f2 public="1"><x path="Int"/></f2>
		<f3 public="1"><x path="Int"/></f3>
		<f4 public="1"><x path="Int"/></f4>
		<f5 public="1"><x path="Int"/></f5>
		<f6 public="1"><x path="Int"/></f6>
		<f7 public="1"><x path="Int"/></f7>
		<f8 public="1"><x path="Int"/></f8>
		<f9 public="1"><x path="Int"/></f9>
		<f10 public="1"><x path="Int"/></f10>
		<f11 public="1"><x path="Int"/></f11>
		<f12 public="1"><x path="Int"/></f12>
		<f13 public="1"><x path="Int"/></f13>
		<f14 public="1"><x path="Int"/></f14>
		<f15 public="1"><x path="Int"/></f15>
		<new public="1" set="method" line="253"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="lime.helpers.native.AudioHelper" params="" file="/Users/sven/dev/lime/lime/helpers/native/AudioHelper.hx">
		<audio_state public="1" static="1">
			<c path="lime.helpers.native.AudioThreadState"/>
			<meta><m n=":noCompletion"/></meta>
		</audio_state>
		<audio_message_check_complete public="1" line="25" static="1">
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</audio_message_check_complete>
		<audio_thread_is_idle public="1" line="26" static="1">
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</audio_thread_is_idle>
		<audio_thread_running public="1" line="27" static="1">
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</audio_thread_running>
		<lime_sound_from_file line="113" static="1"><f a=":">
	<t path="Null"><c path="String"/></t>
	<t path="Null"><x path="Bool"/></t>
	<unknown/>
</f></lime_sound_from_file>
		<lime_sound_from_data line="114" static="1"><unknown/></lime_sound_from_data>
		<lib><c path="lime.Lime"/></lib>
		<startup public="1" set="method" line="37">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</startup>
		<update public="1" set="method" line="51">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</update>
		<shutdown public="1" set="method" line="57">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</shutdown>
		<create public="1" set="method" line="67"><f a="_name:_file:?_music" v="::false">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="lime.helpers.Sound"/>
</f></create>
		<audio_thread_handler public="1" set="method" line="77"><f a=""><x path="Void"/></f></audio_thread_handler>
		<new public="1" set="method" line="31"><f a="_lib">
	<c path="lime.Lime"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.helpers.native.AudioThreadState" params="" file="/Users/sven/dev/lime/lime/helpers/native/AudioHelper.hx" module="lime.helpers.native.AudioHelper">
		<audio_thread public="1"><c path="cpp.vm.Thread"/></audio_thread>
		<sound_list public="1"><x path="Map">
	<c path="lime.helpers.Sound"/>
	<x path="Bool"/>
</x></sound_list>
		<main_thread public="1"><c path="cpp.vm.Thread"/></main_thread>
		<mutex public="1"><c path="cpp.vm.Mutex"/></mutex>
		<add public="1" set="method" line="134"><f a="sound">
	<c path="lime.helpers.Sound"/>
	<x path="Void"/>
</f></add>
		<check public="1" set="method" line="147"><f a=""><x path="Void"/></f></check>
		<remove public="1" set="method" line="164"><f a="sound">
	<c path="lime.helpers.Sound"/>
	<x path="Void"/>
</f></remove>
		<update public="1" set="method" line="179"><f a=""><x path="Void"/></f></update>
		<new public="1" set="method" line="129"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="lime.helpers.native.InputHelper" params="" file="/Users/sven/dev/lime/lime/helpers/native/InputHelper.hx">
		<lib><c path="lime.Lime"/></lib>
		<startup public="1" set="method" line="15">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</startup>
		<update public="1" set="method" line="19">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</update>
		<new public="1" set="method" line="9"><f a="_lib">
	<c path="lime.Lime"/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="lime.utils.ArrayBuffer" params="" file="/Users/sven/dev/lime/lime/utils/ArrayBuffer.hx"><t path="lime.utils.ByteArray"/></typedef>
	<class path="lime.utils.IMemoryRange" params="" file="/Users/sven/dev/lime/lime/utils/IMemoryRange.hx" interface="1">
		<getByteBuffer public="1" set="method"><f a=""><t path="lime.utils.ByteArray"/></f></getByteBuffer>
		<getStart public="1" set="method"><f a=""><x path="Int"/></f></getStart>
		<getLength public="1" set="method"><f a=""><x path="Int"/></f></getLength>
	</class>
	<class path="lime.utils.ArrayBufferView" params="" file="/Users/sven/dev/lime/lime/utils/ArrayBufferView.hx">
		<implements path="lime.utils.IMemoryRange"/>
		<invalidDataIndex line="22" static="1"><c path="String"/></invalidDataIndex>
		<buffer public="1" set="null"><t path="lime.utils.ByteArray"/></buffer>
		<byteOffset public="1" set="null"><x path="Int"/></byteOffset>
		<byteLength public="1" set="null"><x path="Int"/></byteLength>
		<bytes><t path="haxe.io.BytesData"/></bytes>
		<getByteBuffer public="1" set="method" line="80"><f a=""><t path="lime.utils.ByteArray"/></f></getByteBuffer>
		<getFloat32 public="1" get="inline" set="null" line="87"><f a="position">
	<x path="Int"/>
	<x path="Float"/>
</f></getFloat32>
		<getInt16 public="1" get="inline" set="null" line="99"><f a="position">
	<x path="Int"/>
	<x path="Int"/>
</f></getInt16>
		<getInt32 public="1" get="inline" set="null" line="111"><f a="position">
	<x path="Int"/>
	<x path="Int"/>
</f></getInt32>
		<getLength public="1" set="method" line="123"><f a=""><x path="Int"/></f></getLength>
		<getStart public="1" set="method" line="130"><f a=""><x path="Int"/></f></getStart>
		<getUInt8 public="1" get="inline" set="null" line="137"><f a="position">
	<x path="Int"/>
	<x path="Int"/>
</f></getUInt8>
		<setFloat32 public="1" get="inline" set="null" line="149"><f a="position:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat32>
		<setInt16 public="1" get="inline" set="null" line="161"><f a="position:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setInt16>
		<setInt32 public="1" get="inline" set="null" line="173"><f a="position:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setInt32>
		<setUInt8 public="1" get="inline" set="null" line="185"><f a="position:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setUInt8>
		<new set="method" line="28"><f a="lengthOrBuffer:?byteOffset:?length" v=":0:null">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.utils.Assets" params="" file="/Users/sven/dev/lime/lime/utils/Assets.hx">
		<initialized line="40" static="1"><x path="Bool"/></initialized>
		<id public="1" get="accessor" set="null" static="1"><c path="Array"><c path="String"/></c></id>
		<library public="1" get="accessor" set="null" static="1"><x path="Map">
	<c path="String"/>
	<e path="lime.utils.LibraryType"/>
</x></library>
		<path public="1" get="accessor" set="null" static="1"><x path="Map">
	<c path="String"/>
	<c path="String"/>
</x></path>
		<type public="1" get="accessor" set="null" static="1"><x path="Map">
	<c path="String"/>
	<e path="lime.utils.AssetType"/>
</x></type>
		<initialize set="method" line="49" static="1"><f a=""><x path="Void"/></f></initialize>
		<getBytes public="1" set="method" line="69" static="1">
			<f a="id">
				<c path="String"/>
				<t path="lime.utils.ByteArray"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded binary asset
		 * @usage		var bytes = Assets.getBytes("file.zip");
		 * @param	id		The ID or asset path for the file
		 * @return		A new ByteArray object</haxe_doc>
		</getBytes>
		<getText public="1" set="method" line="117" static="1">
			<f a="id">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded text asset
		 * @usage		var text = Assets.getText("text.txt");
		 * @param	id		The ID or asset path for the file
		 * @return		A new String object</haxe_doc>
		</getText>
		<get_id set="method" line="162" static="1"><f a=""><c path="Array"><c path="String"/></c></f></get_id>
		<get_library set="method" line="178" static="1"><f a=""><x path="Map">
	<c path="String"/>
	<e path="lime.utils.LibraryType"/>
</x></f></get_library>
		<get_path set="method" line="191" static="1"><f a=""><x path="Map">
	<c path="String"/>
	<c path="String"/>
</x></f></get_path>
		<get_type set="method" line="204" static="1"><f a=""><x path="Map">
	<c path="String"/>
	<e path="lime.utils.AssetType"/>
</x></f></get_type>
		<haxe_doc><![CDATA[* <p>The Assets class provides a cross-platform interface to access 
	 * embedded images, fonts, sounds and other resource files.</p>
	 * 
	 * <p>The contents are populated automatically when an application
	 * is compiled using the lime command-line tools, based on the
	 * contents of the *.nmml project file.</p>
	 * 
	 * <p>For most platforms, the assets are included in the same directory
	 * or package as the application, and the paths are handled
	 * automatically. For web content, the assets are preloaded before
	 * the start of the rest of the application. You can customize the 
	 * preloader by extending the <code>NMEPreloader</code> class,
	 * and specifying a custom preloader using <window preloader="" />
	 * in the project file.</p>]]></haxe_doc>
	</class>
	<enum path="lime.utils.AssetType" params="" file="/Users/sven/dev/lime/lime/utils/Assets.hx" module="lime.utils.Assets">
		<BINARY/>
		<TEXT/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="lime.utils.LibraryType" params="" file="/Users/sven/dev/lime/lime/utils/Assets.hx" module="lime.utils.Assets">
		<SWF/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<typedef path="lime.utils.ByteArray" params="" file="/Users/sven/dev/lime/lime/utils/ByteArray.hx"><c path="lime.utils.native.ByteArray"/></typedef>
	<enum path="lime.utils.CompressionAlgorithm" params="" file="/Users/sven/dev/lime/lime/utils/CompressionAlgorithm.hx">
		<DEFLATE/>
		<ZLIB/>
		<LZMA/>
		<GZIP/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="lime.utils.Endian" params="" file="/Users/sven/dev/lime/lime/utils/Endian.hx">
		<BIG_ENDIAN public="1" get="inline" set="null" line="6" static="1"><c path="String"/></BIG_ENDIAN>
		<LITTLE_ENDIAN public="1" get="inline" set="null" line="7" static="1"><c path="String"/></LITTLE_ENDIAN>
	</class>
	<class path="lime.utils.Float32Array" params="" file="/Users/sven/dev/lime/lime/utils/Float32Array.hx">
		<extends path="lime.utils.ArrayBufferView"/>
		<SBYTES_PER_ELEMENT public="1" get="inline" set="null" line="14" static="1"><x path="Int"/></SBYTES_PER_ELEMENT>
		<fromMatrix public="1" set="method" line="83" static="1"><f a="matrix">
	<c path="lime.utils.Matrix3D"/>
	<c path="lime.utils.Float32Array"/>
</f></fromMatrix>
		<BYTES_PER_ELEMENT public="1" set="null"><x path="Int"/></BYTES_PER_ELEMENT>
		<length public="1" set="null"><x path="Int"/></length>
		<clear public="1" set="method" line="79"><f a=""><x path="Void"/></f></clear>
		<__get public="1" get="inline" set="null" line="87">
			<f a="index">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":keep"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="88">
			<f a="index:value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":keep"/>
			</meta>
		</__set>
		<new public="1" set="method" line="19"><f a="bufferOrArray:?start:?length" v=":0:null">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.utils.IDataInput" params="" file="/Users/sven/dev/lime/lime/utils/IDataInput.hx" interface="1">
		<bytesAvailable public="1" get="accessor" set="null"><x path="Int"/></bytesAvailable>
		<endian public="1" get="accessor" set="accessor"><c path="String"/></endian>
		<readBoolean public="1" set="method"><f a=""><x path="Bool"/></f></readBoolean>
		<readByte public="1" set="method"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method"><f a="outData:?inOffset:?inLen">
	<t path="lime.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></readBytes>
		<readDouble public="1" set="method"><f a=""><x path="Float"/></f></readDouble>
		<readFloat public="1" set="method"><f a=""><x path="Float"/></f></readFloat>
		<readInt public="1" set="method"><f a=""><x path="Int"/></f></readInt>
		<readShort public="1" set="method"><f a=""><x path="Int"/></f></readShort>
		<readUnsignedByte public="1" set="method"><f a=""><x path="Int"/></f></readUnsignedByte>
		<readUnsignedInt public="1" set="method"><f a=""><x path="Int"/></f></readUnsignedInt>
		<readUnsignedShort public="1" set="method"><f a=""><x path="Int"/></f></readUnsignedShort>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1" set="method"><f a="inLen">
	<x path="Int"/>
	<c path="String"/>
</f></readUTFBytes>
		<get_bytesAvailable set="method"><f a=""><x path="Int"/></f></get_bytesAvailable>
		<get_endian set="method"><f a=""><c path="String"/></f></get_endian>
		<set_endian set="method"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></set_endian>
	</class>
	<class path="lime.utils.Matrix3D" params="" file="/Users/sven/dev/lime/lime/utils/Matrix3D.hx">
		<create2D public="1" set="method" line="89" static="1"><f a="x:y:?scale:?rotation" v="::1:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="lime.utils.Matrix3D"/>
</f></create2D>
		<createABCD public="1" set="method" line="103" static="1"><f a="a:b:c:d:tx:ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="lime.utils.Matrix3D"/>
</f></createABCD>
		<createOrtho public="1" set="method" line="113" static="1"><f a="x0:x1:y0:y1:zNear:zFar">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="lime.utils.Matrix3D"/>
</f></createOrtho>
		<getAxisRotation public="1" get="inline" set="null" line="192" static="1"><f a="x:y:z:degrees">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="lime.utils.Matrix3D"/>
</f></getAxisRotation>
		<interpolate public="1" get="inline" set="null" line="242" static="1"><f a="thisMat:toMat:percent">
	<c path="lime.utils.Matrix3D"/>
	<c path="lime.utils.Matrix3D"/>
	<x path="Float"/>
	<c path="lime.utils.Matrix3D"/>
</f></interpolate>
		<determinant public="1" get="accessor" set="null"><x path="Float"/></determinant>
		<position public="1" get="accessor" set="accessor"><c path="lime.utils.Vector3D"/></position>
		<rawData public="1"><x path="lime.utils.Vector"><x path="Float"/></x></rawData>
		<append public="1" set="method" line="27"><f a="lhs">
	<c path="lime.utils.Matrix3D"/>
	<x path="Void"/>
</f></append>
		<appendRotation public="1" set="method" line="59"><f a="degrees:axis:?pivotPoint" v="::null">
	<x path="Float"/>
	<c path="lime.utils.Vector3D"/>
	<c path="lime.utils.Vector3D"/>
	<x path="Void"/>
</f></appendRotation>
		<appendScale public="1" get="inline" set="null" line="72"><f a="xScale:yScale:zScale">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></appendScale>
		<appendTranslation public="1" get="inline" set="null" line="77"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></appendTranslation>
		<clone public="1" get="inline" set="null" line="84"><f a=""><c path="lime.utils.Matrix3D"/></f></clone>
		<decompose public="1" set="method" line="127"><f a=""><x path="lime.utils.Vector"><c path="lime.utils.Vector3D"/></x></f></decompose>
		<deltaTransformVector public="1" get="inline" set="null" line="182"><f a="v">
	<c path="lime.utils.Vector3D"/>
	<c path="lime.utils.Vector3D"/>
</f></deltaTransformVector>
		<identity public="1" get="inline" set="null" line="222"><f a=""><x path="Void"/></f></identity>
		<interpolateTo public="1" get="inline" set="null" line="254"><f a="toMat:percent">
	<c path="lime.utils.Matrix3D"/>
	<x path="Float"/>
	<x path="Void"/>
</f></interpolateTo>
		<invert public="1" get="inline" set="null" line="262"><f a=""><x path="Bool"/></f></invert>
		<prepend public="1" get="inline" set="null" line="352"><f a="rhs">
	<c path="lime.utils.Matrix3D"/>
	<x path="Void"/>
</f></prepend>
		<prependRotation public="1" get="inline" set="null" line="384"><f a="degrees:axis:?pivotPoint" v="::null">
	<x path="Float"/>
	<c path="lime.utils.Vector3D"/>
	<c path="lime.utils.Vector3D"/>
	<x path="Void"/>
</f></prependRotation>
		<prependScale public="1" get="inline" set="null" line="397"><f a="xScale:yScale:zScale">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependScale>
		<prependTranslation public="1" get="inline" set="null" line="402"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependTranslation>
		<recompose public="1" set="method" line="409"><f a="components">
	<x path="lime.utils.Vector"><c path="lime.utils.Vector3D"/></x>
	<x path="Bool"/>
</f></recompose>
		<transformVector public="1" get="inline" set="null" line="430"><f a="v">
	<c path="lime.utils.Vector3D"/>
	<c path="lime.utils.Vector3D"/>
</f></transformVector>
		<transformVectors public="1" set="method" line="440"><f a="vin:vout">
	<x path="lime.utils.Vector"><x path="Float"/></x>
	<x path="lime.utils.Vector"><x path="Float"/></x>
	<x path="Void"/>
</f></transformVectors>
		<transpose public="1" get="inline" set="null" line="453"><f a=""><x path="Void"/></f></transpose>
		<get_determinant public="1" get="inline" set="null" line="471">
			<f a=""><x path="Float"/></f>
			<haxe_doc>@private</haxe_doc>
		</get_determinant>
		<get_position public="1" get="inline" set="null" line="480">
			<f a=""><c path="lime.utils.Vector3D"/></f>
			<haxe_doc>@private</haxe_doc>
		</get_position>
		<set_position public="1" get="inline" set="null" line="484">
			<f a="val">
				<c path="lime.utils.Vector3D"/>
				<c path="lime.utils.Vector3D"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</set_position>
		<new public="1" set="method" line="15"><f a="?v" v="null">
	<x path="lime.utils.Vector"><x path="Float"/></x>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.utils.UInt8Array" params="" file="/Users/sven/dev/lime/lime/utils/UInt8Array.hx">
		<extends path="lime.utils.ArrayBufferView"/>
		<SBYTES_PER_ELEMENT public="1" get="inline" set="null" line="12" static="1"><x path="Int"/></SBYTES_PER_ELEMENT>
		<BYTES_PER_ELEMENT public="1" set="null"><x path="Int"/></BYTES_PER_ELEMENT>
		<length public="1" set="null"><x path="Int"/></length>
		<__get public="1" get="inline" set="null" line="66">
			<f a="index">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":keep"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="67">
			<f a="index:value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":keep"/>
			</meta>
		</__set>
		<new public="1" set="method" line="18"><f a="bufferOrArray:?start:?length" v=":0:null">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<abstract path="lime.utils.Vector" params="T" file="/Users/sven/dev/lime/lime/utils/Vector.hx">
		<from><icast field="fromArray"><c path="Array"><c path="fromArray.U"/></c></icast></from>
		<this><c path="Array"><c path="lime.utils.Vector.T"/></c></this>
		<to><icast field="toArray"><c path="Array"><c path="toArray.T"/></c></icast></to>
		<meta><m n=":arrayAccess"/></meta>
		<impl><class path="lime.utils._Vector.Vector_Impl_" params="" file="/Users/sven/dev/lime/lime/utils/Vector.hx" private="1" module="lime.utils.Vector">
	<length public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<fixed public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</fixed>
	<_new public="1" set="method" line="11" static="1">
		<f a="?length:?fixed" v="null:null">
			<x path="Int"/>
			<x path="Bool"/>
			<c path="Array"><c path="lime.utils.Vector.T"/></c>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<concat public="1" set="method" line="18" static="1">
		<f a="this:?a" v=":null">
			<c path="Array"><c path="lime.utils.Vector.T"/></c>
			<c path="Array"><c path="lime.utils.Vector.T"/></c>
			<x path="lime.utils.Vector"><c path="lime.utils.Vector.T"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</concat>
	<copy public="1" set="method" line="25" static="1">
		<f a="this">
			<c path="Array"><c path="lime.utils.Vector.T"/></c>
			<x path="lime.utils.Vector"><c path="lime.utils.Vector.T"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</copy>
	<iterator public="1" params="T" set="method" line="32" static="1">
		<f a="this">
			<c path="Array"><c path="iterator.T"/></c>
			<t path="Iterator"><c path="iterator.T"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</iterator>
	<join public="1" set="method" line="39" static="1">
		<f a="this:sep">
			<c path="Array"><c path="lime.utils.Vector.T"/></c>
			<c path="String"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</join>
	<pop public="1" set="method" line="46" static="1">
		<f a="this">
			<c path="Array"><c path="lime.utils.Vector.T"/></c>
			<t path="Null"><c path="lime.utils.Vector.T"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</pop>
	<push public="1" set="method" line="53" static="1">
		<f a="this:x">
			<c path="Array"><c path="lime.utils.Vector.T"/></c>
			<c path="lime.utils.Vector.T"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</push>
	<reverse public="1" set="method" line="60" static="1">
		<f a="this">
			<c path="Array"><c path="lime.utils.Vector.T"/></c>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</reverse>
	<shift public="1" set="method" line="67" static="1">
		<f a="this">
			<c path="Array"><c path="lime.utils.Vector.T"/></c>
			<t path="Null"><c path="lime.utils.Vector.T"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</shift>
	<unshift public="1" set="method" line="74" static="1">
		<f a="this:x">
			<c path="Array"><c path="lime.utils.Vector.T"/></c>
			<c path="lime.utils.Vector.T"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</unshift>
	<slice public="1" set="method" line="81" static="1">
		<f a="this:?pos:?end" v=":null:null">
			<c path="Array"><c path="lime.utils.Vector.T"/></c>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Vector"><c path="lime.utils.Vector.T"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</slice>
	<sort public="1" set="method" line="88" static="1">
		<f a="this:f">
			<c path="Array"><c path="lime.utils.Vector.T"/></c>
			<f a=":">
				<c path="lime.utils.Vector.T"/>
				<c path="lime.utils.Vector.T"/>
				<x path="Int"/>
			</f>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</sort>
	<splice public="1" set="method" line="95" static="1">
		<f a="this:pos:len">
			<c path="Array"><c path="lime.utils.Vector.T"/></c>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Vector"><c path="lime.utils.Vector.T"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</splice>
	<toString public="1" set="method" line="102" static="1">
		<f a="this">
			<c path="Array"><c path="lime.utils.Vector.T"/></c>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<indexOf public="1" set="method" line="109" static="1">
		<f a="this:x:?from" v="::0">
			<c path="Array"><c path="lime.utils.Vector.T"/></c>
			<c path="lime.utils.Vector.T"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</indexOf>
	<lastIndexOf public="1" set="method" line="126" static="1">
		<f a="this:x:?from" v="::0">
			<c path="Array"><c path="lime.utils.Vector.T"/></c>
			<c path="lime.utils.Vector.T"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</lastIndexOf>
	<ofArray public="1" params="T" get="inline" set="null" line="142" static="1"><f a="a">
	<c path="Array"><d/></c>
	<x path="lime.utils.Vector"><c path="ofArray.T"/></x>
</f></ofArray>
	<convert public="1" params="T:U" get="inline" set="null" line="149" static="1"><f a="v">
	<c path="Array"><c path="convert.T"/></c>
	<x path="lime.utils.Vector"><c path="convert.U"/></x>
</f></convert>
	<fromArray public="1" params="T:U" get="inline" set="null" line="156" static="1">
		<f a="a">
			<c path="Array"><c path="fromArray.U"/></c>
			<x path="lime.utils.Vector"><c path="fromArray.T"/></x>
		</f>
		<meta><m n=":from"/></meta>
	</fromArray>
	<toArray public="1" params="T" get="inline" set="null" line="163" static="1">
		<f a="this">
			<c path="Array"><c path="toArray.T"/></c>
			<c path="Array"><c path="toArray.T"/></c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toArray>
	<get_length set="method" line="177" static="1">
		<f a="this">
			<c path="Array"><c path="lime.utils.Vector.T"/></c>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<set_length set="method" line="184" static="1">
		<f a="this:value">
			<c path="Array"><c path="lime.utils.Vector.T"/></c>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_length>
	<get_fixed set="method" line="191" static="1">
		<f a="this">
			<c path="Array"><c path="lime.utils.Vector.T"/></c>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_fixed>
	<set_fixed set="method" line="198" static="1">
		<f a="this:value">
			<c path="Array"><c path="lime.utils.Vector.T"/></c>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_fixed>
</class></impl>
	</abstract>
	<class path="lime.utils._Vector.Vector_Impl_" params="" file="/Users/sven/dev/lime/lime/utils/Vector.hx" private="1" module="lime.utils.Vector">
		<length public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<fixed public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</fixed>
		<_new public="1" set="method" line="11" static="1">
			<f a="?length:?fixed" v="null:null">
				<x path="Int"/>
				<x path="Bool"/>
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<concat public="1" set="method" line="18" static="1">
			<f a="this:?a" v=":null">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<x path="lime.utils.Vector"><c path="lime.utils.Vector.T"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</concat>
		<copy public="1" set="method" line="25" static="1">
			<f a="this">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<x path="lime.utils.Vector"><c path="lime.utils.Vector.T"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</copy>
		<iterator public="1" params="T" set="method" line="32" static="1">
			<f a="this">
				<c path="Array"><c path="iterator.T"/></c>
				<t path="Iterator"><c path="iterator.T"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</iterator>
		<join public="1" set="method" line="39" static="1">
			<f a="this:sep">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</join>
		<pop public="1" set="method" line="46" static="1">
			<f a="this">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<t path="Null"><c path="lime.utils.Vector.T"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</pop>
		<push public="1" set="method" line="53" static="1">
			<f a="this:x">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<c path="lime.utils.Vector.T"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</push>
		<reverse public="1" set="method" line="60" static="1">
			<f a="this">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</reverse>
		<shift public="1" set="method" line="67" static="1">
			<f a="this">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<t path="Null"><c path="lime.utils.Vector.T"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</shift>
		<unshift public="1" set="method" line="74" static="1">
			<f a="this:x">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<c path="lime.utils.Vector.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</unshift>
		<slice public="1" set="method" line="81" static="1">
			<f a="this:?pos:?end" v=":null:null">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Vector"><c path="lime.utils.Vector.T"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</slice>
		<sort public="1" set="method" line="88" static="1">
			<f a="this:f">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<f a=":">
					<c path="lime.utils.Vector.T"/>
					<c path="lime.utils.Vector.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</sort>
		<splice public="1" set="method" line="95" static="1">
			<f a="this:pos:len">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Vector"><c path="lime.utils.Vector.T"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</splice>
		<toString public="1" set="method" line="102" static="1">
			<f a="this">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<indexOf public="1" set="method" line="109" static="1">
			<f a="this:x:?from" v="::0">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<c path="lime.utils.Vector.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</indexOf>
		<lastIndexOf public="1" set="method" line="126" static="1">
			<f a="this:x:?from" v="::0">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<c path="lime.utils.Vector.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</lastIndexOf>
		<ofArray public="1" params="T" get="inline" set="null" line="142" static="1"><f a="a">
	<c path="Array"><d/></c>
	<x path="lime.utils.Vector"><c path="ofArray.T"/></x>
</f></ofArray>
		<convert public="1" params="T:U" get="inline" set="null" line="149" static="1"><f a="v">
	<c path="Array"><c path="convert.T"/></c>
	<x path="lime.utils.Vector"><c path="convert.U"/></x>
</f></convert>
		<fromArray public="1" params="T:U" get="inline" set="null" line="156" static="1">
			<f a="a">
				<c path="Array"><c path="fromArray.U"/></c>
				<x path="lime.utils.Vector"><c path="fromArray.T"/></x>
			</f>
			<meta><m n=":from"/></meta>
		</fromArray>
		<toArray public="1" params="T" get="inline" set="null" line="163" static="1">
			<f a="this">
				<c path="Array"><c path="toArray.T"/></c>
				<c path="Array"><c path="toArray.T"/></c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toArray>
		<get_length set="method" line="177" static="1">
			<f a="this">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<set_length set="method" line="184" static="1">
			<f a="this:value">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_length>
		<get_fixed set="method" line="191" static="1">
			<f a="this">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_fixed>
		<set_fixed set="method" line="198" static="1">
			<f a="this:value">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_fixed>
	</class>
	<class path="lime.utils.Vector3D" params="" file="/Users/sven/dev/lime/lime/utils/Vector3D.hx">
		<X_AXIS public="1" get="accessor" set="null" static="1"><c path="lime.utils.Vector3D"/></X_AXIS>
		<Y_AXIS public="1" get="accessor" set="null" static="1"><c path="lime.utils.Vector3D"/></Y_AXIS>
		<Z_AXIS public="1" get="accessor" set="null" static="1"><c path="lime.utils.Vector3D"/></Z_AXIS>
		<angleBetween public="1" get="inline" set="null" line="31" static="1"><f a="a:b">
	<c path="lime.utils.Vector3D"/>
	<c path="lime.utils.Vector3D"/>
	<x path="Float"/>
</f></angleBetween>
		<distance public="1" get="inline" set="null" line="63" static="1"><f a="pt1:pt2">
	<c path="lime.utils.Vector3D"/>
	<c path="lime.utils.Vector3D"/>
	<x path="Float"/>
</f></distance>
		<get_X_AXIS get="inline" set="null" line="148" static="1"><f a=""><c path="lime.utils.Vector3D"/></f></get_X_AXIS>
		<get_Y_AXIS get="inline" set="null" line="149" static="1"><f a=""><c path="lime.utils.Vector3D"/></f></get_Y_AXIS>
		<get_Z_AXIS get="inline" set="null" line="150" static="1"><f a=""><c path="lime.utils.Vector3D"/></f></get_Z_AXIS>
		<length public="1" get="accessor" set="null"><x path="Float"/></length>
		<lengthSquared public="1" get="accessor" set="null"><x path="Float"/></lengthSquared>
		<w public="1"><x path="Float"/></w>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<add public="1" get="inline" set="null" line="26"><f a="a">
	<c path="lime.utils.Vector3D"/>
	<c path="lime.utils.Vector3D"/>
</f></add>
		<clone public="1" get="inline" set="null" line="40"><f a=""><c path="lime.utils.Vector3D"/></f></clone>
		<copyFrom public="1" get="inline" set="null" line="45"><f a="sourceVector3D">
	<c path="lime.utils.Vector3D"/>
	<x path="Void"/>
</f></copyFrom>
		<crossProduct public="1" get="inline" set="null" line="51"><f a="a">
	<c path="lime.utils.Vector3D"/>
	<c path="lime.utils.Vector3D"/>
</f></crossProduct>
		<decrementBy public="1" get="inline" set="null" line="56"><f a="a">
	<c path="lime.utils.Vector3D"/>
	<x path="Void"/>
</f></decrementBy>
		<dotProduct public="1" get="inline" set="null" line="72"><f a="a">
	<c path="lime.utils.Vector3D"/>
	<x path="Float"/>
</f></dotProduct>
		<equals public="1" get="inline" set="null" line="77"><f a="toCompare:?allFour" v=":false">
	<c path="lime.utils.Vector3D"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></equals>
		<incrementBy public="1" get="inline" set="null" line="82"><f a="a">
	<c path="lime.utils.Vector3D"/>
	<x path="Void"/>
</f></incrementBy>
		<nearEquals public="1" get="inline" set="null" line="89"><f a="toCompare:tolerance:?allFour" v="::false">
	<c path="lime.utils.Vector3D"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></nearEquals>
		<negate public="1" get="inline" set="null" line="94"><f a=""><x path="Void"/></f></negate>
		<normalize public="1" get="inline" set="null" line="101"><f a=""><x path="Float"/></f></normalize>
		<project public="1" get="inline" set="null" line="115"><f a=""><x path="Void"/></f></project>
		<setTo public="1" get="inline" set="null" line="122"><f a="xa:ya:za">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setTo>
		<scaleBy public="1" get="inline" set="null" line="128"><f a="s">
	<x path="Float"/>
	<x path="Void"/>
</f></scaleBy>
		<subtract public="1" get="inline" set="null" line="135"><f a="a">
	<c path="lime.utils.Vector3D"/>
	<c path="lime.utils.Vector3D"/>
</f></subtract>
		<toString public="1" get="inline" set="null" line="140"><f a=""><c path="String"/></f></toString>
		<get_length get="inline" set="null" line="146"><f a=""><x path="Float"/></f></get_length>
		<get_lengthSquared get="inline" set="null" line="147"><f a=""><x path="Float"/></f></get_lengthSquared>
		<new public="1" set="method" line="18"><f a="?x:?y:?z:?w" v="0.f:0.f:0.f:0.f">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.utils.native.ByteArray" params="" file="/Users/sven/dev/lime/lime/utils/native/ByteArray.hx">
		<extends path="haxe.io.Bytes"/>
		<implements path="lime.utils.IMemoryRange"/>
		<implements path="lime.utils.IDataInput"/>
		<fromBytes public="1" set="method" line="191" static="1"><f a="inBytes">
	<c path="haxe.io.Bytes"/>
	<c path="lime.utils.native.ByteArray"/>
</f></fromBytes>
		<readFile public="1" set="method" line="281" static="1"><f a="inString">
	<c path="String"/>
	<c path="lime.utils.native.ByteArray"/>
</f></readFile>
		<_double_bytes line="620" static="1">
			<f a=":">
				<x path="Float"/>
				<x path="Bool"/>
				<t path="haxe.io.BytesData"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</_double_bytes>
		<_double_of_bytes line="621" static="1">
			<f a=":">
				<t path="haxe.io.BytesData"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</_double_of_bytes>
		<_float_bytes line="622" static="1">
			<f a=":">
				<x path="Float"/>
				<x path="Bool"/>
				<t path="haxe.io.BytesData"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</_float_bytes>
		<_float_of_bytes line="623" static="1">
			<f a=":">
				<t path="haxe.io.BytesData"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</_float_of_bytes>
		<lime_byte_array_overwrite_file line="625" static="1"><f a=":">
	<c path="String"/>
	<c path="lime.utils.native.ByteArray"/>
	<unknown/>
</f></lime_byte_array_overwrite_file>
		<lime_byte_array_read_file line="626" static="1"><f a="">
	<c path="String"/>
	<c path="lime.utils.native.ByteArray"/>
</f></lime_byte_array_read_file>
		<lime_lzma_encode line="628" static="1"><f a="">
	<unknown/>
	<t path="haxe.io.BytesData"/>
</f></lime_lzma_encode>
		<lime_lzma_decode line="629" static="1"><f a="">
	<t path="haxe.io.BytesData"/>
	<t path="haxe.io.BytesData"/>
</f></lime_lzma_decode>
		<bigEndian public="1"><x path="Bool"/></bigEndian>
		<bytesAvailable public="1" get="accessor" set="null"><x path="Int"/></bytesAvailable>
		<endian public="1" get="accessor" set="accessor"><c path="String"/></endian>
		<position public="1"><x path="Int"/></position>
		<byteLength public="1" get="accessor" set="null"><x path="Int"/></byteLength>
		<__get public="1" get="inline" set="null" line="63">
			<f a="pos">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":keep"/></meta>
		</__get>
		<__set public="1" get="inline" set="null" line="96">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
		</__set>
		<asString public="1" set="method" line="106"><f a=""><c path="String"/></f></asString>
		<checkData public="1" set="method" line="111"><f a="inLength">
	<x path="Int"/>
	<x path="Void"/>
</f></checkData>
		<clear public="1" set="method" line="117"><f a=""><x path="Void"/></f></clear>
		<compress public="1" set="method" line="126"><f a="?algorithm" v="null">
	<e path="lime.utils.CompressionAlgorithm"/>
	<x path="Void"/>
</f></compress>
		<deflate public="1" set="method" line="164"><f a=""><x path="Void"/></f></deflate>
		<ensureElem set="method" line="171">
			<f a="inSize:inUpdateLenght">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</ensureElem>
		<getLength public="1" set="method" line="198"><f a=""><x path="Int"/></f></getLength>
		<getByteBuffer public="1" set="method" line="201"><f a=""><c path="lime.utils.native.ByteArray"/></f></getByteBuffer>
		<getStart public="1" set="method" line="202"><f a=""><x path="Int"/></f></getStart>
		<inflate public="1" set="method" line="206"><f a=""><x path="Void"/></f></inflate>
		<limeFromBytes get="inline" set="null" line="214"><f a="inBytes">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></limeFromBytes>
		<readBoolean public="1" get="inline" set="null" line="224"><f a=""><x path="Bool"/></f></readBoolean>
		<readByte public="1" get="inline" set="null" line="229"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="235"><f a="outData:?inOffset:?inLen" v=":0:0">
	<c path="lime.utils.native.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></readBytes>
		<readDouble public="1" set="method" line="259"><f a=""><x path="Float"/></f></readDouble>
		<readFloat public="1" set="method" line="287"><f a=""><x path="Float"/></f></readFloat>
		<readInt public="1" set="method" line="308"><f a=""><x path="Int"/></f></readInt>
		<readMultiByte public="1" get="inline" set="null" line="318"><f a="inLen:charSet">
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readShort public="1" set="method" line="324"><f a=""><x path="Int"/></f></readShort>
		<readUnsignedByte public="1" get="inline" set="null" line="334"><f a=""><x path="Int"/></f></readUnsignedByte>
		<readUnsignedInt public="1" set="method" line="339"><f a=""><x path="Int"/></f></readUnsignedInt>
		<readUnsignedShort public="1" set="method" line="349"><f a=""><x path="Int"/></f></readUnsignedShort>
		<readUTF public="1" set="method" line="357"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1" set="method" line="363"><f a="inLen">
	<x path="Int"/>
	<c path="String"/>
</f></readUTFBytes>
		<setLength public="1" set="method" line="387"><f a="inLength">
	<x path="Int"/>
	<x path="Void"/>
</f></setLength>
		<slice public="1" set="method" line="395"><f a="inBegin:?inEnd" v=":null">
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.native.ByteArray"/>
</f></slice>
		<ThrowEOFi set="method" line="427">
			<f a=""><x path="Int"/></f>
			<haxe_doc>@private</haxe_doc>
		</ThrowEOFi>
		<uncompress public="1" set="method" line="435"><f a="?algorithm" v="null">
	<e path="lime.utils.CompressionAlgorithm"/>
	<x path="Void"/>
</f></uncompress>
		<write_uncheck get="inline" set="null" line="477">
			<f a="inByte">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</write_uncheck>
		<writeBoolean public="1" set="method" line="485"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></writeBoolean>
		<writeByte public="1" get="inline" set="null" line="490"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="501"><f a="bytes:?inOffset:?inLength" v=":0:0">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></writeBytes>
		<writeDouble public="1" set="method" line="510"><f a="x">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeFile public="1" set="method" line="526"><f a="inString">
	<c path="String"/>
	<x path="Void"/>
</f></writeFile>
		<writeFloat public="1" set="method" line="532"><f a="x">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeInt public="1" set="method" line="547"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt>
		<writeShort public="1" set="method" line="569"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeShort>
		<writeUnsignedInt public="1" set="method" line="585"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeUnsignedInt>
		<writeUTF public="1" set="method" line="590"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTF>
		<writeUTFBytes public="1" set="method" line="602"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTFBytes>
		<get_bytesAvailable set="method" line="614"><f a=""><x path="Int"/></f></get_bytesAvailable>
		<get_byteLength set="method" line="615"><f a=""><x path="Int"/></f></get_byteLength>
		<get_endian set="method" line="616"><f a=""><c path="String"/></f></get_endian>
		<set_endian set="method" line="617"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></set_endian>
		<new public="1" set="method" line="42"><f a="?inSize" v="0">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.Audio" params="" file="/Users/sven/dev/luxe/luxe/luxe/Audio.hx">
		<core public="1">
			<c path="luxe.Core"/>
			<meta><m n=":noCompletion"/></meta>
		</core>
		<init public="1" set="method" line="17">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</init>
		<destroy public="1" set="method" line="21">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</destroy>
		<create public="1" set="method" line="32">
			<f a="_name:_file:?_stream" v="::false">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="lime.helpers.Sound"/>
			</f>
			<haxe_doc>Create a named audio reference, with optional stream flag   
            **name** The name to assign this audio reference    
            **file** The asset file id from which the audio is loaded/streamed    
            **stream** Whether or not to stream the audio, default `false`   
            **returns** The `Sound` instance, but the audio API stores this, use the API to manipulate it by name.</haxe_doc>
		</create>
		<sound public="1" set="method" line="41">
			<f a="_name">
				<c path="String"/>
				<c path="lime.helpers.Sound"/>
			</f>
			<haxe_doc>Fetch a named audio reference   
            **name** The name to acquire audio reference    
            **returns** The `Sound` instance</haxe_doc>
		</sound>
		<exists public="1" set="method" line="50">
			<f a="_name">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Determine whether a named audio reference exists  
            **name** The audio reference name to check    
            **returns** true/false</haxe_doc>
		</exists>
		<playing public="1" set="method" line="59">
			<f a="_name">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Determine whether a named audio reference is playing  
            **name** The audio reference name to check    
            **returns** true/false</haxe_doc>
		</playing>
		<on_complete public="1" set="method" line="69">
			<f a="_name:handler">
				<c path="String"/>
				<f a="">
					<c path="lime.helpers.Sound"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the on complete handler for a named audio reference   
            **name** The audio reference name to assign to   
            **handler** The callback to call when playback is complete   
            **returns** nothing</haxe_doc>
		</on_complete>
		<loop public="1" set="method" line="78">
			<f a="_name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Loop a named audio reference indefinitely. Use `stop` if needed.  
            **name** The audio reference name to loop    
            **returns** nothing</haxe_doc>
		</loop>
		<stop public="1" set="method" line="87">
			<f a="_name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stop a named audio reference from playing (or looping)   
            **name** The audio reference name to stop    
            **returns** nothing</haxe_doc>
		</stop>
		<play public="1" set="method" line="98">
			<f a="_name:?_number_of_times:?_start_position_in_s" v=":1:0">
				<c path="String"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Play a named audio reference   
            **name** The audio reference name to play    
            **number_of_times** The exact number of times to play    
            **start_position_in_s** The start time, in seconds    
            **returns** nothing</haxe_doc>
		</play>
		<volume public="1" set="method" line="108">
			<f a="_name:?_volume" v=":null">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>get/set the volume of a named audio reference    
            **name** The audio reference name to adjust    
            **volume** A new volume value (set), or leave empty (get)    
            **returns** The volume of `name` IF volume is unspecified</haxe_doc>
		</volume>
		<pan public="1" set="method" line="118">
			<f a="_name:?_pan" v=":null">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>get/set the pan of a named audio reference    
            **name** The audio reference name to adjust    
            **pan** A new pan value (set), or leave empty (get)   
            **returns** The pan of `name` IF pan is unspecified</haxe_doc>
		</pan>
		<position public="1" set="method" line="128">
			<f a="_name:?_pos" v=":null">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>get/set the position of a named audio reference    
            **name** The audio reference name to adjust    
            **pos** A new position value (set), or leave empty (get)   
            **returns** The position of `name` IF position is unspecified</haxe_doc>
		</position>
		<process public="1" set="method" line="132">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</process>
		<new public="1" set="method" line="11">
			<f a="_core">
				<c path="luxe.Core"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</new>
	</class>
	<typedef path="luxe.ProjectionType" params="" file="/Users/sven/dev/luxe/luxe/luxe/Camera.hx" module="luxe.Camera"><e path="phoenix.ProjectionType"/></typedef>
	<class path="luxe.Objects" params="" file="/Users/sven/dev/luxe/luxe/luxe/Objects.hx">
		<_show_debug public="1" line="42" static="1">
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</_show_debug>
		<_show_debug_verbose public="1" line="43" static="1">
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</_show_debug_verbose>
		<id public="1"><c path="String"/></id>
		<name public="1"><c path="String"/></name>
		<_call set="method" line="18">
			<f a="_object:_name:?args" v="::null">
				<c path="luxe.Objects"/>
				<c path="String"/>
				<c path="Array"><d/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_call>
		<_merge_properties set="method" line="27">
			<f a="_properties:_with">
				<d/>
				<d/>
				<d/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_merge_properties>
		<_debug set="method" line="44">
			<f a="v:?verbose" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_debug>
		<new public="1" set="method" line="12">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</new>
	</class>
	<class path="luxe.Entity" params="" file="/Users/sven/dev/luxe/luxe/luxe/Entity.hx">
		<extends path="luxe.Objects"/>
		<components public="1" get="accessor" set="null"><x path="Map">
	<c path="String"/>
	<c path="luxe.components.Component"/>
</x></components>
		<events public="1"><c path="luxe.Events"/></events>
		<children public="1"><c path="Array"><c path="luxe.Entity"/></c></children>
		<_destroyed public="1"><x path="Bool"/></_destroyed>
		<inited public="1"><x path="Bool"/></inited>
		<started public="1"><x path="Bool"/></started>
		<serialize public="1"><x path="Bool"/></serialize>
		<fixed_rate public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</fixed_rate>
		<parent public="1" get="accessor" set="accessor">
			<c path="luxe.Entity"/>
			<meta><m n=":isVar"/></meta>
		</parent>
		<pos public="1" get="accessor" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</pos>
		<pos_local public="1" get="accessor" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</pos_local>
		<rotation public="1" get="accessor" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</rotation>
		<rotation_local public="1" get="accessor" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</rotation_local>
		<scale public="1" get="accessor" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</scale>
		<scale_local public="1" get="accessor" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</scale_local>
		<scene public="1" get="accessor" set="accessor">
			<c path="luxe.Scene"/>
			<meta><m n=":isVar"/></meta>
		</scene>
		<_components><c path="luxe.components.Components"/></_components>
		<fixed_rate_timer><c path="haxe.Timer"/></fixed_rate_timer>
		<_last_scale><t path="luxe.Vector"/></_last_scale>
		<options><d/></options>
		<_init public="1" set="method" line="150">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</_init>
		<_reset public="1" set="method" line="178">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</_reset>
		<destroy public="1" set="method" line="203"><f a=""><x path="Void"/></f></destroy>
		<_onkeyup public="1" set="method" line="250">
			<f a="e">
				<t path="luxe.KeyEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_onkeyup>
		<_onkeydown public="1" set="method" line="271">
			<f a="e">
				<t path="luxe.KeyEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_onkeydown>
		<_onmousedown public="1" set="method" line="294">
			<f a="e">
				<t path="luxe.MouseEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_onmousedown>
		<_onmouseup public="1" set="method" line="316">
			<f a="e">
				<t path="luxe.MouseEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_onmouseup>
		<_onmousewheel public="1" set="method" line="337">
			<f a="e">
				<t path="luxe.MouseEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_onmousewheel>
		<_onmousemove public="1" set="method" line="358">
			<f a="e">
				<t path="luxe.MouseEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_onmousemove>
		<_ontouchbegin public="1" set="method" line="380">
			<f a="e">
				<t path="luxe.TouchEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_ontouchbegin>
		<_ontouchend public="1" set="method" line="401">
			<f a="e">
				<t path="luxe.TouchEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_ontouchend>
		<_ontouchmove public="1" set="method" line="422">
			<f a="e">
				<t path="luxe.TouchEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_ontouchmove>
		<_ongamepadaxis public="1" set="method" line="444">
			<f a="e">
				<unknown/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_ongamepadaxis>
		<_ongamepadball public="1" set="method" line="465">
			<f a="e">
				<unknown/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_ongamepadball>
		<_ongamepadhat public="1" set="method" line="486">
			<f a="e">
				<unknown/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_ongamepadhat>
		<_ongamepadbuttondown public="1" set="method" line="507">
			<f a="e">
				<unknown/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_ongamepadbuttondown>
		<_ongamepadbuttonup public="1" set="method" line="528">
			<f a="e">
				<unknown/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_ongamepadbuttonup>
		<_oninputdown public="1" set="method" line="551">
			<f a="_name:e">
				<c path="String"/>
				<t path="luxe.InputEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_oninputdown>
		<_oninputup public="1" set="method" line="572">
			<f a="_name:e">
				<c path="String"/>
				<t path="luxe.InputEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_oninputup>
		<_update public="1" set="method" line="594">
			<f a="dt">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_update>
		<_fixed_update public="1" set="method" line="623">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</_fixed_update>
		<get_fixed_rate set="method" line="645"><f a=""><x path="Float"/></f></get_fixed_rate>
		<set_fixed_rate set="method" line="649"><f a="_rate">
	<x path="Float"/>
	<x path="Float"/>
</f></set_fixed_rate>
		<_stop_fixed_rate_timer set="method" line="659"><f a=""><x path="Void"/></f></_stop_fixed_rate_timer>
		<_start_fixed_rate_timer set="method" line="666"><f a="_rate">
	<x path="Float"/>
	<x path="Void"/>
</f></_start_fixed_rate_timer>
		<add public="1" params="T1:T2" set="method" line="676"><f a="type:?_name:?_data" v=":'':null">
	<x path="Class"><c path="add.T1"/></x>
	<c path="String"/>
	<c path="add.T2"/>
	<c path="add.T1"/>
</f></add>
		<remove public="1" params="T" set="method" line="680"><f a="?_name:?_data" v="'':null">
	<c path="String"/>
	<c path="remove.T"/>
	<x path="Bool"/>
</f></remove>
		<get public="1" params="T" set="method" line="684"><f a="_name:?_in_children" v=":false">
	<c path="String"/>
	<x path="Bool"/>
	<c path="get.T"/>
</f></get>
		<get_any public="1" params="T" set="method" line="688"><f a="_name:?_in_children:?_first_only" v=":false:true">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="Array"><c path="get_any.T"/></c>
</f></get_any>
		<has public="1" set="method" line="692"><f a="_name">
	<c path="String"/>
	<x path="Bool"/>
</f></has>
		<get_components set="method" line="696"><f a=""><x path="Map">
	<c path="String"/>
	<c path="luxe.components.Component"/>
</x></f></get_components>
		<_add_child set="method" line="700"><f a="child">
	<c path="luxe.Entity"/>
	<x path="Void"/>
</f></_add_child>
		<add_child public="1" set="method" line="716"><f a="child">
	<c path="luxe.Entity"/>
	<x path="Void"/>
</f></add_child>
		<remove_child public="1" set="method" line="725"><f a="child">
	<c path="luxe.Entity"/>
	<x path="Void"/>
</f></remove_child>
		<set_pos_local set="method" line="731"><f a="_p">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_pos_local>
		<set_rotation_local set="method" line="751"><f a="_r">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_rotation_local>
		<set_scale_local set="method" line="771"><f a="_s">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_scale_local>
		<set_pos set="method" line="792"><f a="_p">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_pos>
		<set_rotation set="method" line="817"><f a="_r">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_rotation>
		<set_scale set="method" line="844"><f a="_s">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_scale>
		<internal_parent_pos_changed public="1" set="method" line="867">
			<f a="_parent_pos">
				<t path="luxe.Vector"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</internal_parent_pos_changed>
		<internal_parent_rotation_changed public="1" set="method" line="873">
			<f a="_parent_rotation">
				<t path="luxe.Vector"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</internal_parent_rotation_changed>
		<internal_parent_scale_changed public="1" set="method" line="879">
			<f a="_parent_scale">
				<t path="luxe.Vector"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</internal_parent_scale_changed>
		<set_parent set="method" line="886"><f a="other">
	<c path="luxe.Entity"/>
	<c path="luxe.Entity"/>
</f></set_parent>
		<get_pos set="method" line="917"><f a=""><t path="luxe.Vector"/></f></get_pos>
		<get_rotation set="method" line="918"><f a=""><t path="luxe.Vector"/></f></get_rotation>
		<get_scale set="method" line="919"><f a=""><t path="luxe.Vector"/></f></get_scale>
		<get_scene set="method" line="921"><f a=""><c path="luxe.Scene"/></f></get_scene>
		<set_scene set="method" line="922"><f a="_scene">
	<c path="luxe.Scene"/>
	<c path="luxe.Scene"/>
</f></set_scene>
		<get_pos_local set="method" line="924"><f a=""><t path="luxe.Vector"/></f></get_pos_local>
		<get_rotation_local set="method" line="925"><f a=""><t path="luxe.Vector"/></f></get_rotation_local>
		<get_scale_local set="method" line="926"><f a=""><t path="luxe.Vector"/></f></get_scale_local>
		<get_parent set="method" line="928"><f a=""><c path="luxe.Entity"/></f></get_parent>
		<_pos_change set="method" line="933"><f a="_v">
	<x path="Float"/>
	<x path="Void"/>
</f></_pos_change>
		<_scale_change set="method" line="935"><f a="_v">
	<x path="Float"/>
	<x path="Void"/>
</f></_scale_change>
		<_rotation_change set="method" line="937"><f a="_v">
	<x path="Float"/>
	<x path="Void"/>
</f></_rotation_change>
		<_attach_listener set="method" line="941"><f a="_v:listener">
	<t path="luxe.Vector"/>
	<f a="">
		<x path="Float"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></_attach_listener>
		<get_serialize_data public="1" set="method" line="947"><f a=""><d/></f></get_serialize_data>
		<serialize_to_disk public="1" set="method" line="965"><f a="_destination_path:?_parent_write" v=":false">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></serialize_to_disk>
		<new public="1" params="T" set="method" line="54"><f a="?_options" v="null">
	<t path="luxe.options.EntityOptions"><c path="new.T"/></t>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.Camera" params="" file="/Users/sven/dev/luxe/luxe/luxe/Camera.hx">
		<extends path="luxe.Entity"/>
		<viewport public="1" get="accessor" set="accessor">
			<t path="luxe.Rectangle"/>
			<meta><m n=":isVar"/></meta>
		</viewport>
		<center public="1" get="accessor" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</center>
		<zoom public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</zoom>
		<minimum_zoom public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</minimum_zoom>
		<view public="1"><c path="phoenix.Camera"/></view>
		<bounds public="1"><t path="luxe.Rectangle"/></bounds>
		<shake_vector public="1"><t path="luxe.Vector"/></shake_vector>
		<shake_amount public="1"><x path="Float"/></shake_amount>
		<shaking public="1"><x path="Bool"/></shaking>
		<minimum_shake public="1"><x path="Float"/></minimum_shake>
		<_final_pos><t path="luxe.Vector"/></_final_pos>
		<_rotation_radian><t path="luxe.Vector"/></_rotation_radian>
		<_rotation_cache><c path="phoenix.Quaternion"/></_rotation_cache>
		<get_viewport set="method" line="66"><f a=""><t path="luxe.Rectangle"/></f></get_viewport>
		<set_viewport set="method" line="70"><f a="_v">
	<t path="luxe.Rectangle"/>
	<t path="luxe.Rectangle"/>
</f></set_viewport>
		<get_center set="method" line="74"><f a=""><t path="luxe.Vector"/></f></get_center>
		<set_center set="method" line="78"><f a="_c">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_center>
		<get_scale set="method" line="82" override="1"><f a=""><t path="luxe.Vector"/></f></get_scale>
		<set_scale set="method" line="86" override="1"><f a="_c">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_scale>
		<get_rotation set="method" line="90" override="1"><f a=""><t path="luxe.Vector"/></f></get_rotation>
		<set_rotation set="method" line="102" override="1"><f a="_r">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_rotation>
		<get_minimum_zoom set="method" line="122"><f a=""><x path="Float"/></f></get_minimum_zoom>
		<set_minimum_zoom set="method" line="126"><f a="_m">
	<x path="Float"/>
	<x path="Float"/>
</f></set_minimum_zoom>
		<get_zoom set="method" line="130"><f a=""><x path="Float"/></f></get_zoom>
		<set_zoom set="method" line="134"><f a="_z">
	<x path="Float"/>
	<x path="Float"/>
</f></set_zoom>
		<focus public="1" set="method" line="139"><f a="_p:?_t:?oncomplete" v=":0.6f:null">
	<t path="luxe.Vector"/>
	<x path="Float"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></focus>
		<screen_point_to_world public="1" set="method" line="153"><f a="_vector">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></screen_point_to_world>
		<world_point_to_screen public="1" set="method" line="159"><f a="_vector:?_viewport" v=":null">
	<t path="luxe.Vector"/>
	<t path="luxe.Rectangle"/>
	<t path="luxe.Vector"/>
</f></world_point_to_screen>
		<get_pos public="1" set="method" line="166" override="1">
			<f a=""><t path="luxe.Vector"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_pos>
		<set_pos public="1" set="method" line="172" override="1">
			<f a="v">
				<t path="luxe.Vector"/>
				<t path="luxe.Vector"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_pos>
		<shake public="1" set="method" line="195"><f a="amount">
	<x path="Float"/>
	<x path="Void"/>
</f></shake>
		<update public="1" set="method" line="203">
			<f a="dt">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</update>
		<get_serialize_data public="1" set="method" line="238" override="1"><f a=""><d/></f></get_serialize_data>
		<new public="1" set="method" line="38"><f a="?options" v="null">
	<t path="luxe.options.LuxeCameraOptions"/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="luxe.Color" params="" file="/Users/sven/dev/luxe/luxe/luxe/Color.hx"><c path="phoenix.Color"/></typedef>
	<typedef path="luxe.ColorHSV" params="" file="/Users/sven/dev/luxe/luxe/luxe/Color.hx" module="luxe.Color"><c path="phoenix.ColorHSV"/></typedef>
	<typedef path="luxe.ColorHSL" params="" file="/Users/sven/dev/luxe/luxe/luxe/Color.hx" module="luxe.Color"><c path="phoenix.ColorHSL"/></typedef>
	<typedef path="luxe.LoadTextureInfo" params="" file="/Users/sven/dev/luxe/luxe/luxe/Core.hx" module="luxe.Core"><a>
	<onloaded><f a="">
	<c path="phoenix.Texture"/>
	<x path="Void"/>
</f></onloaded>
	<id><c path="String"/></id>
	<bytes><t path="lime.utils.ByteArray"/></bytes>
</a></typedef>
	<typedef path="luxe.LoadShaderInfo" params="" file="/Users/sven/dev/luxe/luxe/luxe/Core.hx" module="luxe.Core"><a>
	<vs_id><c path="String"/></vs_id>
	<ps_id><c path="String"/></ps_id>
	<onloaded><f a="">
	<c path="phoenix.Shader"/>
	<x path="Void"/>
</f></onloaded>
</a></typedef>
	<enum path="luxe.CoreThreadRequest" params="" file="/Users/sven/dev/luxe/luxe/luxe/Core.hx" module="luxe.Core">
		<load_texture/>
		<load_shader/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="luxe.Core" params="" file="/Users/sven/dev/luxe/luxe/luxe/Core.hx">
		<load public="1" set="method" line="394" static="1"><f a="library:method:?args" v="::0">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<d/>
</f></load>
		<host_tag_update get="inline" set="null" line="689" static="1"><c path="String"/></host_tag_update>
		<core_tag_render get="inline" set="null" line="690" static="1"><c path="String"/></core_tag_render>
		<core_tag_debug get="inline" set="null" line="691" static="1"><c path="String"/></core_tag_debug>
		<core_tag_physics get="inline" set="null" line="692" static="1"><c path="String"/></core_tag_physics>
		<core_tag_updates get="inline" set="null" line="693" static="1"><c path="String"/></core_tag_updates>
		<core_tag_events get="inline" set="null" line="694" static="1"><c path="String"/></core_tag_events>
		<core_tag_audio get="inline" set="null" line="695" static="1"><c path="String"/></core_tag_audio>
		<core_tag_input get="inline" set="null" line="696" static="1"><c path="String"/></core_tag_input>
		<core_tag_time get="inline" set="null" line="697" static="1"><c path="String"/></core_tag_time>
		<core_tag_scene get="inline" set="null" line="698" static="1"><c path="String"/></core_tag_scene>
		<version public="1"><c path="String"/></version>
		<host public="1"><d/></host>
		<config public="1"><t path="lime.LimeConfig"/></config>
		<core_thread public="1"><c path="cpp.vm.Thread"/></core_thread>
		<thread_message public="1"><d/></thread_message>
		<console_visible public="1"><x path="Bool"/></console_visible>
		<lime public="1"><c path="lime.Lime"/></lime>
		<debug public="1"><c path="luxe.Debug"/></debug>
		<draw public="1"><c path="luxe.Draw"/></draw>
		<time public="1"><c path="luxe.Timer"/></time>
		<events public="1"><c path="luxe.Events"/></events>
		<input public="1"><c path="luxe.Input"/></input>
		<audio public="1"><c path="luxe.Audio"/></audio>
		<scene public="1"><c path="luxe.Scene"/></scene>
		<renderer public="1"><c path="phoenix.Renderer"/></renderer>
		<screen public="1"><c path="luxe.Screen"/></screen>
		<physics public="1"><c path="luxe.Physics"/></physics>
		<dt public="1"><x path="Float"/></dt>
		<end_dt><x path="Float"/></end_dt>
		<_mouse_pos><t path="luxe.Vector"/></_mouse_pos>
		<_touch_pos><t path="luxe.Vector"/></_touch_pos>
		<_update_handlers><x path="Map">
	<c path="String"/>
	<f a="">
		<x path="Float"/>
		<x path="Void"/>
	</f>
</x></_update_handlers>
		<add_internal_update public="1" set="method" line="97"><f a="_update">
	<f a="">
		<x path="Float"/>
		<x path="Void"/>
	</f>
	<c path="String"/>
</f></add_internal_update>
		<shutting_down public="1"><x path="Bool"/></shutting_down>
		<has_shutdown public="1"><x path="Bool"/></has_shutdown>
		<ready set="method" line="136"><f a="_lime">
	<c path="lime.Lime"/>
	<x path="Void"/>
</f></ready>
		<init public="1" set="method" line="167"><f a=""><x path="Void"/></f></init>
		<shutdown public="1" set="method" line="222"><f a=""><x path="Void"/></f></shutdown>
		<update public="1" set="method" line="268"><f a=""><x path="Void"/></f></update>
		<render public="1" set="method" line="365"><f a=""><x path="Void"/></f></render>
		<set_renderer public="1" set="method" line="387"><f a="_renderer">
	<c path="phoenix.Renderer"/>
	<x path="Void"/>
</f></set_renderer>
		<show_console public="1" set="method" line="398"><f a="?_show" v="true">
	<x path="Bool"/>
	<x path="Void"/>
</f></show_console>
		<onresize public="1" set="method" line="406"><f a="e">
	<a>
		<y set="null"><x path="Float"/></y>
		<x set="null"><x path="Float"/></x>
	</a>
	<x path="Void"/>
</f></onresize>
		<onkeydown public="1" set="method" line="422"><f a="e">
	<t path="luxe.KeyEvent"/>
	<x path="Void"/>
</f></onkeydown>
		<onkeyup public="1" set="method" line="443"><f a="e">
	<t path="luxe.KeyEvent"/>
	<x path="Void"/>
</f></onkeyup>
		<oninputdown public="1" set="method" line="462"><f a="_name:e">
	<c path="String"/>
	<t path="luxe.InputEvent"/>
	<x path="Void"/>
</f></oninputdown>
		<oninputup public="1" set="method" line="474"><f a="_name:e">
	<c path="String"/>
	<t path="luxe.InputEvent"/>
	<x path="Void"/>
</f></oninputup>
		<onmousedown public="1" set="method" line="488"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></onmousedown>
		<onmousewheel public="1" set="method" line="506"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></onmousewheel>
		<onmouseup public="1" set="method" line="520"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></onmouseup>
		<onmousemove public="1" set="method" line="538"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></onmousemove>
		<touches_down><x path="Map">
	<x path="Int"/>
	<t path="luxe.TouchEvent"/>
</x></touches_down>
		<ontouchbegin public="1" set="method" line="558"><f a="e">
	<t path="luxe.TouchEvent"/>
	<x path="Void"/>
</f></ontouchbegin>
		<ontouchend public="1" set="method" line="591"><f a="e">
	<t path="luxe.TouchEvent"/>
	<x path="Void"/>
</f></ontouchend>
		<ontouchmove public="1" set="method" line="609"><f a="e">
	<t path="luxe.TouchEvent"/>
	<x path="Void"/>
</f></ontouchmove>
		<ongamepadaxis public="1" set="method" line="627"><f a="e">
	<unknown/>
	<x path="Void"/>
</f></ongamepadaxis>
		<ongamepadball public="1" set="method" line="639"><f a="e">
	<unknown/>
	<x path="Void"/>
</f></ongamepadball>
		<ongamepadhat public="1" set="method" line="651"><f a="e">
	<unknown/>
	<x path="Void"/>
</f></ongamepadhat>
		<ongamepadbuttondown public="1" set="method" line="663"><f a="e">
	<unknown/>
	<x path="Void"/>
</f></ongamepadbuttondown>
		<ongamepadbuttonup public="1" set="method" line="675"><f a="e">
	<unknown/>
	<x path="Void"/>
</f></ongamepadbuttonup>
		<log public="1"><x path="Bool"/></log>
		<verbose public="1"><x path="Bool"/></verbose>
		<more_verbose public="1"><x path="Bool"/></more_verbose>
		<_debug public="1" set="method" line="705"><f a="value:?_verbose:?_more_verbose" v=":false:false">
	<d/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></_debug>
		<new public="1" set="method" line="111"><f a="_host">
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":noCompletion"/></meta>
	</class>
	<class path="luxe.Debug" params="" file="/Users/sven/dev/luxe/luxe/luxe/Debug.hx">
		<shut_down public="1" line="27" static="1"><x path="Bool"/></shut_down>
		<views public="1" static="1"><c path="Array"><c path="luxe.debug.DebugView"/></c></views>
		<trace_callbacks static="1"><x path="Map">
	<c path="String"/>
	<f a=":?">
		<d/>
		<t path="haxe.PosInfos"/>
		<x path="Void"/>
	</f>
</x></trace_callbacks>
		<internal_trace public="1" set="method" line="94" static="1"><f a="v:?inf" v=":null">
	<d/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></internal_trace>
		<core public="1"><c path="luxe.Core"/></core>
		<visible public="1"><x path="Bool"/></visible>
		<debug_inspector public="1"><c path="luxe.debug.Inspector"/></debug_inspector>
		<overlay public="1"><c path="phoenix.geometry.QuadGeometry"/></overlay>
		<batcher public="1"><c path="phoenix.Batcher"/></batcher>
		<view public="1"><c path="phoenix.Camera"/></view>
		<debug_font public="1"><c path="phoenix.BitmapFont"/></debug_font>
		<dt_average public="1"><x path="Float"/></dt_average>
		<dt_average_accum public="1"><x path="Float"/></dt_average_accum>
		<dt_average_span public="1"><x path="Int"/></dt_average_span>
		<dt_average_count public="1"><x path="Int"/></dt_average_count>
		<current_view_index public="1"><x path="Int"/></current_view_index>
		<last_view_index public="1"><x path="Int"/></last_view_index>
		<current_view public="1"><c path="luxe.debug.DebugView"/></current_view>
		<padding public="1"><t path="luxe.Vector"/></padding>
		<started public="1"><x path="Bool"/></started>
		<profile_path public="1"><c path="String"/></profile_path>
		<profiling public="1"><x path="Bool"/></profiling>
		<init public="1" set="method" line="61"><f a=""><x path="Void"/></f></init>
		<start public="1" set="method" line="80"><f a="_name">
	<c path="String"/>
	<x path="Void"/>
</f></start>
		<end public="1" set="method" line="83"><f a="_name">
	<c path="String"/>
	<x path="Void"/>
</f></end>
		<remove_trace_listener public="1" set="method" line="87"><f a="_name">
	<c path="String"/>
	<x path="Void"/>
</f></remove_trace_listener>
		<add_trace_listener public="1" set="method" line="90"><f a="_name:_callback">
	<c path="String"/>
	<f a=":?">
		<d/>
		<t path="haxe.PosInfos"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></add_trace_listener>
		<create_debug_console public="1" set="method" line="111"><f a=""><x path="Void"/></f></create_debug_console>
		<onmouseup public="1" set="method" line="155"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></onmouseup>
		<onmousedown public="1" set="method" line="163"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></onmousedown>
		<onmousewheel public="1" set="method" line="171"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></onmousewheel>
		<onmousemove public="1" set="method" line="179"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></onmousemove>
		<onkeyup public="1" set="method" line="187"><f a="e">
	<t path="luxe.KeyEvent"/>
	<x path="Void"/>
</f></onkeyup>
		<onkeydown public="1" set="method" line="206"><f a="e">
	<t path="luxe.KeyEvent"/>
	<x path="Void"/>
</f></onkeydown>
		<onresize public="1" set="method" line="232"><f a="e">
	<a>
		<y set="null"><x path="Float"/></y>
		<x set="null"><x path="Float"/></x>
	</a>
	<x path="Void"/>
</f></onresize>
		<refresh set="method" line="237"><f a=""><x path="Void"/></f></refresh>
		<switch_view public="1" set="method" line="241"><f a=""><x path="Void"/></f></switch_view>
		<last_cursor_shown><x path="Bool"/></last_cursor_shown>
		<last_cursor_locked><x path="Bool"/></last_cursor_locked>
		<show_console public="1" set="method" line="267"><f a="?_show" v="true">
	<x path="Bool"/>
	<x path="Void"/>
</f></show_console>
		<destroy public="1" set="method" line="303"><f a=""><x path="Void"/></f></destroy>
		<process public="1" set="method" line="310"><f a=""><x path="Void"/></f></process>
		<new public="1" set="method" line="57"><f a="_core">
	<c path="luxe.Core"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.Draw" params="" file="/Users/sven/dev/luxe/luxe/luxe/Draw.hx">
		<core public="1">
			<c path="luxe.Core"/>
			<meta><m n=":noCompletion"/></meta>
		</core>
		<default_options set="method" line="20"><f a="options">
	<d/>
	<unknown/>
</f></default_options>
		<line public="1" set="method" line="35"><f a="options">
	<d/>
	<c path="phoenix.geometry.LineGeometry"/>
</f></line>
		<box public="1" set="method" line="52"><f a="options">
	<d/>
	<c path="phoenix.geometry.QuadGeometry"/>
</f></box>
		<rectangle public="1" set="method" line="66"><f a="options">
	<d/>
	<c path="phoenix.geometry.RectangleGeometry"/>
</f></rectangle>
		<text public="1" set="method" line="80"><f a="options">
	<d/>
	<c path="phoenix.geometry.Geometry"/>
</f></text>
		<ring public="1" set="method" line="92"><f a="options">
	<d/>
	<c path="phoenix.geometry.RingGeometry"/>
</f></ring>
		<arc public="1" set="method" line="106"><f a="options">
	<d/>
	<c path="phoenix.geometry.ArcGeometry"/>
</f></arc>
		<circle public="1" set="method" line="120"><f a="options">
	<d/>
	<c path="phoenix.geometry.CircleGeometry"/>
</f></circle>
		<ngon public="1" set="method" line="133"><f a="options">
	<d/>
	<c path="phoenix.geometry.Geometry"/>
</f></ngon>
		<plane public="1" set="method" line="204"><f a="options">
	<d/>
	<c path="phoenix.geometry.PlaneGeometry"/>
</f></plane>
		<axis3D public="1" set="method" line="219"><f a="?options" v="null">
	<d/>
	<x path="Void"/>
</f></axis3D>
		<new public="1" set="method" line="18">
			<f a="_core">
				<c path="luxe.Core"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</new>
	</class>
	<class path="luxe.Events" params="" file="/Users/sven/dev/luxe/luxe/luxe/Events.hx">
		<event_queue public="1">
			<x path="Map">
				<c path="String"/>
				<c path="luxe._Events.EventObject"/>
			</x>
			<meta><m n=":noCompletion"/></meta>
		</event_queue>
		<event_connections public="1">
			<x path="Map">
				<c path="String"/>
				<c path="luxe._Events.EventConnection"/>
			</x>
			<meta><m n=":noCompletion"/></meta>
		</event_connections>
		<event_slots public="1">
			<x path="Map">
				<c path="String"/>
				<c path="Array"><c path="luxe._Events.EventConnection"/></c>
			</x>
			<meta><m n=":noCompletion"/></meta>
		</event_slots>
		<event_filters public="1">
			<x path="Map">
				<c path="String"/>
				<c path="Array"><c path="luxe._Events.EventConnection"/></c>
			</x>
			<meta><m n=":noCompletion"/></meta>
		</event_filters>
		<event_schedules public="1">
			<x path="Map">
				<c path="String"/>
				<c path="haxe.Timer"/>
			</x>
			<meta><m n=":noCompletion"/></meta>
		</event_schedules>
		<destroy public="1" set="method" line="24"><f a=""><x path="Void"/></f></destroy>
		<clear public="1" set="method" line="28"><f a=""><x path="Void"/></f></clear>
		<does_filter_event public="1" set="method" line="54"><f a="_filter:_event">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></does_filter_event>
		<listen public="1" params="T" set="method" line="68"><f a="_event_name:_listener">
	<c path="String"/>
	<f a="">
		<c path="listen.T"/>
		<x path="Void"/>
	</f>
	<c path="String"/>
</f></listen>
		<disconnect public="1" set="method" line="113"><f a="event_id">
	<c path="String"/>
	<x path="Bool"/>
</f></disconnect>
		<queue public="1" params="T" set="method" line="145"><f a="event_name:?properties" v=":null">
	<c path="String"/>
	<c path="queue.T"/>
	<c path="String"/>
</f></queue>
		<dequeue public="1" set="method" line="159"><f a="event_id">
	<c path="String"/>
	<x path="Bool"/>
</f></dequeue>
		<process public="1" set="method" line="172"><f a=""><x path="Void"/></f></process>
		<fire public="1" params="T" set="method" line="192"><f a="_event_name:?_properties" v=":null">
	<c path="String"/>
	<c path="fire.T"/>
	<x path="Bool"/>
</f></fire>
		<schedule public="1" params="T" set="method" line="240"><f a="time:event_name:?properties" v="::null">
	<x path="Float"/>
	<c path="String"/>
	<c path="schedule.T"/>
	<c path="String"/>
</f></schedule>
		<unschedule public="1" set="method" line="257"><f a="schedule_id">
	<c path="String"/>
	<x path="Bool"/>
</f></unschedule>
		<tag_properties set="method" line="274"><f a="_properties:_name:_count">
	<d/>
	<c path="String"/>
	<x path="Int"/>
	<c path="fire.T"/>
</f></tag_properties>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="luxe._Events.EventConnection" params="" file="/Users/sven/dev/luxe/luxe/luxe/Events.hx" private="1" module="luxe.Events">
		<listener public="1"><f a="">
	<d/>
	<x path="Void"/>
</f></listener>
		<id public="1"><c path="String"/></id>
		<event_name public="1"><c path="String"/></event_name>
		<new public="1" set="method" line="298"><f a="_id:_event_name:_listener">
	<c path="String"/>
	<c path="String"/>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe._Events.EventObject" params="" file="/Users/sven/dev/luxe/luxe/luxe/Events.hx" private="1" module="luxe.Events">
		<id public="1"><c path="String"/></id>
		<name public="1"><c path="String"/></name>
		<properties public="1"><d/></properties>
		<new public="1" set="method" line="317"><f a="_id:_event_name:_event_properties">
	<c path="String"/>
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="luxe.KeyValue" params="" file="/Users/sven/dev/luxe/luxe/luxe/Input.hx" module="luxe.Input"><e path="lime.helpers.KeyValue"/></typedef>
	<typedef path="luxe.MouseButton" params="" file="/Users/sven/dev/luxe/luxe/luxe/Input.hx" module="luxe.Input"><e path="lime.MouseButton"/></typedef>
	<typedef path="luxe.MouseState" params="" file="/Users/sven/dev/luxe/luxe/luxe/Input.hx" module="luxe.Input"><e path="lime.MouseState"/></typedef>
	<typedef path="luxe.TouchState" params="" file="/Users/sven/dev/luxe/luxe/luxe/Input.hx" module="luxe.Input"><e path="lime.TouchState"/></typedef>
	<typedef path="luxe.ButtonState" params="" file="/Users/sven/dev/luxe/luxe/luxe/Input.hx" module="luxe.Input"><e path="lime.ButtonState"/></typedef>
	<typedef path="luxe.KeyEvent" params="" file="/Users/sven/dev/luxe/luxe/luxe/Input.hx" module="luxe.Input"><t path="lime.KeyEvent"/></typedef>
	<typedef path="luxe.GamepadEvent" params="" file="/Users/sven/dev/luxe/luxe/luxe/Input.hx" module="luxe.Input"><t path="lime.GamepadEvent"/></typedef>
	<typedef path="luxe.GamepadButtonEvent" params="" file="/Users/sven/dev/luxe/luxe/luxe/Input.hx" module="luxe.Input"><t path="lime.GamepadButtonEvent"/></typedef>
	<typedef path="luxe.GamepadAxisEvent" params="" file="/Users/sven/dev/luxe/luxe/luxe/Input.hx" module="luxe.Input"><t path="lime.GamepadAxisEvent"/></typedef>
	<typedef path="luxe.TouchEvent" params="" file="/Users/sven/dev/luxe/luxe/luxe/Input.hx" module="luxe.Input"><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
	<state><e path="lime.TouchState"/></state>
	<raw><d/></raw>
	<pos><t path="luxe.Vector"/></pos>
	<flags><x path="Int"/></flags>
	<ID><x path="Int"/></ID>
</a></typedef>
	<typedef path="luxe.MouseEvent" params="" file="/Users/sven/dev/luxe/luxe/luxe/Input.hx" module="luxe.Input"><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
	<state><e path="lime.MouseState"/></state>
	<shift_down><x path="Bool"/></shift_down>
	<raw><d/></raw>
	<pos><t path="luxe.Vector"/></pos>
	<meta_down><x path="Bool"/></meta_down>
	<flags><x path="Int"/></flags>
	<deltaY><x path="Float"/></deltaY>
	<deltaX><x path="Float"/></deltaX>
	<ctrl_down><x path="Bool"/></ctrl_down>
	<button><e path="lime.MouseButton"/></button>
	<alt_down><x path="Bool"/></alt_down>
</a></typedef>
	<enum path="luxe.InputType" params="" file="/Users/sven/dev/luxe/luxe/luxe/Input.hx" module="luxe.Input">
		<mouse/>
		<touch/>
		<keys/>
		<gamepad/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="luxe.InputState" params="" file="/Users/sven/dev/luxe/luxe/luxe/Input.hx" module="luxe.Input">
		<down/>
		<up/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<typedef path="luxe.InputEvent" params="" file="/Users/sven/dev/luxe/luxe/luxe/Input.hx" module="luxe.Input"><a>
	<type><e path="luxe.InputType"/></type>
	<touch_event>
		<t path="luxe.TouchEvent"/>
		<meta><m n=":optional"/></meta>
	</touch_event>
	<state><e path="luxe.InputState"/></state>
	<name><c path="String"/></name>
	<mouse_event>
		<t path="luxe.MouseEvent"/>
		<meta><m n=":optional"/></meta>
	</mouse_event>
	<key_event>
		<t path="luxe.KeyEvent"/>
		<meta><m n=":optional"/></meta>
	</key_event>
	<gamepad_event>
		<t path="luxe.GamepadEvent"/>
		<meta><m n=":optional"/></meta>
	</gamepad_event>
</a></typedef>
	<class path="luxe.Input" params="" file="/Users/sven/dev/luxe/luxe/luxe/Input.hx">
		<Keys public="1" static="1"><c path="lime.helpers.Keys"/></Keys>
		<Gamepad public="1" static="1"><c path="lime.helpers.Gamepad"/></Gamepad>
		<core public="1">
			<c path="luxe.Core"/>
			<meta><m n=":noCompletion"/></meta>
		</core>
		<key_bindings><x path="Map">
	<c path="String"/>
	<x path="Map">
		<t path="luxe.KeyValue"/>
		<x path="Bool"/>
	</x>
</x></key_bindings>
		<mouse_bindings><x path="Map">
	<c path="String"/>
	<x path="Map">
		<t path="luxe.MouseButton"/>
		<x path="Bool"/>
	</x>
</x></mouse_bindings>
		<init public="1" set="method" line="66">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</init>
		<destroy public="1" set="method" line="80">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</destroy>
		<process public="1" set="method" line="84">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</process>
		<add_key_binding set="method" line="106"><f a="_name:_value">
	<c path="String"/>
	<t path="luxe.KeyValue"/>
	<x path="Void"/>
</f></add_key_binding>
		<add_mouse_binding set="method" line="117"><f a="_name:_value">
	<c path="String"/>
	<t path="luxe.MouseButton"/>
	<x path="Void"/>
</f></add_mouse_binding>
		<add public="1" params="T" set="method" line="128"><f a="_name:_binding_value">
	<c path="String"/>
	<c path="add.T"/>
	<x path="Void"/>
</f></add>
		<check_named_keys public="1" set="method" line="141">
			<f a="e:?_down" v=":false">
				<t path="luxe.KeyEvent"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</check_named_keys>
		<check_named_mouse public="1" set="method" line="175">
			<f a="e:?_down" v=":false">
				<t path="luxe.MouseEvent"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</check_named_mouse>
		<onchar public="1" set="method" line="211">
			<f a="_event">
				<t path="luxe.KeyEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</onchar>
		<onkeydown public="1" set="method" line="214">
			<f a="_event">
				<t path="luxe.KeyEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</onkeydown>
		<onkeyup public="1" set="method" line="217">
			<f a="_event">
				<t path="luxe.KeyEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</onkeyup>
		<gotinputfocus public="1" set="method" line="220">
			<f a="_event">
				<t path="luxe.KeyEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</gotinputfocus>
		<lostinputfocus public="1" set="method" line="223">
			<f a="_event">
				<t path="luxe.KeyEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</lostinputfocus>
		<mousemove public="1" set="method" line="228">
			<f a="_event">
				<t path="luxe.MouseEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</mousemove>
		<mousedown public="1" set="method" line="231">
			<f a="_event">
				<t path="luxe.MouseEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</mousedown>
		<mouseclick public="1" set="method" line="234">
			<f a="_event">
				<t path="luxe.MouseEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</mouseclick>
		<mouseup public="1" set="method" line="237">
			<f a="_event">
				<t path="luxe.MouseEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</mouseup>
		<touchbegin public="1" set="method" line="243">
			<f a="_event">
				<t path="luxe.TouchEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</touchbegin>
		<touchmove public="1" set="method" line="246">
			<f a="_event">
				<t path="luxe.TouchEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</touchmove>
		<touchend public="1" set="method" line="249">
			<f a="_event">
				<t path="luxe.TouchEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</touchend>
		<touchtap public="1" set="method" line="252">
			<f a="_event">
				<t path="luxe.TouchEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</touchtap>
		<gamepadaxis public="1" set="method" line="257">
			<f a="_event">
				<t path="luxe.GamepadEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</gamepadaxis>
		<gamepadball public="1" set="method" line="260">
			<f a="_event">
				<t path="luxe.GamepadEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</gamepadball>
		<gamepadhat public="1" set="method" line="263">
			<f a="_event">
				<t path="luxe.GamepadEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</gamepadhat>
		<gamepadbuttondown public="1" set="method" line="266">
			<f a="_event">
				<t path="luxe.GamepadEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</gamepadbuttondown>
		<gamepadbuttonup public="1" set="method" line="269">
			<f a="_event">
				<t path="luxe.GamepadEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</gamepadbuttonup>
		<new public="1" set="method" line="56">
			<f a="_core">
				<c path="luxe.Core"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</new>
	</class>
	<typedef path="luxe.Slice" params="" file="/Users/sven/dev/luxe/luxe/luxe/NineSlice.hx" module="luxe.NineSlice"><a>
	<width><x path="Float"/></width>
	<source_y><x path="Float"/></source_y>
	<source_x><x path="Float"/></source_x>
	<source_width><x path="Float"/></source_width>
	<source_height><x path="Float"/></source_height>
	<pos><t path="luxe.Vector"/></pos>
	<height><x path="Float"/></height>
	<geometry_id><c path="String"/></geometry_id>
</a></typedef>
	<class path="luxe.Visual" params="" file="/Users/sven/dev/luxe/luxe/luxe/Visual.hx">
		<extends path="luxe.Entity"/>
		<size public="1" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</size>
		<geometry public="1" set="accessor">
			<c path="phoenix.geometry.Geometry"/>
			<meta><m n=":isVar"/></meta>
		</geometry>
		<locked public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</locked>
		<texture public="1" set="accessor">
			<c path="phoenix.Texture"/>
			<meta><m n=":isVar"/></meta>
		</texture>
		<shader public="1" set="accessor">
			<c path="phoenix.Shader"/>
			<meta><m n=":isVar"/></meta>
		</shader>
		<color public="1" set="accessor">
			<t path="luxe.Color"/>
			<meta><m n=":isVar"/></meta>
		</color>
		<visible public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</visible>
		<rotation_z public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</rotation_z>
		<radians public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</radians>
		<depth public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</depth>
		<group public="1" set="accessor">
			<x path="Int"/>
			<meta><m n=":isVar"/></meta>
		</group>
		<origin public="1" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</origin>
		<clip public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</clip>
		<clip_rect public="1" set="accessor">
			<t path="luxe.Rectangle"/>
			<meta><m n=":isVar"/></meta>
		</clip_rect>
		<_rotation_vector><t path="luxe.Vector"/></_rotation_vector>
		<_rotation_quat><c path="phoenix.Quaternion"/></_rotation_quat>
		<_has_custom_origin><x path="Bool"/></_has_custom_origin>
		<_creating_geometry><x path="Bool"/></_creating_geometry>
		<_create_geometry public="1" set="method" line="134">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</_create_geometry>
		<destroyed set="method" line="202"><f a=""><x path="Void"/></f></destroyed>
		<on_geometry_created set="method" line="215"><f a=""><x path="Void"/></f></on_geometry_created>
		<set_visible set="method" line="221"><f a="_v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<set_depth set="method" line="234"><f a="_v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_depth>
		<set_group set="method" line="244"><f a="_v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_group>
		<set_color set="method" line="256"><f a="_c">
	<t path="luxe.Color"/>
	<t path="luxe.Color"/>
</f></set_color>
		<set_texture set="method" line="266"><f a="_t">
	<c path="phoenix.Texture"/>
	<c path="phoenix.Texture"/>
</f></set_texture>
		<set_shader set="method" line="275"><f a="_s">
	<c path="phoenix.Shader"/>
	<c path="phoenix.Shader"/>
</f></set_shader>
		<set_origin set="method" line="286"><f a="_o">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_origin>
		<ignore_texture_on_geometry_change><x path="Bool"/></ignore_texture_on_geometry_change>
		<set_geometry set="method" line="300"><f a="_g">
	<c path="phoenix.geometry.Geometry"/>
	<c path="phoenix.geometry.Geometry"/>
</f></set_geometry>
		<set_pos set="method" line="335" override="1"><f a="_p">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_pos>
		<set_size set="method" line="352"><f a="_v">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_size>
		<get_rotation_z set="method" line="365"><f a=""><x path="Float"/></f></get_rotation_z>
		<set_rotation_z set="method" line="371"><f a="_r">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rotation_z>
		<set_radians set="method" line="379"><f a="_r">
	<x path="Float"/>
	<x path="Float"/>
</f></set_radians>
		<set_rotation set="method" line="395" override="1"><f a="_r">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_rotation>
		<set_scale set="method" line="409" override="1"><f a="_v">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_scale>
		<set_locked set="method" line="425"><f a="_l">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_locked>
		<set_clip set="method" line="438"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_clip>
		<set_clip_rect set="method" line="442"><f a="val">
	<t path="luxe.Rectangle"/>
	<t path="luxe.Rectangle"/>
</f></set_clip_rect>
		<_size_change set="method" line="449"><f a="_v">
	<x path="Float"/>
	<x path="Void"/>
</f></_size_change>
		<get_serialize_data public="1" set="method" line="451" override="1"><f a=""><d/></f></get_serialize_data>
		<new public="1" params="T" set="method" line="44"><f a="_options">
	<t path="luxe.options.VisualOptions"><c path="new.T"/></t>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.Sprite" params="" file="/Users/sven/dev/luxe/luxe/luxe/Sprite.hx">
		<extends path="luxe.Visual"/>
		<centered public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</centered>
		<flipx public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</flipx>
		<flipy public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</flipy>
		<uv public="1" set="accessor">
			<t path="luxe.Rectangle"/>
			<meta><m n=":isVar"/></meta>
		</uv>
		<geometry_quad public="1"><c path="phoenix.geometry.QuadGeometry"/></geometry_quad>
		<on_geometry_created set="method" line="52" override="1"><f a=""><x path="Void"/></f></on_geometry_created>
		<set_geometry set="method" line="89" override="1"><f a="_g">
	<c path="phoenix.geometry.Geometry"/>
	<c path="phoenix.geometry.Geometry"/>
</f></set_geometry>
		<_hit_box_vert_list><c path="Array"><t path="luxe.Vector"/></c></_hit_box_vert_list>
		<_hit_origin_offset><t path="luxe.Vector"/></_hit_origin_offset>
		<point_inside_exact public="1" set="method" line="105"><f a="_p">
	<t path="luxe.Vector"/>
	<x path="Bool"/>
</f></point_inside_exact>
		<point_inside public="1" set="method" line="123"><f a="_p">
	<t path="luxe.Vector"/>
	<x path="Bool"/>
</f></point_inside>
		<set_uv set="method" line="150"><f a="_uv">
	<t path="luxe.Rectangle"/>
	<t path="luxe.Rectangle"/>
</f></set_uv>
		<set_flipy set="method" line="165"><f a="_v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_flipy>
		<set_flipx set="method" line="175"><f a="_v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_flipx>
		<set_size set="method" line="187" override="1"><f a="_v">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_size>
		<set_centered set="method" line="212"><f a="_c">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_centered>
		<get_serialize_data public="1" set="method" line="230" override="1">
			<f a=""><d/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_serialize_data>
		<_uv_change set="method" line="248"><f a="_v">
	<x path="Float"/>
	<x path="Void"/>
</f></_uv_change>
		<_attach_rect_listener set="method" line="250"><f a="_v:listener">
	<t path="luxe.Rectangle"/>
	<f a="">
		<x path="Float"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></_attach_rect_listener>
		<new public="1" params="T" set="method" line="24"><f a="options">
	<t path="luxe.options.SpriteOptions"><c path="new.T"/></t>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.NineSlice" params="" file="/Users/sven/dev/luxe/luxe/luxe/NineSlice.hx">
		<extends path="luxe.Sprite"/>
		<top public="1"><x path="Float"/></top>
		<left public="1"><x path="Float"/></left>
		<right public="1"><x path="Float"/></right>
		<width public="1"><x path="Float"/></width>
		<bottom public="1"><x path="Float"/></bottom>
		<height public="1"><x path="Float"/></height>
		<source_x public="1"><x path="Float"/></source_x>
		<source_y public="1"><x path="Float"/></source_y>
		<source_w public="1"><x path="Float"/></source_w>
		<source_h public="1"><x path="Float"/></source_h>
		<is_set public="1"><x path="Bool"/></is_set>
		<midwidth public="1">
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</midwidth>
		<midheight public="1">
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</midheight>
		<slices public="1">
			<c path="Array"><t path="luxe.Slice"/></c>
			<meta><m n=":noCompletion"/></meta>
		</slices>
		<added public="1">
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</added>
		<nineslice_options public="1">
			<t path="luxe.options.NineSliceOptions"><d/></t>
			<meta><m n=":noCompletion"/></meta>
		</nineslice_options>
		<_geometry public="1">
			<c path="phoenix.geometry.ComplexGeometry"/>
			<meta><m n=":noCompletion"/></meta>
		</_geometry>
		<_batcher><c path="phoenix.Batcher"/></_batcher>
		<lock public="1" set="method" line="99"><f a=""><x path="Void"/></f></lock>
		<dirty public="1" set="method" line="105"><f a=""><x path="Void"/></f></dirty>
		<update_size public="1" set="method" line="111">
			<f a="_width:_height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</update_size>
		<set public="1" set="method" line="204">
			<f a="_width:_height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set>
		<set_size set="method" line="326" override="1"><f a="_v">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_size>
		<set_pos set="method" line="342" override="1"><f a="_v">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_pos>
		<destroyed set="method" line="356" override="1"><f a=""><x path="Void"/></f></destroyed>
		<set_visible set="method" line="366" override="1"><f a="_v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<set_clip set="method" line="378" override="1"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_clip>
		<set_clip_rect set="method" line="388" override="1"><f a="val">
	<t path="luxe.Rectangle"/>
	<t path="luxe.Rectangle"/>
</f></set_clip_rect>
		<set_color set="method" line="399" override="1"><f a="_color">
	<t path="luxe.Color"/>
	<t path="luxe.Color"/>
</f></set_color>
		<_create set="method" line="409"><f a="_pos:_w:_h:?_reset" v=":::false">
	<t path="luxe.Vector"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></_create>
		<create public="1" set="method" line="449"><f a="_pos:_w:_h:?_reset" v=":::false">
	<t path="luxe.Vector"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></create>
		<new public="1" params="T" set="method" line="50"><f a="_options">
	<t path="luxe.options.NineSliceOptions"><c path="new.T"/></t>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.Physics" params="" file="/Users/sven/dev/luxe/luxe/luxe/Physics.hx">
		<core public="1"><c path="luxe.Core"/></core>
		<engines public="1"><c path="Array"><c path="luxe.PhysicsEngine"/></c></engines>
		<init public="1" set="method" line="30"><f a=""><x path="Void"/></f></init>
		<add_engine public="1" params="T1:T2" set="method" line="44">
			<f a="type:?_data" v=":null">
				<x path="Class"><c path="add_engine.T1"/></x>
				<c path="add_engine.T2"/>
				<c path="add_engine.T1"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</add_engine>
		<process public="1" set="method" line="61"><f a=""><x path="Void"/></f></process>
		<destroy public="1" set="method" line="67"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="26"><f a="_core">
	<c path="luxe.Core"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.PhysicsEngine" params="" file="/Users/sven/dev/luxe/luxe/luxe/Physics.hx" module="luxe.Physics">
		<paused public="1"><x path="Bool"/></paused>
		<init public="1" set="method" line="86"><f a=""><x path="Void"/></f></init>
		<process public="1" set="method" line="89"><f a=""><x path="Void"/></f></process>
		<pause public="1" set="method" line="92"><f a="?_pause" v="true">
	<x path="Bool"/>
	<x path="Void"/>
</f></pause>
		<destroy public="1" set="method" line="106"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="81"><f a=""><x path="Void"/></f></new>
	</class>
	<typedef path="luxe.Rectangle" params="" file="/Users/sven/dev/luxe/luxe/luxe/Rectangle.hx"><c path="phoenix.Rectangle"/></typedef>
	<enum path="luxe.ResourceType" params="" file="/Users/sven/dev/luxe/luxe/luxe/Resource.hx" module="luxe.Resource">
		<unknown/>
		<text/>
		<data/>
		<texture/>
		<sound/>
		<render_texture/>
		<font/>
		<shader/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="luxe.Resource" params="" file="/Users/sven/dev/luxe/luxe/luxe/Resource.hx">
		<manager public="1"><c path="luxe.ResourceManager"/></manager>
		<type public="1"><e path="luxe.ResourceType"/></type>
		<id public="1"><c path="String"/></id>
		<persistent public="1"><x path="Bool"/></persistent>
		<time_to_load public="1"><x path="Float"/></time_to_load>
		<time_created public="1"><x path="Float"/></time_created>
		<dropped public="1"><x path="Bool"/></dropped>
		<drop public="1" set="method" line="43"><f a=""><x path="Void"/></f></drop>
		<new public="1" set="method" line="31"><f a="_manager:_type:?_load_time" v="::null">
	<c path="luxe.ResourceManager"/>
	<e path="luxe.ResourceType"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.TextResource" params="" file="/Users/sven/dev/luxe/luxe/luxe/Resource.hx" module="luxe.Resource">
		<extends path="luxe.Resource"/>
		<text public="1"><c path="String"/></text>
		<new public="1" set="method" line="60"><f a="_id:_text:_manager">
	<c path="String"/>
	<c path="String"/>
	<c path="luxe.ResourceManager"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.DataResource" params="" file="/Users/sven/dev/luxe/luxe/luxe/Resource.hx" module="luxe.Resource">
		<extends path="luxe.Resource"/>
		<data public="1"><t path="lime.utils.ByteArray"/></data>
		<new public="1" set="method" line="79"><f a="_id:_data:_manager">
	<c path="String"/>
	<t path="lime.utils.ByteArray"/>
	<c path="luxe.ResourceManager"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.SoundResource" params="" file="/Users/sven/dev/luxe/luxe/luxe/Resource.hx" module="luxe.Resource">
		<extends path="luxe.Resource"/>
		<name public="1"><c path="String"/></name>
		<new public="1" set="method" line="99"><f a="_name:_id:_manager">
	<c path="String"/>
	<c path="String"/>
	<c path="luxe.ResourceManager"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.ResourceStats" params="" file="/Users/sven/dev/luxe/luxe/luxe/ResourceManager.hx" module="luxe.ResourceManager">
		<resources public="1"><x path="Int"/></resources>
		<fonts public="1"><x path="Int"/></fonts>
		<textures public="1"><x path="Int"/></textures>
		<render_textures public="1"><x path="Int"/></render_textures>
		<shaders public="1"><x path="Int"/></shaders>
		<texts public="1"><x path="Int"/></texts>
		<datas public="1"><x path="Int"/></datas>
		<sounds public="1"><x path="Int"/></sounds>
		<unknown public="1"><x path="Int"/></unknown>
		<toString public="1" set="method" line="30"><f a=""><c path="String"/></f></toString>
		<reset public="1" set="method" line="46"><f a=""><x path="Void"/></f></reset>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="luxe.ResourceManager" params="" file="/Users/sven/dev/luxe/luxe/luxe/ResourceManager.hx">
		<resourcelist public="1"><c path="Array"><c path="luxe.Resource"/></c></resourcelist>
		<render_textures public="1"><x path="Map">
	<c path="String"/>
	<c path="phoenix.RenderTexture"/>
</x></render_textures>
		<textures public="1"><x path="Map">
	<c path="String"/>
	<c path="phoenix.Texture"/>
</x></textures>
		<shaders public="1"><x path="Map">
	<c path="String"/>
	<c path="phoenix.Shader"/>
</x></shaders>
		<fonts public="1"><x path="Map">
	<c path="String"/>
	<c path="phoenix.BitmapFont"/>
</x></fonts>
		<data public="1"><x path="Map">
	<c path="String"/>
	<t path="lime.utils.ByteArray"/>
</x></data>
		<text public="1"><x path="Map">
	<c path="String"/>
	<c path="String"/>
</x></text>
		<sounds public="1"><x path="Map">
	<c path="String"/>
	<c path="String"/>
</x></sounds>
		<stats public="1"><c path="luxe.ResourceStats"/></stats>
		<add public="1" set="method" line="93"><f a="res">
	<c path="luxe.Resource"/>
	<x path="Void"/>
</f></add>
		<remove public="1" set="method" line="122"><f a="res">
	<c path="luxe.Resource"/>
	<x path="Void"/>
</f></remove>
		<uncache public="1" set="method" line="151"><f a="res">
	<c path="luxe.Resource"/>
	<x path="Void"/>
</f></uncache>
		<cache public="1" set="method" line="175"><f a="res">
	<c path="luxe.Resource"/>
	<x path="Void"/>
</f></cache>
		<find_render_texture public="1" set="method" line="199"><f a="_name">
	<c path="String"/>
	<t path="Null"><c path="phoenix.RenderTexture"/></t>
</f></find_render_texture>
		<find_texture public="1" set="method" line="203"><f a="_name">
	<c path="String"/>
	<t path="Null"><c path="phoenix.Texture"/></t>
</f></find_texture>
		<find_shader public="1" set="method" line="207"><f a="_name">
	<c path="String"/>
	<t path="Null"><c path="phoenix.Shader"/></t>
</f></find_shader>
		<find_font public="1" set="method" line="211"><f a="_name">
	<c path="String"/>
	<t path="Null"><c path="phoenix.BitmapFont"/></t>
</f></find_font>
		<find_sound public="1" set="method" line="215"><f a="_name">
	<c path="String"/>
	<t path="Null"><c path="String"/></t>
</f></find_sound>
		<find_text public="1" set="method" line="219"><f a="_name">
	<c path="String"/>
	<t path="Null"><c path="String"/></t>
</f></find_text>
		<find_data public="1" set="method" line="223"><f a="_name">
	<c path="String"/>
	<t path="Null"><t path="lime.utils.ByteArray"/></t>
</f></find_data>
		<clear public="1" set="method" line="227"><f a="?and_persistent" v="false">
	<x path="Bool"/>
	<x path="Void"/>
</f></clear>
		<find public="1" set="method" line="253"><f a="id">
	<c path="String"/>
	<c path="luxe.Resource"/>
</f></find>
		<new public="1" set="method" line="79"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="luxe.Scene" params="" file="/Users/sven/dev/luxe/luxe/luxe/Scene.hx">
		<extends path="luxe.Objects"/>
		<entities public="1"><x path="Map">
	<c path="String"/>
	<c path="luxe.Entity"/>
</x></entities>
		<inited public="1"><x path="Bool"/></inited>
		<started public="1"><x path="Bool"/></started>
		<_delayed_init_entities><c path="Array"><c path="luxe.Entity"/></c></_delayed_init_entities>
		<_delayed_start_entities><c path="Array"><c path="luxe.Entity"/></c></_delayed_start_entities>
		<entitycount public="1" get="accessor" set="null"><x path="Int"/></entitycount>
		<toString public="1" set="method" line="24"><f a=""><c path="String"/></f></toString>
		<get_entitycount set="method" line="28"><f a=""><x path="Int"/></f></get_entitycount>
		<create public="1" params="T1:T2" set="method" line="34"><f a="type:?_name:?_data" v=":'':null">
	<x path="Class"><c path="create.T1"/></x>
	<c path="String"/>
	<c path="create.T2"/>
	<c path="create.T1"/>
</f></create>
		<add public="1" set="method" line="61"><f a="entity">
	<c path="luxe.Entity"/>
	<x path="Void"/>
</f></add>
		<list_entities set="method" line="83"><f a=""><x path="Void"/></f></list_entities>
		<remove public="1" set="method" line="89"><f a="entity">
	<c path="luxe.Entity"/>
	<x path="Bool"/>
</f></remove>
		<empty public="1" set="method" line="109"><f a=""><x path="Void"/></f></empty>
		<onkeydown public="1" set="method" line="122"><f a="e">
	<t path="luxe.KeyEvent"/>
	<x path="Void"/>
</f></onkeydown>
		<onkeyup public="1" set="method" line="129"><f a="e">
	<t path="luxe.KeyEvent"/>
	<x path="Void"/>
</f></onkeyup>
		<onmousedown public="1" set="method" line="137"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></onmousedown>
		<onmousewheel public="1" set="method" line="144"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></onmousewheel>
		<onmouseup public="1" set="method" line="151"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></onmouseup>
		<onmousemove public="1" set="method" line="158"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></onmousemove>
		<ontouchbegin public="1" set="method" line="166"><f a="e">
	<t path="luxe.TouchEvent"/>
	<x path="Void"/>
</f></ontouchbegin>
		<ontouchend public="1" set="method" line="173"><f a="e">
	<t path="luxe.TouchEvent"/>
	<x path="Void"/>
</f></ontouchend>
		<ontouchmove public="1" set="method" line="180"><f a="e">
	<t path="luxe.TouchEvent"/>
	<x path="Void"/>
</f></ontouchmove>
		<ongamepadaxis public="1" set="method" line="188"><f a="e">
	<unknown/>
	<x path="Void"/>
</f></ongamepadaxis>
		<ongamepadball public="1" set="method" line="195"><f a="e">
	<unknown/>
	<x path="Void"/>
</f></ongamepadball>
		<ongamepadhat public="1" set="method" line="202"><f a="e">
	<unknown/>
	<x path="Void"/>
</f></ongamepadhat>
		<ongamepadbuttonup public="1" set="method" line="209"><f a="e">
	<unknown/>
	<x path="Void"/>
</f></ongamepadbuttonup>
		<ongamepadbuttondown public="1" set="method" line="216"><f a="e">
	<unknown/>
	<x path="Void"/>
</f></ongamepadbuttondown>
		<oninputdown public="1" set="method" line="224"><f a="_name:e">
	<c path="String"/>
	<t path="luxe.InputEvent"/>
	<x path="Void"/>
</f></oninputdown>
		<oninputup public="1" set="method" line="231"><f a="_name:e">
	<c path="String"/>
	<t path="luxe.InputEvent"/>
	<x path="Void"/>
</f></oninputup>
		<destroy public="1" set="method" line="239"><f a=""><x path="Void"/></f></destroy>
		<_do_init set="method" line="249"><f a=""><x path="Bool"/></f></_do_init>
		<init public="1" set="method" line="270"><f a=""><x path="Void"/></f></init>
		<start public="1" set="method" line="283"><f a=""><x path="Void"/></f></start>
		<update public="1" set="method" line="295"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<fixed_update public="1" set="method" line="309"><f a=""><x path="Void"/></f></fixed_update>
		<handle_delayed_additions set="method" line="319"><f a=""><x path="Void"/></f></handle_delayed_additions>
		<serialize_to_disk public="1" set="method" line="338"><f a="_destination_path">
	<c path="String"/>
	<x path="Void"/>
</f></serialize_to_disk>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="luxe.Cursor" params="" file="/Users/sven/dev/luxe/luxe/luxe/Screen.hx" module="luxe.Screen">
		<screen><c path="luxe.Screen"/></screen>
		<visible public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</visible>
		<locked public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</locked>
		<pos public="1" get="accessor" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</pos>
		<get_visible set="method" line="22"><f a=""><x path="Bool"/></f></get_visible>
		<set_visible set="method" line="28"><f a="_visible">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<get_locked set="method" line="36"><f a=""><x path="Bool"/></f></get_locked>
		<set_locked set="method" line="42"><f a="_lock">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_locked>
		<get_pos set="method" line="50"><f a=""><t path="luxe.Vector"/></f></get_pos>
		<set_pos set="method" line="60"><f a="_p">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_pos>
		<new public="1" set="method" line="15"><f a="_screen">
	<c path="luxe.Screen"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.Screen" params="" file="/Users/sven/dev/luxe/luxe/luxe/Screen.hx">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<w public="1"><x path="Float"/></w>
		<h public="1"><x path="Float"/></h>
		<cursor public="1"><c path="luxe.Cursor"/></cursor>
		<core public="1"><c path="luxe.Core"/></core>
		<mid public="1" get="accessor" set="null">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</mid>
		<get_mid set="method" line="100"><f a=""><t path="luxe.Vector"/></f></get_mid>
		<point_inside public="1" set="method" line="106"><f a="_p">
	<t path="luxe.Vector"/>
	<x path="Bool"/>
</f></point_inside>
		<new public="1" set="method" line="86"><f a="?_core:_x:_y:_w:_h" v="null::::">
	<c path="luxe.Core"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="luxe.TextAlign" params="" file="/Users/sven/dev/luxe/luxe/luxe/Text.hx" module="luxe.Text"><e path="phoenix.TextAlign"/></typedef>
	<class path="luxe.Text" params="" file="/Users/sven/dev/luxe/luxe/luxe/Text.hx">
		<extends path="luxe.Visual"/>
		<font public="1"><c path="phoenix.BitmapFont"/></font>
		<_batcher><c path="phoenix.Batcher"/></_batcher>
		<composite_geometry public="1"><c path="phoenix.geometry.CompositeGeometry"/></composite_geometry>
		<text public="1" set="accessor">
			<c path="String"/>
			<meta><m n=":isVar"/></meta>
		</text>
		<textsize public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</textsize>
		<ready public="1"><x path="Bool"/></ready>
		<text_options public="1"><d/></text_options>
		<onloaded public="1" set="method" line="95">
			<f a="font">
				<c path="phoenix.BitmapFont"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</onloaded>
		<set_pos set="method" line="102" override="1"><f a="v">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_pos>
		<set_textsize set="method" line="111"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_textsize>
		<set_color set="method" line="123" override="1"><f a="c">
	<t path="luxe.Color"/>
	<t path="luxe.Color"/>
</f></set_color>
		<set_visible set="method" line="133" override="1"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<set_locked set="method" line="144" override="1"><f a="l">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_locked>
		<set_text set="method" line="154"><f a="t">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<new public="1" set="method" line="27"><f a="_options">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.Timer" params="" file="/Users/sven/dev/luxe/luxe/luxe/Timer.hx">
		<core public="1">
			<c path="luxe.Core"/>
			<meta><m n=":noCompletion"/></meta>
		</core>
		<init public="1" set="method" line="16">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</init>
		<destroy public="1" set="method" line="20">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</destroy>
		<process public="1" set="method" line="24">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</process>
		<schedule public="1" set="method" line="28"><f a="_time_in_seconds:_on_time:?repeat" v="::false">
	<x path="Float"/>
	<f a=""><x path="Void"/></f>
	<x path="Bool"/>
	<c path="haxe.Timer"/>
</f></schedule>
		<new public="1" set="method" line="12">
			<f a="_core">
				<c path="luxe.Core"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</new>
	</class>
	<typedef path="luxe.Vector" params="" file="/Users/sven/dev/luxe/luxe/luxe/Vector.hx"><c path="phoenix.Vector"/></typedef>
	<typedef path="luxe.Vec" params="" file="/Users/sven/dev/luxe/luxe/luxe/Vector.hx" module="luxe.Vector"><x path="phoenix.Vec"/></typedef>
	<class path="luxe.components.Component" params="" file="/Users/sven/dev/luxe/luxe/luxe/components/Components.hx" module="luxe.components.Components">
		<extends path="luxe.Objects"/>
		<entity public="1"><c path="luxe.Entity"/></entity>
		<pos public="1" get="accessor" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</pos>
		<pos_local public="1" get="accessor" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</pos_local>
		<rotation public="1" get="accessor" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</rotation>
		<rotation_local public="1" get="accessor" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</rotation_local>
		<scale public="1" get="accessor" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</scale>
		<scale_local public="1" get="accessor" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</scale_local>
		<options>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</options>
		<_init public="1" set="method" line="29">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</_init>
		<_reset public="1" set="method" line="32">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</_reset>
		<set_pos set="method" line="36"><f a="_p">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_pos>
		<set_pos_local set="method" line="39"><f a="_p">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_pos_local>
		<get_pos set="method" line="42"><f a=""><t path="luxe.Vector"/></f></get_pos>
		<get_pos_local set="method" line="45"><f a=""><t path="luxe.Vector"/></f></get_pos_local>
		<set_rotation set="method" line="49"><f a="_r">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_rotation>
		<set_rotation_local set="method" line="52"><f a="_r">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_rotation_local>
		<get_rotation set="method" line="55"><f a=""><t path="luxe.Vector"/></f></get_rotation>
		<get_rotation_local set="method" line="58"><f a=""><t path="luxe.Vector"/></f></get_rotation_local>
		<set_scale set="method" line="62"><f a="_s">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_scale>
		<set_scale_local set="method" line="65"><f a="_s">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_scale_local>
		<get_scale set="method" line="68"><f a=""><t path="luxe.Vector"/></f></get_scale>
		<get_scale_local set="method" line="71"><f a=""><t path="luxe.Vector"/></f></get_scale_local>
		<add public="1" params="T1:T2" set="method" line="75"><f a="type:?_name:?_data" v=":'':null">
	<x path="Class"><c path="add.T1"/></x>
	<c path="String"/>
	<c path="add.T2"/>
	<c path="add.T1"/>
</f></add>
		<remove public="1" params="T" set="method" line="79"><f a="?_name:?_data" v="'':null">
	<c path="String"/>
	<c path="remove.T"/>
	<x path="Bool"/>
</f></remove>
		<get public="1" params="T" set="method" line="83"><f a="_name:?in_children" v=":false">
	<c path="String"/>
	<x path="Bool"/>
	<c path="get.T"/>
</f></get>
		<get_any public="1" params="T" set="method" line="87"><f a="_name:?in_children:?first_only" v=":false:true">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="Array"><c path="get_any.T"/></c>
</f></get_any>
		<entity_pos_change public="1" set="method" line="91">
			<f a="_p">
				<t path="luxe.Vector"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</entity_pos_change>
		<entity_scale_change public="1" set="method" line="92">
			<f a="_p">
				<t path="luxe.Vector"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</entity_scale_change>
		<entity_rotation_change public="1" set="method" line="93">
			<f a="_p">
				<t path="luxe.Vector"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</entity_rotation_change>
		<_pos_change set="method" line="100">
			<f a="_v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_pos_change>
		<_scale_change set="method" line="102">
			<f a="_v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_scale_change>
		<_rotation_change set="method" line="104">
			<f a="_v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_rotation_change>
		<_attach_listener set="method" line="108">
			<f a="_v:listener">
				<t path="luxe.Vector"/>
				<f a="">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_attach_listener>
		<get_serialize_data public="1" set="method" line="114"><f a=""><d/></f></get_serialize_data>
		<serialize_to_disk public="1" set="method" line="123">
			<f a="_destination_path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</serialize_to_disk>
		<new public="1" params="T" set="method" line="21"><f a="?_options" v="null">
	<t path="luxe.options.ComponentOptions"><c path="new.T"/></t>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.components.Components" params="" file="/Users/sven/dev/luxe/luxe/luxe/components/Components.hx">
		<_show_debug public="1" line="317" static="1">
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</_show_debug>
		<components public="1"><x path="Map">
	<c path="String"/>
	<c path="luxe.components.Component"/>
</x></components>
		<entity public="1"><c path="luxe.Entity"/></entity>
		<add public="1" params="T1:T2" set="method" line="157"><f a="type:?_name:?_data" v=":'':null">
	<x path="Class"><c path="add.T1"/></x>
	<c path="String"/>
	<c path="add.T2"/>
	<c path="add.T1"/>
</f></add>
		<remove public="1" params="T" set="method" line="197"><f a="?_name:?_data" v="'':null">
	<c path="String"/>
	<c path="remove.T"/>
	<x path="Bool"/>
</f></remove>
		<get public="1" params="T" set="method" line="216"><f a="_name:?in_children" v=":false">
	<c path="String"/>
	<x path="Bool"/>
	<c path="get.T"/>
</f></get>
		<get_any public="1" params="T" set="method" line="255"><f a="_name:?in_children:?first_only" v=":false:true">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="Array"><c path="get_any.T"/></c>
</f></get_any>
		<has public="1" set="method" line="304"><f a="_name">
	<c path="String"/>
	<x path="Bool"/>
</f></has>
		<_call set="method" line="308">
			<f a="_object:_name:?args" v="::null">
				<d/>
				<c path="String"/>
				<c path="Array"><d/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_call>
		<_debug set="method" line="318">
			<f a="v">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_debug>
		<new public="1" set="method" line="150"><f a="_entity">
	<c path="luxe.Entity"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":noCompletion"/></meta>
	</class>
	<class path="luxe.debug.DebugView" params="" file="/Users/sven/dev/luxe/luxe/luxe/debug/DebugView.hx">
		<extends path="luxe.Objects"/>
		<visible public="1"><x path="Bool"/></visible>
		<refresh public="1" set="method" line="14"><f a=""><x path="Void"/></f></refresh>
		<process public="1" set="method" line="17"><f a=""><x path="Void"/></f></process>
		<onmousedown public="1" set="method" line="20"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></onmousedown>
		<onmousewheel public="1" set="method" line="23"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></onmousewheel>
		<onmouseup public="1" set="method" line="26"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></onmouseup>
		<onmousemove public="1" set="method" line="29"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></onmousemove>
		<onkeydown public="1" set="method" line="32"><f a="e">
	<t path="luxe.KeyEvent"/>
	<x path="Void"/>
</f></onkeydown>
		<onkeyup public="1" set="method" line="35"><f a="e">
	<t path="luxe.KeyEvent"/>
	<x path="Void"/>
</f></onkeyup>
		<create public="1" set="method" line="38"><f a=""><x path="Void"/></f></create>
		<show public="1" set="method" line="41"><f a=""><x path="Void"/></f></show>
		<hide public="1" set="method" line="44"><f a=""><x path="Void"/></f></hide>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="luxe.debug.BatcherDebugView" params="" file="/Users/sven/dev/luxe/luxe/luxe/debug/BatcherDebugView.hx">
		<extends path="luxe.debug.DebugView"/>
		<batcher><c path="phoenix.Batcher"/></batcher>
		<create public="1" set="method" line="20" override="1"><f a=""><x path="Void"/></f></create>
		<refresh public="1" set="method" line="28" override="1"><f a=""><x path="Void"/></f></refresh>
		<dragging><x path="Bool"/></dragging>
		<dragstart><t path="luxe.Vector"/></dragstart>
		<dragmstart><t path="luxe.Vector"/></dragmstart>
		<onmousedown public="1" set="method" line="37" override="1"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></onmousedown>
		<onmouseup public="1" set="method" line="42" override="1"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></onmouseup>
		<onmousemove public="1" set="method" line="45" override="1"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></onmousemove>
		<onmousewheel public="1" set="method" line="52" override="1"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></onmousewheel>
		<_tree_geom><c path="phoenix.geometry.CompositeGeometry"/></_tree_geom>
		<as_immediate><x path="Bool"/></as_immediate>
		<clear_batcher_tree public="1" set="method" line="63"><f a=""><x path="Void"/></f></clear_batcher_tree>
		<keystr set="method" line="70"><f a="key:key2">
	<t path="phoenix.geometry.GeometryKey"/>
	<t path="phoenix.geometry.GeometryKey"/>
	<c path="String"/>
</f></keystr>
		<draw_geom_node public="1" set="method" line="82"><f a="l:_leaf:_p:?_bbw" v=":::20">
	<x path="Bool"/>
	<c path="luxe.structural.BalancedBinarySearchTreeNode">
		<t path="phoenix.geometry.GeometryKey"/>
		<c path="phoenix.geometry.Geometry"/>
	</c>
	<t path="luxe.Vector"/>
	<x path="Float"/>
	<x path="Void"/>
</f></draw_geom_node>
		<draw_geom_leaf public="1" set="method" line="172"><f a="L:_leaf:_p">
	<x path="Bool"/>
	<c path="luxe.structural.BalancedBinarySearchTreeNode">
		<t path="phoenix.geometry.GeometryKey"/>
		<c path="phoenix.geometry.Geometry"/>
	</c>
	<t path="luxe.Vector"/>
	<x path="Void"/>
</f></draw_geom_leaf>
		<draw_batcher_tree public="1" set="method" line="235"><f a=""><x path="Void"/></f></draw_batcher_tree>
		<process public="1" set="method" line="253" override="1"><f a=""><x path="Void"/></f></process>
		<show public="1" set="method" line="261" override="1"><f a=""><x path="Void"/></f></show>
		<hide public="1" set="method" line="266" override="1"><f a=""><x path="Void"/></f></hide>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
	</class>
	<typedef path="luxe.debug.DebugInspectorOptions" params="" file="/Users/sven/dev/luxe/luxe/luxe/debug/Inspector.hx" module="luxe.debug.Inspector"><a>
	<title>
		<c path="String"/>
		<meta><m n=":optional"/></meta>
	</title>
	<size>
		<t path="luxe.Vector"/>
		<meta><m n=":optional"/></meta>
	</size>
	<pos>
		<t path="luxe.Vector"/>
		<meta><m n=":optional"/></meta>
	</pos>
	<font>
		<c path="phoenix.BitmapFont"/>
		<meta><m n=":optional"/></meta>
	</font>
	<batcher>
		<c path="phoenix.Batcher"/>
		<meta><m n=":optional"/></meta>
	</batcher>
</a></typedef>
	<class path="luxe.debug.Inspector" params="" file="/Users/sven/dev/luxe/luxe/luxe/debug/Inspector.hx">
		<title public="1"><c path="String"/></title>
		<font public="1"><c path="phoenix.BitmapFont"/></font>
		<pos public="1"><t path="luxe.Vector"/></pos>
		<size public="1"><t path="luxe.Vector"/></size>
		<_title_text public="1"><c path="luxe.Text"/></_title_text>
		<default_box_texture public="1"><c path="phoenix.Texture"/></default_box_texture>
		<default_button_texture public="1"><c path="phoenix.Texture"/></default_button_texture>
		<_window public="1"><c path="luxe.NineSlice"/></_window>
		<_batcher><c path="phoenix.Batcher"/></_batcher>
		<onrefresh public="1"><f a=""><x path="Void"/></f></onrefresh>
		<refresh public="1" set="method" line="62"><f a=""><x path="Void"/></f></refresh>
		<show public="1" set="method" line="72"><f a=""><x path="Void"/></f></show>
		<hide public="1" set="method" line="77"><f a=""><x path="Void"/></f></hide>
		<_create_window set="method" line="82"><f a=""><x path="Void"/></f></_create_window>
		<new public="1" set="method" line="36"><f a="_options">
	<t path="luxe.debug.DebugInspectorOptions"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":noCompletion"/></meta>
	</class>
	<class path="luxe.debug.ProfilerDebugView" params="" file="/Users/sven/dev/luxe/luxe/luxe/debug/ProfilerDebugView.hx">
		<extends path="luxe.debug.DebugView"/>
		<lists public="1" static="1"><x path="Map">
	<c path="String"/>
	<c path="luxe.debug._ProfilerDebugView.ProfilerValue"/>
</x></lists>
		<add_offset public="1" set="method" line="26" static="1"><f a="_id:_offset">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></add_offset>
		<hide_item public="1" set="method" line="37" static="1"><f a="_id">
	<c path="String"/>
	<x path="Void"/>
</f></hide_item>
		<show_item public="1" set="method" line="44" static="1"><f a="_id">
	<c path="String"/>
	<x path="Void"/>
</f></show_item>
		<start public="1" set="method" line="52" static="1"><f a="_id">
	<c path="String"/>
	<x path="Void"/>
</f></start>
		<end public="1" set="method" line="64" static="1"><f a="_id">
	<c path="String"/>
	<x path="Void"/>
</f></end>
		<_setup><x path="Bool"/></_setup>
		<show public="1" set="method" line="73" override="1"><f a=""><x path="Void"/></f></show>
		<hide public="1" set="method" line="88" override="1"><f a=""><x path="Void"/></f></hide>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="luxe.debug._ProfilerDebugView.ProfilerValue" params="" file="/Users/sven/dev/luxe/luxe/luxe/debug/ProfilerDebugView.hx" private="1" module="luxe.debug.ProfilerDebugView">
		<offsets public="1"><c path="Array"><c path="luxe.debug._ProfilerDebugView.ProfilerValue"/></c></offsets>
		<bar public="1"><c path="luxe.debug._ProfilerDebugView.ProfilerBar"/></bar>
		<name public="1"><c path="String"/></name>
		<start public="1"><x path="Float"/></start>
		<history public="1"><c path="Array"><x path="Float"/></c></history>
		<avg public="1"><x path="Int"/></avg>
		<hidden public="1"><x path="Bool"/></hidden>
		<count><x path="Int"/></count>
		<accum><x path="Float"/></accum>
		<set public="1" set="method" line="114"><f a=""><x path="Void"/></f></set>
		<new public="1" set="method" line="108"><f a="_name:_bar">
	<c path="String"/>
	<c path="luxe.debug._ProfilerDebugView.ProfilerBar"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.debug._ProfilerDebugView.ProfilerBar" params="" file="/Users/sven/dev/luxe/luxe/luxe/debug/ProfilerDebugView.hx" private="1" module="luxe.debug.ProfilerDebugView">
		<bar_geometry public="1"><c path="phoenix.geometry.QuadGeometry"/></bar_geometry>
		<bg_geometry public="1"><c path="phoenix.geometry.QuadGeometry"/></bg_geometry>
		<graphbg_geometry public="1"><c path="phoenix.geometry.QuadGeometry"/></graphbg_geometry>
		<graph_geometry public="1"><c path="phoenix.geometry.Geometry"/></graph_geometry>
		<text_item public="1"><c path="luxe.Text"/></text_item>
		<name public="1"><c path="String"/></name>
		<width public="1"><x path="Float"/></width>
		<height public="1"><x path="Float"/></height>
		<height2 public="1"><x path="Float"/></height2>
		<max public="1"><x path="Float"/></max>
		<history public="1"><x path="Int"/></history>
		<visible public="1"><x path="Bool"/></visible>
		<segment><x path="Float"/></segment>
		<color_red><t path="luxe.Color"/></color_red>
		<color_green><t path="luxe.Color"/></color_green>
		<color_normal><t path="luxe.Color"/></color_normal>
		<text public="1" set="accessor">
			<c path="String"/>
			<meta><m n=":isVar"/></meta>
		</text>
		<pos public="1" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</pos>
		<value public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</value>
		<ping public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</ping>
		<hide public="1" set="method" line="239"><f a=""><x path="Void"/></f></hide>
		<show public="1" set="method" line="247"><f a=""><x path="Void"/></f></show>
		<set_ping set="method" line="256"><f a="_v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_ping>
		<set_value set="method" line="292"><f a="_v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_value>
		<set_pos set="method" line="316"><f a="_p">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_pos>
		<set_text set="method" line="325"><f a="_t">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<new public="1" set="method" line="177"><f a="_name:_color">
	<c path="String"/>
	<t path="luxe.Color"/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="luxe.debug.RenderStats" params="" file="/Users/sven/dev/luxe/luxe/luxe/debug/StatsDebugView.hx" module="luxe.debug.StatsDebugView"><a>
	<visible_count><x path="Int"/></visible_count>
	<static_batched_count><x path="Int"/></static_batched_count>
	<group_count><x path="Int"/></group_count>
	<geometry_count><x path="Int"/></geometry_count>
	<dynamic_batched_count><x path="Int"/></dynamic_batched_count>
	<draw_calls><x path="Int"/></draw_calls>
	<batchers><x path="Int"/></batchers>
</a></typedef>
	<class path="luxe.debug.StatsDebugView" params="" file="/Users/sven/dev/luxe/luxe/luxe/debug/StatsDebugView.hx">
		<extends path="luxe.debug.DebugView"/>
		<_last_render_stats public="1"><t path="luxe.debug.RenderStats"/></_last_render_stats>
		<_render_stats public="1"><t path="luxe.debug.RenderStats"/></_render_stats>
		<debug_draw_call_count public="1"><x path="Int"/></debug_draw_call_count>
		<debug_geometry_count public="1"><x path="Int"/></debug_geometry_count>
		<render_stats_text public="1"><c path="luxe.Text"/></render_stats_text>
		<resource_stats_text public="1"><c path="luxe.Text"/></resource_stats_text>
		<resource_list_text public="1"><c path="luxe.Text"/></resource_list_text>
		<get_resource_stats_string public="1" set="method" line="58"><f a=""><c path="String"/></f></get_resource_stats_string>
		<get_render_stats_string public="1" set="method" line="62"><f a=""><c path="String"/></f></get_render_stats_string>
		<create public="1" set="method" line="73" override="1"><f a=""><x path="Void"/></f></create>
		<refresh public="1" set="method" line="119" override="1"><f a=""><x path="Void"/></f></refresh>
		<process public="1" set="method" line="151" override="1"><f a=""><x path="Void"/></f></process>
		<onkeydown public="1" set="method" line="181" override="1"><f a="e">
	<t path="luxe.KeyEvent"/>
	<x path="Void"/>
</f></onkeydown>
		<show public="1" set="method" line="187" override="1"><f a=""><x path="Void"/></f></show>
		<hide public="1" set="method" line="195" override="1"><f a=""><x path="Void"/></f></hide>
		<refresh_render_stats public="1" set="method" line="202"><f a=""><x path="Void"/></f></refresh_render_stats>
		<hide_debug public="1"><x path="Bool"/></hide_debug>
		<toggle_debug_stats public="1" set="method" line="220"><f a=""><x path="Void"/></f></toggle_debug_stats>
		<update_render_stats public="1" set="method" line="224"><f a=""><x path="Void"/></f></update_render_stats>
		<new public="1" set="method" line="30"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="luxe.debug.TraceDebugView" params="" file="/Users/sven/dev/luxe/luxe/luxe/debug/TraceDebugView.hx">
		<extends path="luxe.debug.DebugView"/>
		<logged public="1"><c path="Array"><c path="String"/></c></logged>
		<lines public="1"><c path="luxe.Text"/></lines>
		<max_lines public="1"><x path="Int"/></max_lines>
		<on_trace public="1" set="method" line="24"><f a="v:?inf" v=":null">
	<d/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></on_trace>
		<create public="1" set="method" line="28" override="1"><f a=""><x path="Void"/></f></create>
		<add_line public="1" set="method" line="49"><f a="_t">
	<c path="String"/>
	<x path="Void"/>
</f></add_line>
		<_last_logged_length><x path="Int"/></_last_logged_length>
		<refresh_lines set="method" line="66"><f a=""><x path="Void"/></f></refresh_lines>
		<refresh public="1" set="method" line="99" override="1"><f a=""><x path="Void"/></f></refresh>
		<process public="1" set="method" line="103" override="1"><f a=""><x path="Void"/></f></process>
		<show public="1" set="method" line="107" override="1"><f a=""><x path="Void"/></f></show>
		<hide public="1" set="method" line="112" override="1"><f a=""><x path="Void"/></f></hide>
		<new public="1" set="method" line="10"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="luxe.defaults.TinyBox" params="" file="/Users/sven/dev/luxe/luxe/luxe/defaults/TinyUI.hx" module="luxe.defaults.TinyUI">
		<data public="1" set="method" line="5" static="1"><f a=""><c path="String"/></f></data>
		<meta><m n=":noCompletion"/></meta>
	</class>
	<class path="luxe.defaults.TinyButton" params="" file="/Users/sven/dev/luxe/luxe/luxe/defaults/TinyUI.hx" module="luxe.defaults.TinyUI">
		<data public="1" set="method" line="17" static="1"><f a=""><c path="String"/></f></data>
		<meta><m n=":noCompletion"/></meta>
	</class>
	<typedef path="luxe.options.ProjectionOptions" params="" file="/Users/sven/dev/luxe/luxe/luxe/options/CameraOptions.hx" module="luxe.options.CameraOptions"><a>
	<y2>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</y2>
	<y1>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</y1>
	<x2>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</x2>
	<x1>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</x1>
	<viewport>
		<c path="phoenix.Rectangle"/>
		<meta><m n=":optional"/></meta>
	</viewport>
	<near>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</near>
	<fov>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</fov>
	<far>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</far>
	<aspect>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</aspect>
</a></typedef>
	<typedef path="luxe.options.CameraOptions" params="" file="/Users/sven/dev/luxe/luxe/luxe/options/CameraOptions.hx"><a>
	<y2>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</y2>
	<y1>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</y1>
	<x2>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</x2>
	<x1>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</x1>
	<viewport>
		<c path="phoenix.Rectangle"/>
		<meta><m n=":optional"/></meta>
	</viewport>
	<projection>
		<e path="phoenix.ProjectionType"/>
		<meta><m n=":optional"/></meta>
	</projection>
	<near>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</near>
	<name>
		<c path="String"/>
		<meta><m n=":optional"/></meta>
	</name>
	<fov>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</fov>
	<far>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</far>
	<aspect>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</aspect>
</a></typedef>
	<typedef path="luxe.options.LuxeCameraOptions" params="" file="/Users/sven/dev/luxe/luxe/luxe/options/CameraOptions.hx" module="luxe.options.CameraOptions"><a>
	<y2>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</y2>
	<y1>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</y1>
	<x2>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</x2>
	<x1>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</x1>
	<viewport>
		<c path="phoenix.Rectangle"/>
		<meta><m n=":optional"/></meta>
	</viewport>
	<view>
		<c path="phoenix.Camera"/>
		<meta><m n=":optional"/></meta>
	</view>
	<projection>
		<e path="phoenix.ProjectionType"/>
		<meta><m n=":optional"/></meta>
	</projection>
	<no_scene>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</no_scene>
	<near>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</near>
	<name>
		<c path="String"/>
		<meta><m n=":optional"/></meta>
	</name>
	<fov>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</fov>
	<far>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</far>
	<aspect>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</aspect>
</a></typedef>
	<typedef path="luxe.options.ColorOptions" params="" file="/Users/sven/dev/luxe/luxe/luxe/options/ColorOptions.hx"><a>
	<v>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</v>
	<s>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</s>
	<r>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</r>
	<l>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</l>
	<h>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</h>
	<g>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</g>
	<b>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</b>
	<a>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</a>
</a></typedef>
	<typedef path="luxe.options.ComponentOptions" params="T" file="/Users/sven/dev/luxe/luxe/luxe/options/ComponentOptions.hx"><a><init_with>
	<c path="luxe.options.ComponentOptions.T"/>
	<meta><m n=":optional"/></meta>
</init_with></a></typedef>
	<typedef path="luxe.options.EntityOptions" params="T" file="/Users/sven/dev/luxe/luxe/luxe/options/EntityOptions.hx"><a>
	<scene>
		<c path="luxe.Scene"/>
		<meta><m n=":optional"/></meta>
	</scene>
	<scale>
		<t path="luxe.Vector"/>
		<meta><m n=":optional"/></meta>
	</scale>
	<pos>
		<t path="luxe.Vector"/>
		<meta><m n=":optional"/></meta>
	</pos>
	<parent>
		<c path="luxe.Entity"/>
		<meta><m n=":optional"/></meta>
	</parent>
	<no_scene>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</no_scene>
	<name>
		<c path="String"/>
		<meta><m n=":optional"/></meta>
	</name>
	<init_with>
		<c path="luxe.options.EntityOptions.T"/>
		<meta><m n=":optional"/></meta>
	</init_with>
</a></typedef>
	<typedef path="luxe.options.NineSliceOptions" params="T" file="/Users/sven/dev/luxe/luxe/luxe/options/NineSliceOptions.hx"><a>
	<visible>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</visible>
	<uv>
		<t path="luxe.Rectangle"/>
		<meta><m n=":optional"/></meta>
	</uv>
	<top>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</top>
	<texture>
		<c path="phoenix.Texture"/>
		<meta><m n=":optional"/></meta>
	</texture>
	<source_y>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</source_y>
	<source_x>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</source_x>
	<source_w>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</source_w>
	<source_h>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</source_h>
	<size>
		<t path="luxe.Vector"/>
		<meta><m n=":optional"/></meta>
	</size>
	<shader>
		<c path="phoenix.Shader"/>
		<meta><m n=":optional"/></meta>
	</shader>
	<serialize>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</serialize>
	<scene>
		<c path="luxe.Scene"/>
		<meta><m n=":optional"/></meta>
	</scene>
	<scale>
		<t path="luxe.Vector"/>
		<meta><m n=":optional"/></meta>
	</scale>
	<rotation_z>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</rotation_z>
	<right>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</right>
	<pos>
		<t path="luxe.Vector"/>
		<meta><m n=":optional"/></meta>
	</pos>
	<parent>
		<c path="luxe.Entity"/>
		<meta><m n=":optional"/></meta>
	</parent>
	<origin>
		<t path="luxe.Vector"/>
		<meta><m n=":optional"/></meta>
	</origin>
	<no_scene>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</no_scene>
	<no_geometry>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</no_geometry>
	<no_batcher_add>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</no_batcher_add>
	<name>
		<c path="String"/>
		<meta><m n=":optional"/></meta>
	</name>
	<left>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</left>
	<init_with>
		<c path="luxe.options.NineSliceOptions.T"/>
		<meta><m n=":optional"/></meta>
	</init_with>
	<group>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</group>
	<geometry>
		<c path="phoenix.geometry.Geometry"/>
		<meta><m n=":optional"/></meta>
	</geometry>
	<flipy>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</flipy>
	<flipx>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</flipx>
	<depth>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</depth>
	<color>
		<t path="luxe.Color"/>
		<meta><m n=":optional"/></meta>
	</color>
	<centered>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</centered>
	<bottom>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</bottom>
	<batcher>
		<c path="phoenix.Batcher"/>
		<meta><m n=":optional"/></meta>
	</batcher>
</a></typedef>
	<typedef path="luxe.options.SpriteOptions" params="T" file="/Users/sven/dev/luxe/luxe/luxe/options/SpriteOptions.hx"><a>
	<visible>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</visible>
	<uv>
		<t path="luxe.Rectangle"/>
		<meta><m n=":optional"/></meta>
	</uv>
	<texture>
		<c path="phoenix.Texture"/>
		<meta><m n=":optional"/></meta>
	</texture>
	<size>
		<t path="luxe.Vector"/>
		<meta><m n=":optional"/></meta>
	</size>
	<shader>
		<c path="phoenix.Shader"/>
		<meta><m n=":optional"/></meta>
	</shader>
	<serialize>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</serialize>
	<scene>
		<c path="luxe.Scene"/>
		<meta><m n=":optional"/></meta>
	</scene>
	<scale>
		<t path="luxe.Vector"/>
		<meta><m n=":optional"/></meta>
	</scale>
	<rotation_z>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</rotation_z>
	<pos>
		<t path="luxe.Vector"/>
		<meta><m n=":optional"/></meta>
	</pos>
	<parent>
		<c path="luxe.Entity"/>
		<meta><m n=":optional"/></meta>
	</parent>
	<origin>
		<t path="luxe.Vector"/>
		<meta><m n=":optional"/></meta>
	</origin>
	<no_scene>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</no_scene>
	<no_geometry>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</no_geometry>
	<no_batcher_add>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</no_batcher_add>
	<name>
		<c path="String"/>
		<meta><m n=":optional"/></meta>
	</name>
	<init_with>
		<c path="luxe.options.SpriteOptions.T"/>
		<meta><m n=":optional"/></meta>
	</init_with>
	<group>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</group>
	<geometry>
		<c path="phoenix.geometry.Geometry"/>
		<meta><m n=":optional"/></meta>
	</geometry>
	<flipy>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</flipy>
	<flipx>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</flipx>
	<depth>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</depth>
	<color>
		<t path="luxe.Color"/>
		<meta><m n=":optional"/></meta>
	</color>
	<centered>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</centered>
	<batcher>
		<c path="phoenix.Batcher"/>
		<meta><m n=":optional"/></meta>
	</batcher>
</a></typedef>
	<typedef path="luxe.options.VisualOptions" params="T" file="/Users/sven/dev/luxe/luxe/luxe/options/VisualOptions.hx"><a>
	<visible>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</visible>
	<texture>
		<c path="phoenix.Texture"/>
		<meta><m n=":optional"/></meta>
	</texture>
	<size>
		<t path="luxe.Vector"/>
		<meta><m n=":optional"/></meta>
	</size>
	<shader>
		<c path="phoenix.Shader"/>
		<meta><m n=":optional"/></meta>
	</shader>
	<serialize>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</serialize>
	<scene>
		<c path="luxe.Scene"/>
		<meta><m n=":optional"/></meta>
	</scene>
	<scale>
		<t path="luxe.Vector"/>
		<meta><m n=":optional"/></meta>
	</scale>
	<rotation_z>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</rotation_z>
	<pos>
		<t path="luxe.Vector"/>
		<meta><m n=":optional"/></meta>
	</pos>
	<parent>
		<c path="luxe.Entity"/>
		<meta><m n=":optional"/></meta>
	</parent>
	<origin>
		<t path="luxe.Vector"/>
		<meta><m n=":optional"/></meta>
	</origin>
	<no_scene>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</no_scene>
	<no_geometry>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</no_geometry>
	<no_batcher_add>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</no_batcher_add>
	<name>
		<c path="String"/>
		<meta><m n=":optional"/></meta>
	</name>
	<init_with>
		<c path="luxe.options.VisualOptions.T"/>
		<meta><m n=":optional"/></meta>
	</init_with>
	<group>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</group>
	<geometry>
		<c path="phoenix.geometry.Geometry"/>
		<meta><m n=":optional"/></meta>
	</geometry>
	<depth>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</depth>
	<color>
		<t path="luxe.Color"/>
		<meta><m n=":optional"/></meta>
	</color>
	<batcher>
		<c path="phoenix.Batcher"/>
		<meta><m n=":optional"/></meta>
	</batcher>
</a></typedef>
	<class path="luxe.structural.BalancedBinarySearchTree" params="K:T" file="/Users/sven/dev/luxe/luxe/luxe/structural/BalancedBinarySearchTree.hx">
		<RED public="1" get="inline" set="null" line="6" static="1">
			<x path="Bool"/>
			<meta>
				<m n=":noCompletion"/>
				<m n=":noCompletion"/>
			</meta>
		</RED>
		<BLACK public="1" get="inline" set="null" line="7" static="1">
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</BLACK>
		<root public="1"><c path="luxe.structural.BalancedBinarySearchTreeNode">
	<c path="luxe.structural.BalancedBinarySearchTree.K"/>
	<c path="luxe.structural.BalancedBinarySearchTree.T"/>
</c></root>
		<compare public="1"><f a=":">
	<c path="luxe.structural.BalancedBinarySearchTree.K"/>
	<c path="luxe.structural.BalancedBinarySearchTree.K"/>
	<x path="Int"/>
</f></compare>
		<toString public="1" set="method" line="16"><f a=""><c path="String"/></f></toString>
		<empty public="1" set="method" line="21"><f a=""><x path="Bool"/></f></empty>
		<size public="1" set="method" line="25"><f a=""><x path="Int"/></f></size>
		<height public="1" set="method" line="29"><f a=""><x path="Int"/></f></height>
		<_height set="method" line="33"><f a="_node">
	<c path="luxe.structural.BalancedBinarySearchTreeNode">
		<c path="luxe.structural.BalancedBinarySearchTree.K"/>
		<c path="luxe.structural.BalancedBinarySearchTree.T"/>
	</c>
	<x path="Int"/>
</f></_height>
		<_size set="method" line="40"><f a="_node">
	<c path="luxe.structural.BalancedBinarySearchTreeNode">
		<c path="luxe.structural.BalancedBinarySearchTree.K"/>
		<c path="luxe.structural.BalancedBinarySearchTree.T"/>
	</c>
	<x path="Int"/>
</f></_size>
		<insert public="1" set="method" line="49"><f a="_key:_value">
	<c path="luxe.structural.BalancedBinarySearchTree.K"/>
	<c path="luxe.structural.BalancedBinarySearchTree.T"/>
	<x path="Void"/>
</f></insert>
		<_insert set="method" line="54"><f a="_node:_key:_value">
	<c path="luxe.structural.BalancedBinarySearchTreeNode">
		<c path="luxe.structural.BalancedBinarySearchTree.K"/>
		<c path="luxe.structural.BalancedBinarySearchTree.T"/>
	</c>
	<c path="luxe.structural.BalancedBinarySearchTree.K"/>
	<c path="luxe.structural.BalancedBinarySearchTree.T"/>
	<c path="luxe.structural.BalancedBinarySearchTreeNode">
		<c path="luxe.structural.BalancedBinarySearchTree.K"/>
		<c path="luxe.structural.BalancedBinarySearchTree.T"/>
	</c>
</f></_insert>
		<contains public="1" set="method" line="89"><f a="_key">
	<c path="luxe.structural.BalancedBinarySearchTree.K"/>
	<x path="Bool"/>
</f></contains>
		<find public="1" set="method" line="95"><f a="_key">
	<c path="luxe.structural.BalancedBinarySearchTree.K"/>
	<c path="luxe.structural.BalancedBinarySearchTree.T"/>
</f></find>
		<_find set="method" line="99"><f a="_node:_key">
	<c path="luxe.structural.BalancedBinarySearchTreeNode">
		<c path="luxe.structural.BalancedBinarySearchTree.K"/>
		<c path="luxe.structural.BalancedBinarySearchTree.T"/>
	</c>
	<c path="luxe.structural.BalancedBinarySearchTree.K"/>
	<c path="luxe.structural.BalancedBinarySearchTree.T"/>
</f></_find>
		<rank public="1" set="method" line="119"><f a="_key">
	<c path="luxe.structural.BalancedBinarySearchTree.K"/>
	<x path="Int"/>
</f></rank>
		<_rank set="method" line="123"><f a="_key:_node">
	<c path="luxe.structural.BalancedBinarySearchTree.K"/>
	<c path="luxe.structural.BalancedBinarySearchTreeNode">
		<c path="luxe.structural.BalancedBinarySearchTree.K"/>
		<c path="luxe.structural.BalancedBinarySearchTree.T"/>
	</c>
	<x path="Int"/>
</f></_rank>
		<select public="1" set="method" line="138"><f a="_rank">
	<x path="Int"/>
	<c path="luxe.structural.BalancedBinarySearchTree.K"/>
</f></select>
		<_select set="method" line="142"><f a="_node:_rank">
	<c path="luxe.structural.BalancedBinarySearchTreeNode">
		<c path="luxe.structural.BalancedBinarySearchTree.K"/>
		<c path="luxe.structural.BalancedBinarySearchTree.T"/>
	</c>
	<x path="Int"/>
	<c path="luxe.structural.BalancedBinarySearchTreeNode">
		<c path="luxe.structural.BalancedBinarySearchTree.K"/>
		<c path="luxe.structural.BalancedBinarySearchTree.T"/>
	</c>
</f></_select>
		<min public="1" set="method" line="159"><f a=""><c path="luxe.structural.BalancedBinarySearchTree.K"/></f></min>
		<_min set="method" line="163"><f a="_node">
	<c path="luxe.structural.BalancedBinarySearchTreeNode">
		<c path="luxe.structural.BalancedBinarySearchTree.K"/>
		<c path="luxe.structural.BalancedBinarySearchTree.T"/>
	</c>
	<c path="luxe.structural.BalancedBinarySearchTreeNode">
		<c path="luxe.structural.BalancedBinarySearchTree.K"/>
		<c path="luxe.structural.BalancedBinarySearchTree.T"/>
	</c>
</f></_min>
		<max public="1" set="method" line="168"><f a=""><c path="luxe.structural.BalancedBinarySearchTree.K"/></f></max>
		<_max set="method" line="172"><f a="_node">
	<c path="luxe.structural.BalancedBinarySearchTreeNode">
		<c path="luxe.structural.BalancedBinarySearchTree.K"/>
		<c path="luxe.structural.BalancedBinarySearchTree.T"/>
	</c>
	<c path="luxe.structural.BalancedBinarySearchTreeNode">
		<c path="luxe.structural.BalancedBinarySearchTree.K"/>
		<c path="luxe.structural.BalancedBinarySearchTree.T"/>
	</c>
</f></_max>
		<floor public="1" set="method" line="180"><f a="_key">
	<c path="luxe.structural.BalancedBinarySearchTree.K"/>
	<t path="Null"><c path="luxe.structural.BalancedBinarySearchTree.K"/></t>
</f></floor>
		<_floor set="method" line="189"><f a="_node:_key">
	<c path="luxe.structural.BalancedBinarySearchTreeNode">
		<c path="luxe.structural.BalancedBinarySearchTree.K"/>
		<c path="luxe.structural.BalancedBinarySearchTree.T"/>
	</c>
	<c path="luxe.structural.BalancedBinarySearchTree.K"/>
	<c path="luxe.structural.BalancedBinarySearchTreeNode">
		<c path="luxe.structural.BalancedBinarySearchTree.K"/>
		<c path="luxe.structural.BalancedBinarySearchTree.T"/>
	</c>
</f></_floor>
		<ceil public="1" set="method" line="207"><f a="_key">
	<c path="luxe.structural.BalancedBinarySearchTree.K"/>
	<t path="Null"><c path="luxe.structural.BalancedBinarySearchTree.K"/></t>
</f></ceil>
		<_ceil set="method" line="216"><f a="_node:_key">
	<c path="luxe.structural.BalancedBinarySearchTreeNode">
		<c path="luxe.structural.BalancedBinarySearchTree.K"/>
		<c path="luxe.structural.BalancedBinarySearchTree.T"/>
	</c>
	<c path="luxe.structural.BalancedBinarySearchTree.K"/>
	<c path="luxe.structural.BalancedBinarySearchTreeNode">
		<c path="luxe.structural.BalancedBinarySearchTree.K"/>
		<c path="luxe.structural.BalancedBinarySearchTree.T"/>
	</c>
</f></_ceil>
		<deleteMin public="1" set="method" line="235"><f a=""><x path="Void"/></f></deleteMin>
		<_deleteMin set="method" line="249"><f a="_node">
	<c path="luxe.structural.BalancedBinarySearchTreeNode">
		<c path="luxe.structural.BalancedBinarySearchTree.K"/>
		<c path="luxe.structural.BalancedBinarySearchTree.T"/>
	</c>
	<c path="luxe.structural.BalancedBinarySearchTreeNode">
		<c path="luxe.structural.BalancedBinarySearchTree.K"/>
		<c path="luxe.structural.BalancedBinarySearchTree.T"/>
	</c>
</f></_deleteMin>
		<deleteMax public="1" set="method" line="265"><f a=""><x path="Void"/></f></deleteMax>
		<_deleteMax set="method" line="280"><f a="_node">
	<c path="luxe.structural.BalancedBinarySearchTreeNode">
		<c path="luxe.structural.BalancedBinarySearchTree.K"/>
		<c path="luxe.structural.BalancedBinarySearchTree.T"/>
	</c>
	<c path="luxe.structural.BalancedBinarySearchTreeNode">
		<c path="luxe.structural.BalancedBinarySearchTree.K"/>
		<c path="luxe.structural.BalancedBinarySearchTree.T"/>
	</c>
</f></_deleteMax>
		<remove public="1" set="method" line="300"><f a="_key">
	<c path="luxe.structural.BalancedBinarySearchTree.K"/>
	<x path="Bool"/>
</f></remove>
		<_remove set="method" line="323"><f a="_node:_key">
	<c path="luxe.structural.BalancedBinarySearchTreeNode">
		<c path="luxe.structural.BalancedBinarySearchTree.K"/>
		<c path="luxe.structural.BalancedBinarySearchTree.T"/>
	</c>
	<c path="luxe.structural.BalancedBinarySearchTree.K"/>
	<c path="luxe.structural.BalancedBinarySearchTreeNode">
		<c path="luxe.structural.BalancedBinarySearchTree.K"/>
		<c path="luxe.structural.BalancedBinarySearchTree.T"/>
	</c>
</f></_remove>
		<is_red set="method" line="371"><f a="_node">
	<c path="luxe.structural.BalancedBinarySearchTreeNode">
		<c path="luxe.structural.BalancedBinarySearchTree.K"/>
		<c path="luxe.structural.BalancedBinarySearchTree.T"/>
	</c>
	<x path="Bool"/>
</f></is_red>
		<rotate_left public="1" set="method" line="376">
			<f a="_node">
				<c path="luxe.structural.BalancedBinarySearchTreeNode">
					<c path="luxe.structural.BalancedBinarySearchTree.K"/>
					<c path="luxe.structural.BalancedBinarySearchTree.T"/>
				</c>
				<c path="luxe.structural.BalancedBinarySearchTreeNode">
					<c path="luxe.structural.BalancedBinarySearchTree.K"/>
					<c path="luxe.structural.BalancedBinarySearchTree.T"/>
				</c>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</rotate_left>
		<rotate_right public="1" set="method" line="387">
			<f a="_node">
				<c path="luxe.structural.BalancedBinarySearchTreeNode">
					<c path="luxe.structural.BalancedBinarySearchTree.K"/>
					<c path="luxe.structural.BalancedBinarySearchTree.T"/>
				</c>
				<c path="luxe.structural.BalancedBinarySearchTreeNode">
					<c path="luxe.structural.BalancedBinarySearchTree.K"/>
					<c path="luxe.structural.BalancedBinarySearchTree.T"/>
				</c>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</rotate_right>
		<flip_colors public="1" set="method" line="398">
			<f a="_node">
				<c path="luxe.structural.BalancedBinarySearchTreeNode">
					<c path="luxe.structural.BalancedBinarySearchTree.K"/>
					<c path="luxe.structural.BalancedBinarySearchTree.T"/>
				</c>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</flip_colors>
		<move_red_left set="method" line="406"><f a="_node">
	<c path="luxe.structural.BalancedBinarySearchTreeNode">
		<c path="luxe.structural.BalancedBinarySearchTree.K"/>
		<c path="luxe.structural.BalancedBinarySearchTree.T"/>
	</c>
	<c path="luxe.structural.BalancedBinarySearchTreeNode">
		<c path="luxe.structural.BalancedBinarySearchTree.K"/>
		<c path="luxe.structural.BalancedBinarySearchTree.T"/>
	</c>
</f></move_red_left>
		<move_red_right set="method" line="420"><f a="_node">
	<c path="luxe.structural.BalancedBinarySearchTreeNode">
		<c path="luxe.structural.BalancedBinarySearchTree.K"/>
		<c path="luxe.structural.BalancedBinarySearchTree.T"/>
	</c>
	<c path="luxe.structural.BalancedBinarySearchTreeNode">
		<c path="luxe.structural.BalancedBinarySearchTree.K"/>
		<c path="luxe.structural.BalancedBinarySearchTree.T"/>
	</c>
</f></move_red_right>
		<balance set="method" line="432"><f a="_node">
	<c path="luxe.structural.BalancedBinarySearchTreeNode">
		<c path="luxe.structural.BalancedBinarySearchTree.K"/>
		<c path="luxe.structural.BalancedBinarySearchTree.T"/>
	</c>
	<c path="luxe.structural.BalancedBinarySearchTreeNode">
		<c path="luxe.structural.BalancedBinarySearchTree.K"/>
		<c path="luxe.structural.BalancedBinarySearchTree.T"/>
	</c>
</f></balance>
		<toArray public="1" set="method" line="452"><f a=""><c path="Array"><c path="luxe.structural.BalancedBinarySearchTree.T"/></c></f></toArray>
		<keys public="1" set="method" line="462"><f a=""><c path="Array"><c path="luxe.structural.BalancedBinarySearchTree.K"/></c></f></keys>
		<iterator public="1" set="method" line="472"><f a=""><t path="Iterator"><c path="luxe.structural.BalancedBinarySearchTree.T"/></t></f></iterator>
		<traverse public="1" set="method" line="478"><f a="_node:_traverse_method:_process_node_function">
	<c path="luxe.structural.BalancedBinarySearchTreeNode">
		<c path="luxe.structural.BalancedBinarySearchTree.K"/>
		<c path="luxe.structural.BalancedBinarySearchTree.T"/>
	</c>
	<e path="luxe.structural.BalancedBinarySearchTraverseMethod"/>
	<f a="">
		<c path="luxe.structural.BalancedBinarySearchTreeNode">
			<c path="luxe.structural.BalancedBinarySearchTree.K"/>
			<c path="luxe.structural.BalancedBinarySearchTree.T"/>
		</c>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></traverse>
		<new public="1" set="method" line="12"><f a="compare_function">
	<f a=":">
		<c path="luxe.structural.BalancedBinarySearchTree.K"/>
		<c path="luxe.structural.BalancedBinarySearchTree.K"/>
		<x path="Int"/>
	</f>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.structural.BalancedBinarySearchTreeNode" params="K:T" file="/Users/sven/dev/luxe/luxe/luxe/structural/BalancedBinarySearchTree.hx" module="luxe.structural.BalancedBinarySearchTree">
		<left public="1"><c path="luxe.structural.BalancedBinarySearchTreeNode">
	<c path="luxe.structural.BalancedBinarySearchTreeNode.K"/>
	<c path="luxe.structural.BalancedBinarySearchTreeNode.T"/>
</c></left>
		<right public="1"><c path="luxe.structural.BalancedBinarySearchTreeNode">
	<c path="luxe.structural.BalancedBinarySearchTreeNode.K"/>
	<c path="luxe.structural.BalancedBinarySearchTreeNode.T"/>
</c></right>
		<nodecount public="1"><x path="Int"/></nodecount>
		<color public="1"><x path="Bool"/></color>
		<key public="1"><c path="luxe.structural.BalancedBinarySearchTreeNode.K"/></key>
		<value public="1"><c path="luxe.structural.BalancedBinarySearchTreeNode.T"/></value>
		<new public="1" set="method" line="526"><f a="_key:_value:_nodecount:_color">
	<c path="luxe.structural.BalancedBinarySearchTreeNode.K"/>
	<c path="luxe.structural.BalancedBinarySearchTreeNode.T"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="luxe.structural.BalancedBinarySearchTraverseMethod" params="" file="/Users/sven/dev/luxe/luxe/luxe/structural/BalancedBinarySearchTree.hx" module="luxe.structural.BalancedBinarySearchTree">
		<PreOrder/>
		<InOrder/>
		<PostOrder/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="luxe.structural.BinarySearchTree" params="K:T" file="/Users/sven/dev/luxe/luxe/luxe/structural/BinarySearchTree.hx">
		<root public="1"><c path="luxe.structural.BinarySearchTreeNode">
	<c path="luxe.structural.BinarySearchTree.K"/>
	<c path="luxe.structural.BinarySearchTree.T"/>
</c></root>
		<compare public="1"><f a=":">
	<c path="luxe.structural.BinarySearchTree.K"/>
	<c path="luxe.structural.BinarySearchTree.K"/>
	<x path="Int"/>
</f></compare>
		<toString public="1" set="method" line="12"><f a=""><c path="String"/></f></toString>
		<size public="1" set="method" line="18"><f a=""><x path="Int"/></f></size>
		<_size set="method" line="23"><f a="_node">
	<c path="luxe.structural.BinarySearchTreeNode">
		<c path="luxe.structural.BinarySearchTree.K"/>
		<c path="luxe.structural.BinarySearchTree.T"/>
	</c>
	<x path="Int"/>
</f></_size>
		<insert public="1" set="method" line="32"><f a="_key:_value">
	<c path="luxe.structural.BinarySearchTree.K"/>
	<c path="luxe.structural.BinarySearchTree.T"/>
	<x path="Void"/>
</f></insert>
		<_insert set="method" line="36"><f a="_node:_key:_value">
	<c path="luxe.structural.BinarySearchTreeNode">
		<c path="luxe.structural.BinarySearchTree.K"/>
		<c path="luxe.structural.BinarySearchTree.T"/>
	</c>
	<c path="luxe.structural.BinarySearchTree.K"/>
	<c path="luxe.structural.BinarySearchTree.T"/>
	<c path="luxe.structural.BinarySearchTreeNode">
		<c path="luxe.structural.BinarySearchTree.K"/>
		<c path="luxe.structural.BinarySearchTree.T"/>
	</c>
</f></_insert>
		<contains public="1" set="method" line="59"><f a="_key">
	<c path="luxe.structural.BinarySearchTree.K"/>
	<x path="Bool"/>
</f></contains>
		<find public="1" set="method" line="64"><f a="_key">
	<c path="luxe.structural.BinarySearchTree.K"/>
	<c path="luxe.structural.BinarySearchTree.T"/>
</f></find>
		<_find set="method" line="68"><f a="_node:_key">
	<c path="luxe.structural.BinarySearchTreeNode">
		<c path="luxe.structural.BinarySearchTree.K"/>
		<c path="luxe.structural.BinarySearchTree.T"/>
	</c>
	<c path="luxe.structural.BinarySearchTree.K"/>
	<c path="luxe.structural.BinarySearchTree.T"/>
</f></_find>
		<rank public="1" set="method" line="87"><f a="_key">
	<c path="luxe.structural.BinarySearchTree.K"/>
	<x path="Int"/>
</f></rank>
		<_rank set="method" line="91"><f a="_key:_node">
	<c path="luxe.structural.BinarySearchTree.K"/>
	<c path="luxe.structural.BinarySearchTreeNode">
		<c path="luxe.structural.BinarySearchTree.K"/>
		<c path="luxe.structural.BinarySearchTree.T"/>
	</c>
	<x path="Int"/>
</f></_rank>
		<select public="1" set="method" line="106"><f a="_rank">
	<x path="Int"/>
	<c path="luxe.structural.BinarySearchTree.K"/>
</f></select>
		<_select set="method" line="110"><f a="_node:_rank">
	<c path="luxe.structural.BinarySearchTreeNode">
		<c path="luxe.structural.BinarySearchTree.K"/>
		<c path="luxe.structural.BinarySearchTree.T"/>
	</c>
	<x path="Int"/>
	<c path="luxe.structural.BinarySearchTreeNode">
		<c path="luxe.structural.BinarySearchTree.K"/>
		<c path="luxe.structural.BinarySearchTree.T"/>
	</c>
</f></_select>
		<min public="1" set="method" line="127"><f a=""><c path="luxe.structural.BinarySearchTree.K"/></f></min>
		<_min set="method" line="131"><f a="_node">
	<c path="luxe.structural.BinarySearchTreeNode">
		<c path="luxe.structural.BinarySearchTree.K"/>
		<c path="luxe.structural.BinarySearchTree.T"/>
	</c>
	<c path="luxe.structural.BinarySearchTreeNode">
		<c path="luxe.structural.BinarySearchTree.K"/>
		<c path="luxe.structural.BinarySearchTree.T"/>
	</c>
</f></_min>
		<max public="1" set="method" line="136"><f a=""><c path="luxe.structural.BinarySearchTree.K"/></f></max>
		<_max set="method" line="140"><f a="_node">
	<c path="luxe.structural.BinarySearchTreeNode">
		<c path="luxe.structural.BinarySearchTree.K"/>
		<c path="luxe.structural.BinarySearchTree.T"/>
	</c>
	<c path="luxe.structural.BinarySearchTreeNode">
		<c path="luxe.structural.BinarySearchTree.K"/>
		<c path="luxe.structural.BinarySearchTree.T"/>
	</c>
</f></_max>
		<floor public="1" set="method" line="148"><f a="_key">
	<c path="luxe.structural.BinarySearchTree.K"/>
	<t path="Null"><c path="luxe.structural.BinarySearchTree.K"/></t>
</f></floor>
		<_floor set="method" line="157"><f a="_node:_key">
	<c path="luxe.structural.BinarySearchTreeNode">
		<c path="luxe.structural.BinarySearchTree.K"/>
		<c path="luxe.structural.BinarySearchTree.T"/>
	</c>
	<c path="luxe.structural.BinarySearchTree.K"/>
	<c path="luxe.structural.BinarySearchTreeNode">
		<c path="luxe.structural.BinarySearchTree.K"/>
		<c path="luxe.structural.BinarySearchTree.T"/>
	</c>
</f></_floor>
		<ceil public="1" set="method" line="175"><f a="_key">
	<c path="luxe.structural.BinarySearchTree.K"/>
	<t path="Null"><c path="luxe.structural.BinarySearchTree.K"/></t>
</f></ceil>
		<_ceil set="method" line="184"><f a="_node:_key">
	<c path="luxe.structural.BinarySearchTreeNode">
		<c path="luxe.structural.BinarySearchTree.K"/>
		<c path="luxe.structural.BinarySearchTree.T"/>
	</c>
	<c path="luxe.structural.BinarySearchTree.K"/>
	<c path="luxe.structural.BinarySearchTreeNode">
		<c path="luxe.structural.BinarySearchTree.K"/>
		<c path="luxe.structural.BinarySearchTree.T"/>
	</c>
</f></_ceil>
		<deleteMin public="1" set="method" line="203"><f a=""><x path="Void"/></f></deleteMin>
		<_deleteMin set="method" line="207"><f a="_node">
	<c path="luxe.structural.BinarySearchTreeNode">
		<c path="luxe.structural.BinarySearchTree.K"/>
		<c path="luxe.structural.BinarySearchTree.T"/>
	</c>
	<c path="luxe.structural.BinarySearchTreeNode">
		<c path="luxe.structural.BinarySearchTree.K"/>
		<c path="luxe.structural.BinarySearchTree.T"/>
	</c>
</f></_deleteMin>
		<deleteMax public="1" set="method" line="220"><f a=""><x path="Void"/></f></deleteMax>
		<_deleteMax set="method" line="224"><f a="_node">
	<c path="luxe.structural.BinarySearchTreeNode">
		<c path="luxe.structural.BinarySearchTree.K"/>
		<c path="luxe.structural.BinarySearchTree.T"/>
	</c>
	<c path="luxe.structural.BinarySearchTreeNode">
		<c path="luxe.structural.BinarySearchTree.K"/>
		<c path="luxe.structural.BinarySearchTree.T"/>
	</c>
</f></_deleteMax>
		<remove public="1" set="method" line="237"><f a="_key">
	<c path="luxe.structural.BinarySearchTree.K"/>
	<x path="Void"/>
</f></remove>
		<_remove set="method" line="241"><f a="_node:_key">
	<c path="luxe.structural.BinarySearchTreeNode">
		<c path="luxe.structural.BinarySearchTree.K"/>
		<c path="luxe.structural.BinarySearchTree.T"/>
	</c>
	<c path="luxe.structural.BinarySearchTree.K"/>
	<c path="luxe.structural.BinarySearchTreeNode">
		<c path="luxe.structural.BinarySearchTree.K"/>
		<c path="luxe.structural.BinarySearchTree.T"/>
	</c>
</f></_remove>
		<toArray public="1" set="method" line="276"><f a=""><c path="Array"><c path="luxe.structural.BinarySearchTree.T"/></c></f></toArray>
		<keys public="1" set="method" line="286"><f a=""><c path="Array"><c path="luxe.structural.BinarySearchTree.K"/></c></f></keys>
		<iterator public="1" set="method" line="296"><f a=""><t path="Iterator"><c path="luxe.structural.BinarySearchTree.T"/></t></f></iterator>
		<traverse public="1" set="method" line="302"><f a="_node:_traverse_method:_process_node_function">
	<c path="luxe.structural.BinarySearchTreeNode">
		<c path="luxe.structural.BinarySearchTree.K"/>
		<c path="luxe.structural.BinarySearchTree.T"/>
	</c>
	<e path="luxe.structural.BinarySearchTraverseMethod"/>
	<f a="">
		<c path="luxe.structural.BinarySearchTreeNode">
			<c path="luxe.structural.BinarySearchTree.K"/>
			<c path="luxe.structural.BinarySearchTree.T"/>
		</c>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></traverse>
		<new public="1" set="method" line="8"><f a="compare_function">
	<f a=":">
		<c path="luxe.structural.BinarySearchTree.K"/>
		<c path="luxe.structural.BinarySearchTree.K"/>
		<x path="Int"/>
	</f>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.structural.BinarySearchTreeNode" params="K:T" file="/Users/sven/dev/luxe/luxe/luxe/structural/BinarySearchTree.hx" module="luxe.structural.BinarySearchTree">
		<left public="1"><c path="luxe.structural.BinarySearchTreeNode">
	<c path="luxe.structural.BinarySearchTreeNode.K"/>
	<c path="luxe.structural.BinarySearchTreeNode.T"/>
</c></left>
		<right public="1"><c path="luxe.structural.BinarySearchTreeNode">
	<c path="luxe.structural.BinarySearchTreeNode.K"/>
	<c path="luxe.structural.BinarySearchTreeNode.T"/>
</c></right>
		<nodecount public="1"><x path="Int"/></nodecount>
		<key public="1"><c path="luxe.structural.BinarySearchTreeNode.K"/></key>
		<value public="1"><c path="luxe.structural.BinarySearchTreeNode.T"/></value>
		<new public="1" set="method" line="349"><f a="_key:_value:_nodecount">
	<c path="luxe.structural.BinarySearchTreeNode.K"/>
	<c path="luxe.structural.BinarySearchTreeNode.T"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="luxe.structural.BinarySearchTraverseMethod" params="" file="/Users/sven/dev/luxe/luxe/luxe/structural/BinarySearchTree.hx" module="luxe.structural.BinarySearchTree">
		<PreOrder/>
		<InOrder/>
		<PostOrder/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="luxe.tween.actuators.IGenericActuator" params="" file="/Users/sven/dev/luxe/luxe/luxe/tween/actuators/GenericActuator.hx" module="luxe.tween.actuators.GenericActuator" interface="1">
		<autoVisible public="1" set="method">
			<f a="?value">
				<x path="Bool"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Flash performs faster when objects are set to visible = false rather than only alpha = 0. autoVisible toggles automatically based on alpha values
     * @param   value       Whether autoVisible should be enabled (Default is true)
     * @return      The current actuator instance</haxe_doc>
		</autoVisible>
		<delay public="1" set="method">
			<f a="duration">
				<x path="Float"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Increases the delay before a tween is executed
     * @param   duration        The amount of seconds to delay
     * @return      The current actuator instance</haxe_doc>
		</delay>
		<ease public="1" set="method">
			<f a="easing">
				<c path="luxe.tween.easing.IEasing"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Sets the easing which is used when running the tween
     * @param   easing      An easing equation, like Elastic.easeIn or Quad.easeOut
     * @return      The current actuator instance</haxe_doc>
		</ease>
		<onComplete public="1" set="method">
			<f a="handler:?parameters">
				<d/>
				<c path="Array"><d/></c>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Defines a function which will be called when the tween finishes
     * @param   handler     The function you would like to be called
     * @param   parameters      Parameters you would like to pass to the handler function when it is called
     * @return      The current actuator instance</haxe_doc>
		</onComplete>
		<onRepeat public="1" set="method">
			<f a="handler:?parameters">
				<d/>
				<c path="Array"><d/></c>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Defines a function which will be called when the tween repeats
     * @param   handler     The function you would like to be called
     * @param   parameters      Parameters you would like to pass to the handler function when it is called
     * @return      The current actuator instance</haxe_doc>
		</onRepeat>
		<onUpdate public="1" set="method">
			<f a="handler:?parameters">
				<d/>
				<c path="Array"><d/></c>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Defines a function which will be called when the tween updates
     * @param   handler     The function you would like to be called
     * @param   parameters      Parameters you would like to pass to the handler function when it is called
     * @return      The current actuator instance</haxe_doc>
		</onUpdate>
		<reflect public="1" set="method">
			<f a="?value">
				<x path="Bool"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Automatically changes the reverse value when the tween repeats. Repeat must be enabled for this to have any effect
     * @param   value       Whether reflect should be enabled (Default is true)
     * @return      The current actuator instance</haxe_doc>
		</reflect>
		<repeat public="1" set="method">
			<f a="?times">
				<x path="Int"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Repeats the tween after it finishes
     * @param   times       The number of times you would like the tween to repeat, or -1 if you would like to repeat the tween indefinitely (Default is -1)
     * @return      The current actuator instance</haxe_doc>
		</repeat>
		<reverse public="1" set="method">
			<f a="?value">
				<x path="Bool"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Sets if the tween should be handled in reverse
     * @param   value       Whether the tween should be reversed (Default is true)
     * @return      The current actuator instance</haxe_doc>
		</reverse>
		<timescale public="1" set="method">
			<f a="?_value">
				<x path="Bool"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Specify whether this should be scaled by the global timescale
     * @param   _value      Whether or not it should be
     * @return      The current actuator instance</haxe_doc>
		</timescale>
		<smartRotation public="1" set="method">
			<f a="?value">
				<x path="Bool"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Enabling smartRotation can prevent undesired results when tweening rotation values
     * @param   value       Whether smart rotation should be enabled (Default is true)
     * @return      The current actuator instance</haxe_doc>
		</smartRotation>
		<snapping public="1" set="method">
			<f a="?value">
				<x path="Bool"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Snapping causes tween values to be rounded automatically
     * @param   value       Whether tween values should be rounded (Default is true)
     * @return      The current actuator instance</haxe_doc>
		</snapping>
		<meta><m n=":noCompletion"/></meta>
	</class>
	<class path="luxe.tween.actuators.GenericActuator" params="" file="/Users/sven/dev/luxe/luxe/luxe/tween/actuators/GenericActuator.hx">
		<implements path="luxe.tween.actuators.IGenericActuator"/>
		<duration public="1"><x path="Float"/></duration>
		<id public="1"><c path="String"/></id>
		<properties public="1"><d/></properties>
		<target public="1"><d/></target>
		<_autoVisible><x path="Bool"/></_autoVisible>
		<_delay><x path="Float"/></_delay>
		<_ease><c path="luxe.tween.easing.IEasing"/></_ease>
		<_onComplete><d/></_onComplete>
		<_onCompleteParams><c path="Array"><d/></c></_onCompleteParams>
		<_onRepeat><d/></_onRepeat>
		<_onRepeatParams><c path="Array"><d/></c></_onRepeatParams>
		<_onUpdate><d/></_onUpdate>
		<_onUpdateParams><c path="Array"><d/></c></_onUpdateParams>
		<_reflect><x path="Bool"/></_reflect>
		<_repeat><x path="Int"/></_repeat>
		<_reverse><x path="Bool"/></_reverse>
		<_smartRotation><x path="Bool"/></_smartRotation>
		<_snapping><x path="Bool"/></_snapping>
		<special><x path="Bool"/></special>
		<apply public="1" set="method" line="59"><f a=""><x path="Void"/></f></apply>
		<autoVisible public="1" set="method" line="83">
			<f a="?value" v="null">
				<x path="Bool"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* sometimes drawing performs faster when objects are set to visible = false rather than only alpha = 0. autoVisible toggles automatically based on alpha values
     * @param   value       Whether autoVisible should be enabled (Default is true)
     * @return      The current actuator instance</haxe_doc>
		</autoVisible>
		<change set="method" line="98"><f a=""><x path="Void"/></f></change>
		<complete set="method" line="118"><f a="?sendEvent" v="true">
	<x path="Bool"/>
	<x path="Void"/>
</f></complete>
		<delay public="1" set="method" line="151">
			<f a="duration">
				<x path="Float"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Increases the delay before a tween is executed
     * @param   duration        The amount of seconds to delay
     * @return      The current actuator instance</haxe_doc>
		</delay>
		<ease public="1" set="method" line="165">
			<f a="easing">
				<c path="luxe.tween.easing.IEasing"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Sets the easing which is used when running the tween
     * @param   easing      An easing equation, like Elastic.easeIn or Quad.easeOut
     * @return      The current actuator instance</haxe_doc>
		</ease>
		<move public="1" set="method" line="174"><f a=""><x path="Void"/></f></move>
		<timescaled public="1">
			<x path="Bool"/>
			<haxe_doc>* Specify whether this should be scaled by the global timescale
     * @param   _value      Whether or not it should be
     * @return      The current actuator instance</haxe_doc>
		</timescaled>
		<timescale public="1" set="method" line="188"><f a="?_value" v="true">
	<x path="Bool"/>
	<c path="luxe.tween.actuators.IGenericActuator"/>
</f></timescale>
		<onComplete public="1" set="method" line="199">
			<f a="handler:?parameters" v=":null">
				<d/>
				<c path="Array"><d/></c>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Defines a function which will be called when the tween finishes
     * @param   handler     The function you would like to be called
     * @param   parameters      Parameters you would like to pass to the handler function when it is called
     * @return      The current actuator instance</haxe_doc>
		</onComplete>
		<onRepeat public="1" set="method" line="230">
			<f a="handler:?parameters" v=":null">
				<d/>
				<c path="Array"><d/></c>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Defines a function which will be called when the tween repeats
     * @param   handler     The function you would like to be called
     * @param   parameters      Parameters you would like to pass to the handler function when it is called
     * @return      The current actuator instance</haxe_doc>
		</onRepeat>
		<onUpdate public="1" set="method" line="255">
			<f a="handler:?parameters" v=":null">
				<d/>
				<c path="Array"><d/></c>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Defines a function which will be called when the tween updates
     * @param   handler     The function you would like to be called
     * @param   parameters      Parameters you would like to pass to the handler function when it is called
     * @return      The current actuator instance</haxe_doc>
		</onUpdate>
		<pause public="1" set="method" line="274"><f a=""><x path="Void"/></f></pause>
		<reflect public="1" set="method" line="286">
			<f a="?value" v="null">
				<x path="Bool"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Automatically changes the reverse value when the tween repeats. Repeat must be enabled for this to have any effect
     * @param   value       Whether reflect should be enabled (Default is true)
     * @return      The current actuator instance</haxe_doc>
		</reflect>
		<repeat public="1" set="method" line="307">
			<f a="?times" v="null">
				<x path="Int"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Repeats the tween after it finishes
     * @param   times       The number of times you would like the tween to repeat, or -1 if you would like to repeat the tween indefinitely (Default is -1)
     * @return      The current actuator instance</haxe_doc>
		</repeat>
		<resume public="1" set="method" line="322"><f a=""><x path="Void"/></f></resume>
		<reverse public="1" set="method" line="334">
			<f a="?value" v="null">
				<x path="Bool"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Sets if the tween should be handled in reverse
     * @param   value       Whether the tween should be reversed (Default is true)
     * @return      The current actuator instance</haxe_doc>
		</reverse>
		<smartRotation public="1" set="method" line="355">
			<f a="?value" v="null">
				<x path="Bool"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Enabling smartRotation can prevent undesired results when tweening rotation values
     * @param   value       Whether smart rotation should be enabled (Default is true)
     * @return      The current actuator instance</haxe_doc>
		</smartRotation>
		<snapping public="1" set="method" line="376">
			<f a="?value" v="null">
				<x path="Bool"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Snapping causes tween values to be rounded automatically
     * @param   value       Whether tween values should be rounded (Default is true)
     * @return      The current actuator instance</haxe_doc>
		</snapping>
		<stop public="1" set="method" line="392"><f a="properties:complete:sendEvent">
	<d/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></stop>
		<new public="1" set="method" line="39"><f a="target:duration:properties">
	<d/>
	<x path="Float"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.tween.actuators.SimpleActuator" params="" file="/Users/sven/dev/luxe/luxe/luxe/tween/actuators/SimpleActuator.hx">
		<extends path="luxe.tween.actuators.GenericActuator"/>
		<actuators line="22" static="1"><c path="Array"><c path="luxe.tween.actuators.SimpleActuator"/></c></actuators>
		<actuatorsLength line="23" static="1"><x path="Int"/></actuatorsLength>
		<addedEvent line="24" static="1"><x path="Bool"/></addedEvent>
		<timer static="1"><c path="haxe.Timer"/></timer>
		<update_timer line="425" static="1"><x path="Float"/></update_timer>
		<current_time line="426" static="1"><x path="Float"/></current_time>
		<on_internal_update set="method" line="427" static="1"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></on_internal_update>
		<timeOffset><x path="Float"/></timeOffset>
		<active><x path="Bool"/></active>
		<cacheVisible><x path="Bool"/></cacheVisible>
		<detailsLength><x path="Int"/></detailsLength>
		<initialized><x path="Bool"/></initialized>
		<paused><x path="Bool"/></paused>
		<pauseTime><x path="Float"/></pauseTime>
		<propertyDetails><c path="Array"><c path="luxe.tween.actuators.PropertyDetails"/></c></propertyDetails>
		<sendChange><x path="Bool"/></sendChange>
		<setVisible><x path="Bool"/></setVisible>
		<startTime><x path="Float"/></startTime>
		<toggleVisible><x path="Bool"/></toggleVisible>
		<has_timescaled_starttime><x path="Bool"/></has_timescaled_starttime>
		<autoVisible public="1" set="method" line="70" override="1">
			<f a="?value" v="null">
				<x path="Bool"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</autoVisible>
		<delay public="1" set="method" line="100" override="1">
			<f a="duration">
				<x path="Float"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</delay>
		<initialize set="method" line="110"><f a=""><x path="Void"/></f></initialize>
		<move public="1" set="method" line="149" override="1"><f a=""><x path="Void"/></f></move>
		<onUpdate public="1" set="method" line="171" override="1">
			<f a="handler:?parameters" v=":null">
				<d/>
				<c path="Array"><d/></c>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</onUpdate>
		<pause public="1" set="method" line="182" override="1"><f a=""><x path="Void"/></f></pause>
		<resume public="1" set="method" line="191" override="1"><f a=""><x path="Void"/></f></resume>
		<setField get="inline" set="null" line="205"><f a="details:value">
	<c path="luxe.tween.actuators.PropertyDetails"/>
	<d/>
	<x path="Void"/>
</f></setField>
		<stop public="1" set="method" line="228" override="1"><f a="properties:complete:sendEvent">
	<d/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></stop>
		<update set="method" line="271"><f a="currentTime">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="42"><f a="target:duration:properties">
	<d/>
	<x path="Float"/>
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* @author Joshua Granick
 * @version 1.2</haxe_doc>
	</class>
	<class path="luxe.tween.easing.Quad" params="" file="/Users/sven/dev/luxe/luxe/luxe/tween/easing/Quad.hx">
		<easeIn public="1" get="accessor" set="null" static="1"><c path="luxe.tween.easing.IEasing"/></easeIn>
		<easeInOut public="1" get="accessor" set="null" static="1"><c path="luxe.tween.easing.IEasing"/></easeInOut>
		<easeOut public="1" get="accessor" set="null" static="1"><c path="luxe.tween.easing.IEasing"/></easeOut>
		<get_easeIn set="method" line="19" static="1"><f a=""><c path="luxe.tween.easing.IEasing"/></f></get_easeIn>
		<get_easeInOut set="method" line="26" static="1"><f a=""><c path="luxe.tween.easing.IEasing"/></f></get_easeInOut>
		<get_easeOut set="method" line="33" static="1"><f a=""><c path="luxe.tween.easing.IEasing"/></f></get_easeOut>
	</class>
	<class path="luxe.tween.easing.IEasing" params="" file="/Users/sven/dev/luxe/luxe/luxe/tween/easing/IEasing.hx" interface="1">
		<calculate public="1" set="method"><f a="k">
	<x path="Float"/>
	<x path="Float"/>
</f></calculate>
		<ease public="1" set="method"><f a="t:b:c:d">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></ease>
		<haxe_doc>* @author Joshua Granick
 * @author Philippe / http://philippe.elsass.me</haxe_doc>
		<meta><m n=":noCompletion"/></meta>
	</class>
	<class path="luxe.tween.easing.QuadEaseOut" params="" file="/Users/sven/dev/luxe/luxe/luxe/tween/easing/Quad.hx" module="luxe.tween.easing.Quad">
		<implements path="luxe.tween.easing.IEasing"/>
		<calculate public="1" set="method" line="113"><f a="k">
	<x path="Float"/>
	<x path="Float"/>
</f></calculate>
		<ease public="1" set="method" line="120"><f a="t:b:c:d">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></ease>
		<new public="1" set="method" line="106"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="luxe.tween.Actuate" params="" file="/Users/sven/dev/luxe/luxe/luxe/tween/Actuate.hx">
		<defaultActuator public="1" line="17" static="1"><x path="Class"><c path="luxe.tween.actuators.GenericActuator"/></x></defaultActuator>
		<defaultEase public="1" line="18" static="1"><c path="luxe.tween.easing.IEasing"/></defaultEase>
		<targetLibraries line="19" static="1"><t path="luxe.tween.ObjectHash"><c path="Array"><c path="luxe.tween.actuators.GenericActuator"/></c></t></targetLibraries>
		<apply public="1" set="method" line="30" static="1">
			<f a="target:properties:?customActuator" v="::null">
				<d/>
				<d/>
				<x path="Class"><c path="luxe.tween.actuators.GenericActuator"/></x>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc><![CDATA[* Copies properties from one object to another. Conflicting tweens are stopped automatically
     * @example     <code>Actuate.apply (MyClip, { alpha: 1 } );</code>
     * @param   target      The object to copy to
     * @param   properties      The object to copy from
     * @param   customActuator      A custom actuator to use instead of the default (Optional)
     * @return      The current actuator instance, which can be used to apply properties like onComplete or onUpdate handlers]]></haxe_doc>
		</apply>
		<getLibrary set="method" line="47" static="1"><f a="target">
	<d/>
	<c path="Array"><c path="luxe.tween.actuators.GenericActuator"/></c>
</f></getLibrary>
		<motionPath public="1" set="method" line="68" static="1">
			<f a="target:duration:properties:?overwrite" v=":::true">
				<d/>
				<x path="Float"/>
				<d/>
				<x path="Bool"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Creates a new MotionPath tween
     * @param   target      The object to tween
     * @param   duration        The length of the tween in seconds
     * @param   properties      An object containing a motion path for each property you wish to tween
     * @param   overwrite       Sets whether previous tweens for the same target and properties will be overwritten (Default is true)
     * @return      The current actuator instance, which can be used to apply properties like ease, delay, onComplete or onUpdate</haxe_doc>
		</motionPath>
		<pause public="1" set="method" line="80" static="1">
			<f a="target">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Pauses tweens for the specified target objects
     * @param   ... targets     The target objects which will have their tweens paused. Passing no value pauses tweens for all objects</haxe_doc>
		</pause>
		<pauseAll public="1" set="method" line="101" static="1"><f a=""><x path="Void"/></f></pauseAll>
		<reset public="1" set="method" line="119" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets Actuate by stopping and removing tweens for all objects</haxe_doc>
		</reset>
		<resume public="1" set="method" line="140" static="1">
			<f a="target">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Resumes paused tweens for the specified target objects
     * @param   ... targets     The target objects which will have their tweens resumed. Passing no value resumes tweens for all objects</haxe_doc>
		</resume>
		<resumeAll public="1" set="method" line="161" static="1"><f a=""><x path="Void"/></f></resumeAll>
		<stop public="1" set="method" line="183" static="1">
			<f a="target:?properties:?complete:?sendEvent" v=":null:false:true">
				<d/>
				<d/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Stops all tweens for an individual object
     * @param   target      The target object which will have its tweens stopped, or a generic actuator instance
     * @param   properties      A string, array or object which contains the properties you wish to stop, like "alpha", [ "x", "y" ] or { alpha: null }. Passing no value removes all tweens for the object (Optional)
     * @param   complete        If tweens should apply their final target values before stopping. Default is false (Optional) 
     * @param   sendEvent   If a complete() event should be dispatched for the specified target. Default is true (Optional)</haxe_doc>
		</stop>
		<timer public="1" set="method" line="235" static="1">
			<f a="duration:?customActuator" v=":null">
				<x path="Float"/>
				<x path="Class"><c path="luxe.tween.actuators.GenericActuator"/></x>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc><![CDATA[* Creates a tween-based timer, which is useful for synchronizing function calls with other animations
     * @example     <code>Actuate.timer (1).onComplete (trace, [ "Timer is now complete" ]);</code>
     * @param   duration        The length of the timer in seconds
     * @param   customActuator      A custom actuator to use instead of the default (Optional)
     * @return      The current actuator instance, which can be used to apply properties like onComplete or to gain a reference to the target timer object]]></haxe_doc>
		</timer>
		<tween public="1" set="method" line="252" static="1">
			<f a="target:duration:properties:?overwrite:?customActuator" v=":::true:null">
				<d/>
				<x path="Float"/>
				<d/>
				<x path="Bool"/>
				<x path="Class"><c path="luxe.tween.actuators.GenericActuator"/></x>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new tween
     * @example     <code>Actuate.tween (MyClip, 1, { alpha: 1 } ).onComplete (trace, [ "MyClip is now visible" ]);</code>
     * @param   target      The object to tween
     * @param   duration        The length of the tween in seconds
     * @param   properties      The end values to tween the target to
     * @param   overwrite           Sets whether previous tweens for the same target and properties will be overwritten (Default is true)
     * @param   customActuator      A custom actuator to use instead of the default (Optional)
     * @return      The current actuator instance, which can be used to apply properties like ease, delay, onComplete or onUpdate]]></haxe_doc>
		</tween>
		<unload public="1" set="method" line="309" static="1"><f a="actuator">
	<c path="luxe.tween.actuators.GenericActuator"/>
	<x path="Void"/>
</f></unload>
		<update public="1" set="method" line="338" static="1">
			<f a="target:duration:?start:?end:?overwrite" v="::null:null:true">
				<d/>
				<x path="Float"/>
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
				<x path="Bool"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new tween that updates a method rather than setting the properties of an object
     * @example     <code>Actuate.update (trace, 1, ["Value: ", 0], ["", 1]).onComplete (trace, [ "Finished tracing values between 0 and 1" ]);</code>
     * @param   target      The method to update        
     * @param   duration        The length of the tween in seconds
     * @param   start       The starting parameters of the method call. You may use both numeric and non-numeric values
     * @param   end     The ending parameters of the method call. You may use both numeric and non-numeric values, but the signature should match the start parameters
     * @param   overwrite       Sets whether previous tweens for the same target and properties will be overwritten (Default is true)
     * @return      The current actuator instance, which can be used to apply properties like ease, delay, onComplete or onUpdate]]></haxe_doc>
		</update>
	</class>
	<class path="luxe.tween._Actuate.TweenTimer" params="" file="/Users/sven/dev/luxe/luxe/luxe/tween/Actuate.hx" private="1" module="luxe.tween.Actuate">
		<progress public="1"><x path="Float"/></progress>
		<new public="1" set="method" line="357"><f a="progress">
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":noCompletion"/></meta>
	</class>
	<typedef path="luxe.tween.ObjectHash" params="T" file="/Users/sven/dev/luxe/luxe/luxe/tween/Actuate.hx" module="luxe.tween.Actuate"><c path="haxe.ds.ObjectMap">
	<d/>
	<c path="luxe.tween.ObjectHash.T"/>
</c></typedef>
	<class path="luxe.tween.MotionPath" params="" file="/Users/sven/dev/luxe/luxe/luxe/tween/MotionPath.hx">
		<x public="1" get="accessor" set="null"><c path="luxe.tween.IComponentPath"/></x>
		<y public="1" get="accessor" set="null"><c path="luxe.tween.IComponentPath"/></y>
		<_x><c path="luxe.tween.ComponentPath"/></_x>
		<_y><c path="luxe.tween.ComponentPath"/></_y>
		<bezier public="1" set="method" line="34">
			<f a="x:y:controlX:controlY:?strength" v="::::1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="luxe.tween.MotionPath"/>
			</f>
			<haxe_doc>* Adds a bezier curve to the current motion path
     * @param   x  The x position of the end point for the curve
     * @param   y  The y position of the end point for the curve
     * @param   controlX  The x position of the control point for the curve, which affects the angle and midpoint
     * @param   controlX  The x position of the control point for the curve, which affects the angle and midpoint
     * @param   strength  The degree of emphasis that should be placed on this segment. If a motion path contains multiple segments with the same strength, they all receive equal emphasis (Default is 1)
     * @return  The current motion path instance</haxe_doc>
		</bezier>
		<line public="1" set="method" line="51">
			<f a="x:y:?strength" v="::1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="luxe.tween.MotionPath"/>
			</f>
			<haxe_doc>* Adds a line to the current motion path
     * @param   x  The x position of the end point for the line
     * @param   x  The y position of the end point for the line
     * @param   strength  The degree of emphasis that should be placed on this segment . If a motion path contains multiple segments with the same strength, they all receive equal emphasis (Default is 1)
     * @return  The current motion path instance</haxe_doc>
		</line>
		<get_x set="method" line="68"><f a=""><c path="luxe.tween.IComponentPath"/></f></get_x>
		<get_y set="method" line="75"><f a=""><c path="luxe.tween.IComponentPath"/></f></get_y>
		<new public="1" set="method" line="17"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* @author Joshua Granick</haxe_doc>
	</class>
	<class path="luxe.tween.IComponentPath" params="" file="/Users/sven/dev/luxe/luxe/luxe/tween/MotionPath.hx" module="luxe.tween.MotionPath" interface="1">
		<end public="1" get="null" set="null"><x path="Float"/></end>
		<start public="1"><x path="Float"/></start>
		<calculate public="1" set="method"><f a="k">
	<x path="Float"/>
	<x path="Float"/>
</f></calculate>
		<meta><m n=":noCompletion"/></meta>
	</class>
	<class path="luxe.tween.ComponentPath" params="" file="/Users/sven/dev/luxe/luxe/luxe/tween/MotionPath.hx" module="luxe.tween.MotionPath">
		<implements path="luxe.tween.IComponentPath"/>
		<start public="1"><x path="Float"/></start>
		<end public="1" get="accessor" set="null"><x path="Float"/></end>
		<paths><c path="Array"><c path="luxe.tween.BezierPath"/></c></paths>
		<totalStrength><x path="Float"/></totalStrength>
		<addPath public="1" set="method" line="104"><f a="path">
	<c path="luxe.tween.BezierPath"/>
	<x path="Void"/>
</f></addPath>
		<calculate public="1" set="method" line="112"><f a="k">
	<x path="Float"/>
	<x path="Float"/>
</f></calculate>
		<get_end set="method" line="151"><f a=""><x path="Float"/></f></get_end>
		<new public="1" set="method" line="95"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="luxe.tween.BezierPath" params="" file="/Users/sven/dev/luxe/luxe/luxe/tween/MotionPath.hx" module="luxe.tween.MotionPath">
		<control public="1"><x path="Float"/></control>
		<end public="1"><x path="Float"/></end>
		<strength public="1"><x path="Float"/></strength>
		<calculate public="1" set="method" line="201"><f a="start:k">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></calculate>
		<new public="1" set="method" line="192"><f a="end:control:strength">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.tween.LinearPath" params="" file="/Users/sven/dev/luxe/luxe/luxe/tween/MotionPath.hx" module="luxe.tween.MotionPath">
		<extends path="luxe.tween.BezierPath"/>
		<calculate public="1" set="method" line="221" override="1"><f a="start:k">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></calculate>
		<new public="1" set="method" line="214"><f a="end:strength">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.tween.actuators.MethodActuator" params="" file="/Users/sven/dev/luxe/luxe/luxe/tween/actuators/MethodActuator.hx">
		<extends path="luxe.tween.actuators.SimpleActuator"/>
		<currentParameters><c path="Array"><d/></c></currentParameters>
		<tweenProperties><d/></tweenProperties>
		<apply public="1" set="method" line="43" override="1"><f a=""><x path="Void"/></f></apply>
		<complete set="method" line="58" override="1"><f a="?sendEvent" v="true">
	<x path="Bool"/>
	<x path="Void"/>
</f></complete>
		<initialize set="method" line="81" override="1"><f a=""><x path="Void"/></f></initialize>
		<update set="method" line="109" override="1"><f a="currentTime">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="15"><f a="target:duration:properties">
	<d/>
	<x path="Float"/>
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* @author Joshua Granick
 * @version 1.2</haxe_doc>
	</class>
	<class path="luxe.tween.actuators.MotionPathActuator" params="" file="/Users/sven/dev/luxe/luxe/luxe/tween/actuators/MotionPathActuator.hx">
		<extends path="luxe.tween.actuators.SimpleActuator"/>
		<apply public="1" set="method" line="20" override="1"><f a=""><x path="Void"/></f></apply>
		<initialize set="method" line="39" override="1"><f a=""><x path="Void"/></f></initialize>
		<update set="method" line="77" override="1"><f a="currentTime">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="13"><f a="target:duration:properties">
	<d/>
	<x path="Float"/>
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* @author Joshua Granick</haxe_doc>
	</class>
	<class path="luxe.tween.actuators.PropertyDetails" params="" file="/Users/sven/dev/luxe/luxe/luxe/tween/actuators/PropertyDetails.hx">
		<change public="1"><x path="Float"/></change>
		<isField public="1"><x path="Bool"/></isField>
		<propertyName public="1"><c path="String"/></propertyName>
		<start public="1"><x path="Float"/></start>
		<target public="1"><d/></target>
		<new public="1" set="method" line="19"><f a="target:propertyName:start:change:?isField" v="::::true">
	<d/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.tween.actuators.PropertyPathDetails" params="" file="/Users/sven/dev/luxe/luxe/luxe/tween/actuators/MotionPathActuator.hx" module="luxe.tween.actuators.MotionPathActuator">
		<extends path="luxe.tween.actuators.PropertyDetails"/>
		<path public="1"><c path="luxe.tween.IComponentPath"/></path>
		<new public="1" set="method" line="224"><f a="target:propertyName:path:?isField" v=":::true">
	<d/>
	<c path="String"/>
	<c path="luxe.tween.IComponentPath"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.tween.easing.QuadEaseIn" params="" file="/Users/sven/dev/luxe/luxe/luxe/tween/easing/Quad.hx" module="luxe.tween.easing.Quad">
		<implements path="luxe.tween.easing.IEasing"/>
		<calculate public="1" set="method" line="53"><f a="k">
	<x path="Float"/>
	<x path="Float"/>
</f></calculate>
		<ease public="1" set="method" line="60"><f a="t:b:c:d">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></ease>
		<new public="1" set="method" line="46"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="luxe.tween.easing.QuadEaseInOut" params="" file="/Users/sven/dev/luxe/luxe/luxe/tween/easing/Quad.hx" module="luxe.tween.easing.Quad">
		<implements path="luxe.tween.easing.IEasing"/>
		<calculate public="1" set="method" line="80"><f a="k">
	<x path="Float"/>
	<x path="Float"/>
</f></calculate>
		<ease public="1" set="method" line="90"><f a="t:b:c:d">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></ease>
		<new public="1" set="method" line="73"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="luxe.utils.Base64" params="" file="/Users/sven/dev/luxe/luxe/luxe/utils/Base64.hx">
		<BASE_64_ENCODINGS get="inline" set="null" line="13" static="1"><c path="String"/></BASE_64_ENCODINGS>
		<BASE_64_PADDING get="inline" set="null" line="14" static="1"><c path="String"/></BASE_64_PADDING>
		<decode public="1" set="method" line="17" static="1"><f a="_string">
	<c path="String"/>
	<c path="String"/>
</f></decode>
		<encode public="1" set="method" line="28" static="1"><f a="_string">
	<c path="String"/>
	<c path="String"/>
</f></encode>
		<encodeBytesData public="1" set="method" line="34" static="1"><f a="bytesData">
	<t path="haxe.io.BytesData"/>
	<c path="String"/>
</f></encodeBytesData>
		<decodeBytesData public="1" set="method" line="54" static="1"><f a="base64">
	<c path="String"/>
	<t path="haxe.io.BytesData"/>
</f></decodeBytesData>
	</class>
	<class path="luxe.utils.GeometryUtils" params="" file="/Users/sven/dev/luxe/luxe/luxe/utils/GeometryUtils.hx">
		<luxe public="1">
			<c path="luxe.Core"/>
			<meta><m n=":noCompletion"/></meta>
		</luxe>
		<segments_for_smooth_circle public="1" set="method" line="19"><f a="_radius:?_smooth" v=":6">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></segments_for_smooth_circle>
		<random_point_in_unit_circle public="1" set="method" line="23"><f a=""><t path="luxe.Vector"/></f></random_point_in_unit_circle>
		<point_in_polygon public="1" set="method" line="33"><f a="_point:_offset:_verts">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
	<c path="Array"><t path="luxe.Vector"/></c>
	<x path="Bool"/>
</f></point_in_polygon>
		<intersect_ray_plane public="1" set="method" line="57"><f a="_ray_start:_ray_dir:_plane_normal:_plane_point">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></intersect_ray_plane>
		<new public="1" set="method" line="13">
			<f a="_luxe">
				<c path="luxe.Core"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</new>
	</class>
	<class path="luxe.utils.JSON" params="" file="/Users/sven/dev/luxe/luxe/luxe/utils/JSON.hx">
		<encode public="1" get="inline" set="null" line="51" static="1">
			<f a="o">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>* Encodes a object into a JSON string.
	 *
	 * @param o The object to create a JSON string for
	 * @return the JSON string representing o</haxe_doc>
		</encode>
		<decode public="1" get="inline" set="null" line="61" static="1">
			<f a="s:?strict" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<d/>
			</f>
			<haxe_doc>* Decodes a JSON string into a native object.
	 * 
	 * @param s The JSON string representing the object
	 * @return A native object as specified by s</haxe_doc>
		</decode>
		<stringify public="1" get="inline" set="null" line="71" static="1">
			<f a="o">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>* Encodes a object into a JSON string.
	 *
	 * @param o The object to create a JSON string for
	 * @return the JSON string representing o</haxe_doc>
		</stringify>
		<parse public="1" get="inline" set="null" line="81" static="1">
			<f a="s:?strict" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<d/>
			</f>
			<haxe_doc>* Decodes a JSON string into a native object.
	 * 
	 * @param s The JSON string representing the object
	 * @return A native object as specified by s</haxe_doc>
		</parse>
	</class>
	<class path="luxe.utils.Maths" params="" file="/Users/sven/dev/luxe/luxe/luxe/utils/Maths.hx">
		<DEG2RAD public="1" line="7" static="1"><x path="Float"/></DEG2RAD>
		<RAD2DEG public="1" line="8" static="1"><x path="Float"/></RAD2DEG>
		<fixed public="1" set="method" line="10" static="1"><f a="value:precision">
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
</f></fixed>
		<clamp public="1" set="method" line="17" static="1"><f a="value:a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></clamp>
		<clamp_bottom public="1" set="method" line="21" static="1"><f a="value:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></clamp_bottom>
		<within_range public="1" set="method" line="25" static="1"><f a="value:start_range:end_range">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></within_range>
		<wrap_angle public="1" set="method" line="29" static="1"><f a="degrees:lower:upper">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></wrap_angle>
		<nearest_power_of_two public="1" set="method" line="39" static="1"><f a="_value">
	<x path="Int"/>
	<x path="Int"/>
</f></nearest_power_of_two>
		<map_linear public="1" set="method" line="53" static="1"><f a="value:a1:a2:b1:b2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></map_linear>
		<smoothstep public="1" set="method" line="57" static="1"><f a="x:min:max">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></smoothstep>
		<smootherstep public="1" set="method" line="73" static="1"><f a="x:min:max">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></smootherstep>
		<random16 public="1" set="method" line="89" static="1"><f a=""><x path="Float"/></f></random16>
		<random_int public="1" set="method" line="93" static="1"><f a="low:high">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></random_int>
		<random_float public="1" set="method" line="97" static="1"><f a="low:high">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></random_float>
		<random_float_spread public="1" set="method" line="101" static="1"><f a="range">
	<x path="Float"/>
	<x path="Float"/>
</f></random_float_spread>
		<sign public="1" set="method" line="105" static="1"><f a="x">
	<x path="Float"/>
	<x path="Int"/>
</f></sign>
		<degToRad public="1" set="method" line="109" static="1"><f a="deg">
	<x path="Float"/>
	<x path="Float"/>
</f></degToRad>
		<radToDeg public="1" set="method" line="113" static="1"><f a="rad">
	<x path="Float"/>
	<x path="Float"/>
</f></radToDeg>
	</class>
	<class path="luxe.utils._UUID.Rule30" params="" file="/Users/sven/dev/luxe/luxe/luxe/utils/UUID.hx" private="1" module="luxe.utils.UUID">
		<createWithLength public="1" set="method" line="124" static="1"><f a="length">
	<x path="Int"/>
	<c path="luxe.utils._UUID.Rule30"/>
</f></createWithLength>
		<cells><c path="String"/></cells>
		<cellsLength><x path="Int"/></cellsLength>
		<getBits public="1" set="method" line="155"><f a="length">
	<x path="Int"/>
	<x path="Int"/>
</f></getBits>
		<getBit set="method" line="167"><f a=""><x path="Int"/></f></getBit>
		<new set="method" line="139"><f a="cells">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":noCompletion"/></meta>
	</class>
	<class path="luxe.utils.UUID" params="" file="/Users/sven/dev/luxe/luxe/luxe/utils/UUID.hx">
		<rule30 line="33" static="1"><c path="luxe.utils._UUID.Rule30"/></rule30>
		<hexChars line="34" static="1"><c path="String"/></hexChars>
		<generate_undashed public="1" set="method" line="39" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Generate a Universal Unique Identifier string.
        For example: B859AA4C0A96CA94F7F82DBECD24205F</haxe_doc>
		</generate_undashed>
		<get public="1" set="method" line="69" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Generate a Universal Unique Identifier string, with dashes according to the spec.
        For example: BD5FB953-0BD3-D6B4-82AB-E642B7036246</haxe_doc>
		</get>
		<hex set="method" line="101" static="1"><f a="sbuf:n">
	<c path="StringBuf"/>
	<x path="Int"/>
	<x path="Void"/>
</f></hex>
	</class>
	<class path="luxe.utils.Utils" params="" file="/Users/sven/dev/luxe/luxe/luxe/utils/Utils.hx">
		<geometry public="1"><c path="luxe.utils.GeometryUtils"/></geometry>
		<luxe public="1">
			<c path="luxe.Core"/>
			<meta><m n=":noCompletion"/></meta>
		</luxe>
		<_byte_levels><c path="Array"><c path="String"/></c></_byte_levels>
		<uniqueid public="1" set="method" line="26"><f a=""><c path="String"/></f></uniqueid>
		<uuid public="1" set="method" line="30"><f a=""><c path="String"/></f></uuid>
		<base64_encode public="1" set="method" line="34"><f a="_string">
	<c path="String"/>
	<c path="String"/>
</f></base64_encode>
		<base64_decode public="1" set="method" line="38"><f a="_string">
	<c path="String"/>
	<c path="String"/>
</f></base64_decode>
		<stacktrace public="1" set="method" line="42"><f a="?_depth" v="100">
	<x path="Int"/>
	<c path="String"/>
</f></stacktrace>
		<find_assets_image_sequence public="1" set="method" line="68"><f a="_name:?_ext:?_start" v=":'.png':'1'">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></find_assets_image_sequence>
		<bytes_to_string public="1" set="method" line="111"><f a="bytes">
	<x path="Int"/>
	<c path="String"/>
</f></bytes_to_string>
		<arrayToBytes public="1" set="method" line="120"><f a="array">
	<c path="Array"><x path="Int"/></c>
	<c path="haxe.io.Bytes"/>
</f></arrayToBytes>
		<file_bytes_to_class public="1" set="method" line="130"><f a="_file:_outfile:?_string_length" v="::2048">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></file_bytes_to_class>
		<new public="1" set="method" line="15">
			<f a="_luxe">
				<c path="luxe.Core"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</new>
	</class>
	<enum path="luxe.utils.json.JSONTokenType" params="" file="/Users/sven/dev/luxe/luxe/luxe/utils/json/JSONDecoder.hx" module="luxe.utils.json.JSONDecoder">
		<tUNKNOWN/>
		<tCOMMA/>
		<tLEFT_BRACE/>
		<tRIGHT_BRACE/>
		<tLEFT_BRACKET/>
		<tRIGHT_BRACKET/>
		<tCOLON/>
		<tTRUE/>
		<tFALSE/>
		<tNULL/>
		<tSTRING/>
		<tNUMBER/>
		<tNAN/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="luxe.utils.json.JSONDecoder" params="" file="/Users/sven/dev/luxe/luxe/luxe/utils/json/JSONDecoder.hx">
		<strict><x path="Bool"/></strict>
		<value>
			<d/>
			<haxe_doc>The value that will get parsed from the JSON string</haxe_doc>
		</value>
		<tokenizer>
			<c path="luxe.utils.json.JSONTokenizer"/>
			<haxe_doc>The tokenizer designated to read the JSON string</haxe_doc>
		</tokenizer>
		<token>
			<c path="luxe.utils.json.JSONToken"/>
			<haxe_doc>The current token from the tokenizer</haxe_doc>
		</token>
		<getValue public="1" set="method" line="90">
			<f a=""><d/></f>
			<haxe_doc>* Gets the internal object that was created by parsing
     * the JSON string passed to the constructor.
     *
     * @return The internal object representation of the JSON
     *      string that was passed to the constructor</haxe_doc>
		</getValue>
		<nextToken set="method" line="98">
			<f a=""><c path="luxe.utils.json.JSONToken"/></f>
			<haxe_doc>* Returns the next token from the tokenzier reading
     * the JSON string</haxe_doc>
		</nextToken>
		<parseArray set="method" line="105">
			<f a=""><c path="Array"><d/></c></f>
			<haxe_doc>* Attempt to parse an array</haxe_doc>
		</parseArray>
		<parseObject set="method" line="160">
			<f a=""><d/></f>
			<haxe_doc>* Attempt to parse an object</haxe_doc>
		</parseObject>
		<parseValue set="method" line="235">
			<f a=""><d/></f>
			<haxe_doc>* Attempt to parse a value</haxe_doc>
		</parseValue>
		<new public="1" set="method" line="74">
			<f a="s:strict">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructs a new JSONDecoder to parse a JSON string 
     * into a native object.
     *
     * @param s The JSON string to be converted into a native object</haxe_doc>
		</new>
		<meta><m n=":noCompletion"/></meta>
	</class>
	<class path="luxe.utils.json.JSONEncoder" params="" file="/Users/sven/dev/luxe/luxe/luxe/utils/json/JSONEncoder.hx">
		<jsonString>
			<c path="String"/>
			<haxe_doc>The string that is going to represent the object we're encoding</haxe_doc>
		</jsonString>
		<getString public="1" set="method" line="65">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Gets the JSON string from the encoder.
     *
     * @return The JSON string representation of the object
     *      that was passed to the constructor</haxe_doc>
		</getString>
		<debug public="1"><x path="Bool"/></debug>
		<_trace public="1" set="method" line="70"><f a="e">
	<c path="String"/>
	<x path="Void"/>
</f></_trace>
		<convertToString set="method" line="78">
			<f a="value">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>* Converts a value to it's JSON string equivalent.
     *
     * @param value The value to convert.  Could be any 
     *      type (object, number, array, etc)</haxe_doc>
		</convertToString>
		<mapHash set="method" line="126"><f a="value">
	<x path="Map">
		<c path="String"/>
		<d/>
	</x>
	<d/>
</f></mapHash>
		<escapeString set="method" line="140">
			<f a="str">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Escapes a string accoding to the JSON specification.
     *
     * @param str The string to be escaped
     * @return The string with escaped special characters
     *      according to the JSON specification</haxe_doc>
		</escapeString>
		<arrayToString set="method" line="225">
			<f a="a">
				<c path="Array"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Converts an array to it's JSON string equivalent
     *
     * @param a The array to convert
     * @return The JSON string representation of <code>a</code>]]></haxe_doc>
		</arrayToString>
		<objectToString set="method" line="268">
			<f a="o">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Converts an object to it's JSON string equivalent
     *
     * @param o The object to convert
     * @return The JSON string representation of <code>o</code>]]></haxe_doc>
		</objectToString>
		<instanceToString set="method" line="300">
			<f a="o:cls">
				<d/>
				<x path="Class"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Converts an instance object to it's JSON string equivalent
   *
   * @param o The instance object to convert
   * @param cls The class of instance object
   * @return The JSON string representation of <code>o</code>]]></haxe_doc>
		</instanceToString>
		<new public="1" set="method" line="55">
			<f a="value">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new JSONEncoder.
     *
     * @param o The object to encode as a JSON string</haxe_doc>
		</new>
		<meta><m n=":noCompletion"/></meta>
	</class>
	<class path="luxe.utils.json.JSONParseError" params="" file="/Users/sven/dev/luxe/luxe/luxe/utils/json/JSONParseError.hx">
		<_location>
			<x path="Int"/>
			<haxe_doc>The location in the string where the error occurred</haxe_doc>
		</_location>
		<_text>
			<c path="String"/>
			<haxe_doc>The string in which the parse error occurred</haxe_doc>
		</_text>
		<name><c path="String"/></name>
		<text public="1" get="accessor" set="null"><c path="String"/></text>
		<location public="1" get="accessor" set="null"><x path="Int"/></location>
		<message><c path="String"/></message>
		<get_location public="1" set="method" line="68">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Provides read-only access to the location variable.
     *
     * @return The location in the string where the error occurred</haxe_doc>
		</get_location>
		<get_text public="1" set="method" line="77">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Provides read-only access to the text variable.
     *
     * @return The string in which the error occurred</haxe_doc>
		</get_text>
		<toString public="1" set="method" line="81"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="55">
			<f a="?message:?location:?text" v="'':0:''">
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructs a new JSONParseError.
     *
     * @param message The error message that occured during parsing</haxe_doc>
		</new>
		<meta><m n=":noCompletion"/></meta>
	</class>
	<class path="luxe.utils.json.JSONToken" params="" file="/Users/sven/dev/luxe/luxe/luxe/utils/json/JSONToken.hx">
		<type public="1">
			<e path="luxe.utils.json.JSONTokenType"/>
			<haxe_doc>type of the token</haxe_doc>
		</type>
		<value public="1">
			<d/>
			<haxe_doc>value of the token</haxe_doc>
		</value>
		<new public="1" set="method" line="54">
			<f a="?type:?value" v="null:null">
				<e path="luxe.utils.json.JSONTokenType"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new JSONToken with a specific token type and value.
   *
   * @param type The JSONTokenType of the token
   * @param value The value of the token</haxe_doc>
		</new>
		<meta><m n=":noCompletion"/></meta>
	</class>
	<class path="luxe.utils.json.JSONTokenizer" params="" file="/Users/sven/dev/luxe/luxe/luxe/utils/json/JSONTokenizer.hx">
		<obj>
			<d/>
			<haxe_doc>The object that will get parsed from the JSON string</haxe_doc>
		</obj>
		<jsonString>
			<c path="String"/>
			<haxe_doc>The JSON string to be parsed</haxe_doc>
		</jsonString>
		<loc>
			<x path="Int"/>
			<haxe_doc>The current parsing location in the JSON string</haxe_doc>
		</loc>
		<ch>
			<c path="String"/>
			<haxe_doc>The current character in the JSON string during parsing</haxe_doc>
		</ch>
		<strict><x path="Bool"/></strict>
		<getNextToken public="1" set="method" line="76">
			<f a=""><c path="luxe.utils.json.JSONToken"/></f>
			<haxe_doc>* Gets the next token in the input sting and advances
    * the character to the next character after the token</haxe_doc>
		</getNextToken>
		<readString set="method" line="198">
			<f a=""><c path="luxe.utils.json.JSONToken"/></f>
			<haxe_doc>* Attempts to read a string from the input string.  Places
     * the character location at the first character after the
     * string.  It is assumed that ch is " before this method is called.
     *
     * @return the JSONToken with the string value if a string could
     *      be read.  Throws an error otherwise.</haxe_doc>
		</readString>
		<hexValToInt get="inline" set="null" line="285"><f a="hexVal">
	<c path="String"/>
	<x path="Int"/>
</f></hexValToInt>
		<readNumber set="method" line="318">
			<f a=""><c path="luxe.utils.json.JSONToken"/></f>
			<haxe_doc>* Attempts to read a number from the input string.  Places
     * the character location at the first character after the
     * number.
     * 
     * @return The JSONToken with the number value if a number could
     *      be read.  Throws an error otherwise.</haxe_doc>
		</readNumber>
		<nextChar set="method" line="427">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Reads the next character in the input
     * string and advances the character location.
     *
     * @return The next character in the input string, or
     *      null if we've read past the end.</haxe_doc>
		</nextChar>
		<skipIgnored set="method" line="435">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Advances the character location past any
     * sort of white space and comments</haxe_doc>
		</skipIgnored>
		<skipComments set="method" line="451">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Skips comments in the input string, either
     * single-line or multi-line.  Advances the character
     * to the first position after the end of the comment.</haxe_doc>
		</skipComments>
		<skipWhite set="method" line="500">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Skip any whitespace in the input string and advances
     * the character to the first character after any possible
     * whitespace.</haxe_doc>
		</skipWhite>
		<isWhiteSpace set="method" line="515">
			<f a="ch">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Determines if a character is whitespace or not.
     *
     * @return True if the character passed in is a whitespace
     *  character</haxe_doc>
		</isWhiteSpace>
		<isDigit set="method" line="524">
			<f a="ch">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Determines if a character is a digit [0-9].
     *
     * @return True if the character passed in is a digit</haxe_doc>
		</isDigit>
		<isHexDigit set="method" line="537">
			<f a="ch">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Determines if a character is a digit [0-9].
     *
     * @return True if the character passed in is a digit</haxe_doc>
		</isHexDigit>
		<parseError public="1" set="method" line="552">
			<f a="message">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Raises a parsing error with a specified message, tacking
     * on the error location and the original string.
     *
     * @param message The message indicating why the error occurred</haxe_doc>
		</parseError>
		<new public="1" set="method" line="64">
			<f a="s:strict">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructs a new JSONDecoder to parse a JSON string 
     * into a native object.
     *
     * @param s The JSON string to be converted
     *      into a native object</haxe_doc>
		</new>
		<meta><m n=":noCompletion"/></meta>
	</class>
	<class path="phoenix.BatchState" params="" file="/Users/sven/dev/luxe/luxe/phoenix/BatchState.hx">
		<batcher public="1"><c path="phoenix.Batcher"/></batcher>
		<geom_state public="1"><c path="phoenix.geometry.GeometryState"/></geom_state>
		<last_geom_state public="1"><c path="phoenix.geometry.GeometryState"/></last_geom_state>
		<last_texture_id public="1"><d/></last_texture_id>
		<last_shader_id public="1"><d/></last_shader_id>
		<last_group public="1"><x path="Int"/></last_group>
		<is_clipping public="1"><x path="Bool"/></is_clipping>
		<clip_rect public="1"><c path="phoenix.Rectangle"/></clip_rect>
		<last_clip_rect public="1"><c path="phoenix.Rectangle"/></last_clip_rect>
		<log public="1"><x path="Bool"/></log>
		<activate public="1" set="method" line="32"><f a="batcher">
	<c path="phoenix.Batcher"/>
	<x path="Void"/>
</f></activate>
		<deactivate public="1" set="method" line="147"><f a="batcher">
	<c path="phoenix.Batcher"/>
	<x path="Void"/>
</f></deactivate>
		<update public="1" set="method" line="169"><f a="geom">
	<c path="phoenix.geometry.Geometry"/>
	<x path="Bool"/>
</f></update>
		<str public="1" set="method" line="184"><f a=""><x path="Void"/></f></str>
		<new public="1" set="method" line="26"><f a="_r">
	<c path="phoenix.Batcher"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="phoenix.PrimitiveType" params="" file="/Users/sven/dev/luxe/luxe/phoenix/Batcher.hx" module="phoenix.Batcher">
		<none/>
		<line_strip/>
		<line_loop/>
		<lines/>
		<triangle_strip/>
		<triangles/>
		<triangle_fan/>
		<points/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="phoenix.BlendMode" params="" file="/Users/sven/dev/luxe/luxe/phoenix/Batcher.hx" module="phoenix.Batcher">
		<zero/>
		<one/>
		<src_color/>
		<one_minus_src_color/>
		<src_alpha/>
		<one_minus_src_alpha/>
		<dst_alpha/>
		<one_minus_dst_alpha/>
		<dst_color/>
		<one_minus_dst_color/>
		<src_alpha_saturate/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="phoenix.BatchGroup" params="" file="/Users/sven/dev/luxe/luxe/phoenix/Batcher.hx" module="phoenix.Batcher">
		<pre_render public="1"><f a="">
	<c path="phoenix.Batcher"/>
	<x path="Void"/>
</f></pre_render>
		<post_render public="1"><f a="">
	<c path="phoenix.Batcher"/>
	<x path="Void"/>
</f></post_render>
		<new public="1" set="method" line="43"><f a="_pre:_post">
	<f a="">
		<c path="phoenix.Batcher"/>
		<x path="Void"/>
	</f>
	<f a="">
		<c path="phoenix.Batcher"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.Batcher" params="" file="/Users/sven/dev/luxe/luxe/phoenix/Batcher.hx">
		<id public="1"><c path="String"/></id>
		<layer public="1" set="accessor">
			<x path="Int"/>
			<meta><m n=":isVar"/></meta>
		</layer>
		<enabled public="1"><x path="Bool"/></enabled>
		<geometry public="1"><c path="luxe.structural.BalancedBinarySearchTree">
	<t path="phoenix.geometry.GeometryKey"/>
	<c path="phoenix.geometry.Geometry"/>
</c></geometry>
		<groups public="1"><x path="Map">
	<x path="Int"/>
	<c path="Array"><c path="phoenix.BatchGroup"/></c>
</x></groups>
		<tree_changed public="1"><x path="Bool"/></tree_changed>
		<vertlist public="1"><c path="lime.utils.Float32Array"/></vertlist>
		<tcoordlist public="1"><c path="lime.utils.Float32Array"/></tcoordlist>
		<colorlist public="1"><c path="lime.utils.Float32Array"/></colorlist>
		<normallist public="1"><c path="lime.utils.Float32Array"/></normallist>
		<static_vertlist public="1"><c path="lime.utils.Float32Array"/></static_vertlist>
		<static_tcoordlist public="1"><c path="lime.utils.Float32Array"/></static_tcoordlist>
		<static_colorlist public="1"><c path="lime.utils.Float32Array"/></static_colorlist>
		<static_normallist public="1"><c path="lime.utils.Float32Array"/></static_normallist>
		<verts public="1"><x path="Int"/></verts>
		<tcoords public="1"><x path="Int"/></tcoords>
		<colors public="1"><x path="Int"/></colors>
		<normals public="1"><x path="Int"/></normals>
		<static_verts public="1"><x path="Int"/></static_verts>
		<static_tcoords public="1"><x path="Int"/></static_tcoords>
		<static_colors public="1"><x path="Int"/></static_colors>
		<static_normals public="1"><x path="Int"/></static_normals>
		<buffer_count public="1"><x path="Int"/></buffer_count>
		<buffer_index public="1"><x path="Int"/></buffer_index>
		<vertexBuffers public="1"><c path="Array"><c path="lime.gl.GLBuffer"/></c></vertexBuffers>
		<tcoordBuffers public="1"><c path="Array"><c path="lime.gl.GLBuffer"/></c></tcoordBuffers>
		<vcolorBuffers public="1"><c path="Array"><c path="lime.gl.GLBuffer"/></c></vcolorBuffers>
		<normalBuffers public="1"><c path="Array"><c path="lime.gl.GLBuffer"/></c></normalBuffers>
		<projectionmatrix_attribute public="1"><t path="lime.gl.GLUniformLocation"/></projectionmatrix_attribute>
		<modelviewmatrix_attribute public="1"><t path="lime.gl.GLUniformLocation"/></modelviewmatrix_attribute>
		<vert_attribute public="1"><x path="Int"/></vert_attribute>
		<tcoord_attribute public="1"><x path="Int"/></tcoord_attribute>
		<color_attribute public="1"><x path="Int"/></color_attribute>
		<normal_attribute public="1"><x path="Int"/></normal_attribute>
		<tex0_attribute public="1"><t path="lime.gl.GLUniformLocation"/></tex0_attribute>
		<tex1_attribute public="1"><t path="lime.gl.GLUniformLocation"/></tex1_attribute>
		<tex2_attribute public="1"><t path="lime.gl.GLUniformLocation"/></tex2_attribute>
		<tex3_attribute public="1"><t path="lime.gl.GLUniformLocation"/></tex3_attribute>
		<tex4_attribute public="1"><t path="lime.gl.GLUniformLocation"/></tex4_attribute>
		<tex5_attribute public="1"><t path="lime.gl.GLUniformLocation"/></tex5_attribute>
		<tex6_attribute public="1"><t path="lime.gl.GLUniformLocation"/></tex6_attribute>
		<tex7_attribute public="1"><t path="lime.gl.GLUniformLocation"/></tex7_attribute>
		<renderer public="1"><c path="phoenix.Renderer"/></renderer>
		<view public="1"><c path="phoenix.Camera"/></view>
		<draw_calls public="1"><x path="Int"/></draw_calls>
		<dynamic_batched_count public="1"><x path="Int"/></dynamic_batched_count>
		<static_batched_count public="1"><x path="Int"/></static_batched_count>
		<visible_count public="1"><x path="Int"/></visible_count>
		<log public="1"><x path="Bool"/></log>
		<name public="1"><c path="String"/></name>
		<set_layer public="1" set="method" line="194"><f a="_layer">
	<x path="Int"/>
	<x path="Int"/>
</f></set_layer>
		<toString public="1" set="method" line="206"><f a=""><c path="String"/></f></toString>
		<compare public="1" set="method" line="211"><f a="other">
	<c path="phoenix.Batcher"/>
	<x path="Int"/>
</f></compare>
		<add_group public="1" set="method" line="220"><f a="_group:_pre_render:_post_render">
	<x path="Int"/>
	<f a="">
		<c path="phoenix.Batcher"/>
		<x path="Void"/>
	</f>
	<f a="">
		<c path="phoenix.Batcher"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></add_group>
		<blend_mode public="1" set="method" line="230"><f a="?_src_mode:?_dst_mode" v="null:null">
	<e path="phoenix.BlendMode"/>
	<e path="phoenix.BlendMode"/>
	<x path="Void"/>
</f></blend_mode>
		<_debug set="method" line="242"><f a="v">
	<c path="String"/>
	<x path="Void"/>
</f></_debug>
		<compare_rule_to_string public="1" set="method" line="248"><f a="r">
	<x path="Int"/>
	<c path="String"/>
</f></compare_rule_to_string>
		<compare_rule public="1" set="method" line="313"><f a="a:b">
	<t path="phoenix.geometry.GeometryKey"/>
	<t path="phoenix.geometry.GeometryKey"/>
	<x path="Int"/>
</f></compare_rule>
		<geometry_compare public="1" set="method" line="395"><f a="a:b">
	<t path="phoenix.geometry.GeometryKey"/>
	<t path="phoenix.geometry.GeometryKey"/>
	<x path="Int"/>
</f></geometry_compare>
		<list_geometry set="method" line="486"><f a=""><x path="Void"/></f></list_geometry>
		<add public="1" set="method" line="493"><f a="_geom:?_force_add" v=":false">
	<c path="phoenix.geometry.Geometry"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></add>
		<remove public="1" set="method" line="524"><f a="_geom:?_remove_batcher_from_geometry" v=":true">
	<c path="phoenix.geometry.Geometry"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></remove>
		<shader_activate public="1" set="method" line="547"><f a="_shader">
	<c path="phoenix.Shader"/>
	<x path="Void"/>
</f></shader_activate>
		<batch public="1" set="method" line="577"><f a="?persist_immediate" v="false">
	<x path="Bool"/>
	<x path="Void"/>
</f></batch>
		<draw public="1" set="method" line="697"><f a="?persist_immediate" v="false">
	<x path="Bool"/>
	<x path="Void"/>
</f></draw>
		<submit_static_geometry public="1" set="method" line="715"><f a="geom">
	<c path="phoenix.geometry.Geometry"/>
	<x path="Void"/>
</f></submit_static_geometry>
		<submit_current_vertex_list public="1" set="method" line="822"><f a="type">
	<e path="phoenix.PrimitiveType"/>
	<x path="Void"/>
</f></submit_current_vertex_list>
		<geometry_batch set="method" line="872"><f a="geom">
	<c path="phoenix.geometry.Geometry"/>
	<x path="Void"/>
</f></geometry_batch>
		<geometry_batch_static set="method" line="886"><f a="geom">
	<c path="phoenix.geometry.Geometry"/>
	<x path="Void"/>
</f></geometry_batch_static>
		<_enable_attributes set="method" line="902"><f a=""><x path="Void"/></f></_enable_attributes>
		<_disable_attributes set="method" line="910"><f a=""><x path="Void"/></f></_disable_attributes>
		<new public="1" set="method" line="122"><f a="_r:?_name" v=":''">
	<c path="phoenix.Renderer"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="phoenix.TextAlign" params="" file="/Users/sven/dev/luxe/luxe/phoenix/BitmapFont.hx" module="phoenix.BitmapFont">
		<left/>
		<right/>
		<center/>
		<top/>
		<bottom/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<typedef path="phoenix.Character" params="" file="/Users/sven/dev/luxe/luxe/phoenix/BitmapFont.hx" module="phoenix.BitmapFont"><a>
	<yoffset><x path="Int"/></yoffset>
	<y><x path="Int"/></y>
	<xoffset><x path="Int"/></xoffset>
	<xadvance><x path="Int"/></xadvance>
	<x><x path="Int"/></x>
	<width><x path="Int"/></width>
	<page><x path="Int"/></page>
	<id><x path="Int"/></id>
	<height><x path="Int"/></height>
</a></typedef>
	<typedef path="phoenix.KerningKey" params="" file="/Users/sven/dev/luxe/luxe/phoenix/BitmapFont.hx" module="phoenix.BitmapFont"><a>
	<index><x path="Int"/></index>
	<glyph><x path="Int"/></glyph>
</a></typedef>
	<typedef path="phoenix.KeyValuePair" params="" file="/Users/sven/dev/luxe/luxe/phoenix/BitmapFont.hx" module="phoenix.BitmapFont"><a>
	<value><c path="String"/></value>
	<key><c path="String"/></key>
</a></typedef>
	<typedef path="phoenix.PageInfo" params="" file="/Users/sven/dev/luxe/luxe/phoenix/BitmapFont.hx" module="phoenix.BitmapFont"><a>
	<id><x path="Int"/></id>
	<file><c path="String"/></file>
</a></typedef>
	<class path="phoenix.BitmapFont" params="" file="/Users/sven/dev/luxe/luxe/phoenix/BitmapFont.hx">
		<extends path="luxe.Resource"/>
		<dimensions public="1"><t path="luxe.Vector"/></dimensions>
		<spacing public="1"><x path="Float"/></spacing>
		<line_height public="1"><x path="Float"/></line_height>
		<font_size public="1"><x path="Float"/></font_size>
		<font_character_count public="1"><x path="Int"/></font_character_count>
		<pages public="1"><x path="Map">
	<x path="Int"/>
	<c path="phoenix.Texture"/>
</x></pages>
		<characters public="1"><x path="Map">
	<x path="Int"/>
	<t path="phoenix.Character"/>
</x></characters>
		<kernings public="1"><x path="Map">
	<t path="phoenix.KerningKey"/>
	<x path="Int"/>
</x></kernings>
		<scale public="1"><t path="luxe.Vector"/></scale>
		<line_widths><c path="Array"><x path="Float"/></c></line_widths>
		<on_pages_loaded public="1"><f a=""><x path="Void"/></f></on_pages_loaded>
		<pages_loaded public="1"><x path="Int"/></pages_loaded>
		<onload public="1"><f a="">
	<c path="phoenix.BitmapFont"/>
	<x path="Void"/>
</f></onload>
		<toString public="1" set="method" line="87"><f a=""><c path="String"/></f></toString>
		<_tokenize_font_line set="method" line="91"><f a="_line_tokens">
	<c path="Array"><c path="String"/></c>
	<x path="Map">
		<c path="String"/>
		<t path="phoenix.KeyValuePair"/>
	</x>
</f></_tokenize_font_line>
		<on_all_pages_loaded public="1" set="method" line="100"><f a=""><x path="Void"/></f></on_all_pages_loaded>
		<one_page_loaded public="1" set="method" line="106"><f a="t">
	<c path="phoenix.Texture"/>
	<x path="Void"/>
</f></one_page_loaded>
		<load_from_string public="1" set="method" line="113"><f a="?_bitmap_file:?_folder:?onloaded:?custom_pages" v="'':'assets/':null:null">
	<c path="String"/>
	<c path="String"/>
	<f a="">
		<c path="phoenix.BitmapFont"/>
		<x path="Void"/>
	</f>
	<c path="Array"><c path="phoenix.Texture"/></c>
	<x path="Void"/>
</f></load_from_string>
		<set_kerning public="1" set="method" line="248"><f a="_glyph:_index:_amount">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set_kerning>
		<get_kerning public="1" set="method" line="252"><f a="_glyph:_index">
	<x path="Int"/>
	<x path="Int"/>
	<t path="Null"><x path="Int"/></t>
</f></get_kerning>
		<get_text_dimensions public="1" set="method" line="262"><f a="_string:_scale">
	<c path="String"/>
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></get_text_dimensions>
		<draw_text public="1" set="method" line="326"><f a="options">
	<d/>
	<c path="phoenix.geometry.CompositeGeometry"/>
</f></draw_text>
		<set_character public="1" set="method" line="542"><f a="_index:_char_info">
	<x path="Int"/>
	<t path="phoenix.Character"/>
	<x path="Void"/>
</f></set_character>
		<new public="1" set="method" line="70"><f a="?_resource_manager" v="null">
	<c path="luxe.ResourceManager"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="phoenix.ProjectionType" params="" file="/Users/sven/dev/luxe/luxe/phoenix/Camera.hx" module="phoenix.Camera">
		<ortho/>
		<perspective/>
		<custom/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="phoenix.Camera" params="" file="/Users/sven/dev/luxe/luxe/phoenix/Camera.hx">
		<name public="1"><c path="String"/></name>
		<viewport public="1" get="accessor" set="accessor">
			<c path="phoenix.Rectangle"/>
			<meta><m n=":isVar"/></meta>
		</viewport>
		<center public="1" get="accessor" set="accessor">
			<c path="phoenix.Vector"/>
			<meta><m n=":isVar"/></meta>
		</center>
		<zoom public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</zoom>
		<pos public="1" get="accessor" set="accessor">
			<c path="phoenix.Vector"/>
			<meta><m n=":isVar"/></meta>
		</pos>
		<scale public="1" get="accessor" set="accessor">
			<c path="phoenix.Vector"/>
			<meta><m n=":isVar"/></meta>
		</scale>
		<rotation public="1" get="accessor" set="accessor">
			<c path="phoenix.Quaternion"/>
			<meta><m n=":isVar"/></meta>
		</rotation>
		<minimum_zoom public="1"><x path="Float"/></minimum_zoom>
		<projection_matrix public="1"><c path="phoenix.Matrix4"/></projection_matrix>
		<view_matrix public="1"><c path="phoenix.Matrix4"/></view_matrix>
		<_origin_matrix_inv><c path="phoenix.Matrix4"/></_origin_matrix_inv>
		<_pos_matrix><c path="phoenix.Matrix4"/></_pos_matrix>
		<_rot_matrix><c path="phoenix.Matrix4"/></_rot_matrix>
		<perspective_options public="1"><t path="luxe.options.ProjectionOptions"/></perspective_options>
		<ortho_options public="1"><t path="luxe.options.ProjectionOptions"/></ortho_options>
		<projection public="1"><e path="phoenix.ProjectionType"/></projection>
		<target public="1"><c path="phoenix.Vector"/></target>
		<up public="1"><c path="phoenix.Vector"/></up>
		<default_ortho_options set="method" line="107"><f a=""><t path="luxe.options.ProjectionOptions"/></f></default_ortho_options>
		<default_camera_options set="method" line="120"><f a=""><t path="luxe.options.CameraOptions"/></f></default_camera_options>
		<default_perspective_options set="method" line="134"><f a=""><t path="luxe.options.ProjectionOptions"/></f></default_perspective_options>
		<process public="1" set="method" line="144"><f a=""><x path="Void"/></f></process>
		<update_look_at public="1" set="method" line="158"><f a=""><x path="Void"/></f></update_look_at>
		<update_view_matrix set="method" line="168"><f a=""><x path="Void"/></f></update_view_matrix>
		<apply_ortho public="1" set="method" line="190"><f a=""><x path="Void"/></f></apply_ortho>
		<apply_perspective public="1" set="method" line="204"><f a=""><x path="Void"/></f></apply_perspective>
		<set_ortho public="1" set="method" line="224"><f a="options">
	<t path="luxe.options.ProjectionOptions"/>
	<x path="Void"/>
</f></set_ortho>
		<set_perspective public="1" set="method" line="235"><f a="options">
	<t path="luxe.options.ProjectionOptions"/>
	<x path="Void"/>
</f></set_perspective>
		<projectVector public="1" set="method" line="247"><f a="_vector">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></projectVector>
		<unprojectVector public="1" set="method" line="257"><f a="_vector">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></unprojectVector>
		<screen_point_to_ray public="1" set="method" line="266"><f a="_vector">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Ray"/>
</f></screen_point_to_ray>
		<screen_point_to_world public="1" set="method" line="272"><f a="_vector">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></screen_point_to_world>
		<world_point_to_screen public="1" set="method" line="285"><f a="_vector:?_viewport" v=":null">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Rectangle"/>
	<c path="phoenix.Vector"/>
</f></world_point_to_screen>
		<ortho_screen_to_world set="method" line="298"><f a="_vector">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></ortho_screen_to_world>
		<ortho_world_to_screen set="method" line="306"><f a="_vector">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></ortho_world_to_screen>
		<persepective_world_to_screen set="method" line="314"><f a="_vector:?_viewport" v=":null">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Rectangle"/>
	<c path="phoenix.Vector"/>
</f></persepective_world_to_screen>
		<set_zoom set="method" line="332"><f a="_p">
	<x path="Float"/>
	<x path="Float"/>
</f></set_zoom>
		<set_center set="method" line="352"><f a="_p">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></set_center>
		<get_center set="method" line="373"><f a=""><c path="phoenix.Vector"/></f></get_center>
		<get_pos set="method" line="377"><f a=""><c path="phoenix.Vector"/></f></get_pos>
		<get_scale set="method" line="380"><f a=""><c path="phoenix.Vector"/></f></get_scale>
		<get_rotation set="method" line="383"><f a=""><c path="phoenix.Quaternion"/></f></get_rotation>
		<get_viewport set="method" line="387"><f a=""><c path="phoenix.Rectangle"/></f></get_viewport>
		<set_viewport set="method" line="391"><f a="_r">
	<c path="phoenix.Rectangle"/>
	<c path="phoenix.Rectangle"/>
</f></set_viewport>
		<set_rotation set="method" line="409"><f a="_q">
	<c path="phoenix.Quaternion"/>
	<c path="phoenix.Quaternion"/>
</f></set_rotation>
		<set_scale set="method" line="419"><f a="_s">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></set_scale>
		<set_pos set="method" line="429"><f a="_p">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></set_pos>
		<_merge_options set="method" line="454"><f a="projection_options:options">
	<t path="luxe.options.ProjectionOptions"/>
	<t path="luxe.options.ProjectionOptions"/>
	<x path="Void"/>
</f></_merge_options>
		<_pos_change set="method" line="495"><f a="_v">
	<x path="Float"/>
	<x path="Void"/>
</f></_pos_change>
		<_scale_change set="method" line="497"><f a="_v">
	<x path="Float"/>
	<x path="Void"/>
</f></_scale_change>
		<_attach_listener set="method" line="503"><f a="_v:listener">
	<c path="phoenix.Vector"/>
	<f a="">
		<x path="Float"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></_attach_listener>
		<new public="1" set="method" line="52"><f a="?options" v="null">
	<t path="luxe.options.CameraOptions"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.Circle" params="" file="/Users/sven/dev/luxe/luxe/phoenix/Circle.hx">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<r public="1"><x path="Float"/></r>
		<toString public="1" set="method" line="16"><f a=""><c path="String"/></f></toString>
		<point_inside public="1" set="method" line="20"><f a="_p">
	<c path="phoenix.Vector"/>
	<x path="Bool"/>
</f></point_inside>
		<clone public="1" set="method" line="25"><f a=""><c path="phoenix.Circle"/></f></clone>
		<set public="1" set="method" line="29"><f a="?_x:?_y:?_r" v="null:null:null">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="phoenix.Circle"/>
</f></set>
		<new public="1" set="method" line="10"><f a="?_x:?_y:?_r" v="0:0:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.Color" params="" file="/Users/sven/dev/luxe/luxe/phoenix/Color.hx">
		<random public="1" set="method" line="81" static="1"><f a="?_include_alpha" v="false">
	<x path="Bool"/>
	<c path="phoenix.Color"/>
</f></random>
		<r public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</r>
		<g public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</g>
		<b public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</b>
		<a public="1"><x path="Float"/></a>
		<is_hsl><x path="Bool"/></is_hsl>
		<is_hsv><x path="Bool"/></is_hsv>
		<refreshing><x path="Bool"/></refreshing>
		<serialized public="1" get="accessor" set="null">
			<d/>
			<meta><m n=":isVar"/></meta>
		</serialized>
		<get_serialized set="method" line="23"><f a=""><d/></f></get_serialized>
		<set_r set="method" line="34"><f a="_r">
	<x path="Float"/>
	<x path="Float"/>
</f></set_r>
		<set_g set="method" line="49"><f a="_g">
	<x path="Float"/>
	<x path="Float"/>
</f></set_g>
		<set_b set="method" line="64"><f a="_b">
	<x path="Float"/>
	<x path="Float"/>
</f></set_b>
		<set public="1" set="method" line="85"><f a="?_r:?_g:?_b:?_a" v="null:null:null:null">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="phoenix.Color"/>
</f></set>
		<maxRGB public="1" set="method" line="106"><f a=""><x path="Float"/></f></maxRGB>
		<minRGB public="1" set="method" line="110"><f a=""><x path="Float"/></f></minRGB>
		<tween public="1" set="method" line="114"><f a="?_time_in_seconds:?_properties_to_tween:?_override" v="0.5f:null:true">
	<x path="Float"/>
	<t path="luxe.options.ColorOptions"/>
	<x path="Bool"/>
	<c path="luxe.tween.actuators.IGenericActuator"/>
</f></tween>
		<clone public="1" set="method" line="164"><f a=""><c path="phoenix.Color"/></f></clone>
		<rgb public="1" set="method" line="168"><f a="?_rgb" v="16777215">
	<x path="Int"/>
	<c path="phoenix.Color"/>
</f></rgb>
		<toColorHSL public="1" set="method" line="173"><f a=""><c path="phoenix.ColorHSL"/></f></toColorHSL>
		<toColorHSV public="1" set="method" line="177"><f a=""><c path="phoenix.ColorHSV"/></f></toColorHSV>
		<fromColorHSV public="1" set="method" line="181"><f a="_color_hsv">
	<c path="phoenix.ColorHSV"/>
	<x path="Void"/>
</f></fromColorHSV>
		<fromColorHSL public="1" set="method" line="211"><f a="_color_hsl">
	<c path="phoenix.ColorHSL"/>
	<c path="phoenix.Color"/>
</f></fromColorHSL>
		<toString public="1" set="method" line="261"><f a=""><c path="String"/></f></toString>
		<from_int set="method" line="265"><f a="_i">
	<x path="Int"/>
	<x path="Void"/>
</f></from_int>
		<new public="1" set="method" line="25"><f a="?_r:?_g:?_b:?_a" v="1.0f:1.0f:1.0f:1.0f">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.ColorHSL" params="" file="/Users/sven/dev/luxe/luxe/phoenix/Color.hx" module="phoenix.Color">
		<extends path="phoenix.Color"/>
		<h public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</h>
		<s public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</s>
		<l public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</l>
		<set_h set="method" line="290"><f a="_h">
	<x path="Float"/>
	<x path="Float"/>
</f></set_h>
		<set_s set="method" line="295"><f a="_s">
	<x path="Float"/>
	<x path="Float"/>
</f></set_s>
		<set_l set="method" line="300"><f a="_l">
	<x path="Float"/>
	<x path="Float"/>
</f></set_l>
		<set public="1" set="method" line="321" override="1"><f a="?_h:?_s:?_l:?_a" v="null:null:null:null">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="phoenix.ColorHSL"/>
</f></set>
		<tween public="1" set="method" line="345" override="1"><f a="?_time_in_seconds:?_dest:?_override" v="0.5f:null:true">
	<x path="Float"/>
	<t path="luxe.options.ColorOptions"/>
	<x path="Bool"/>
	<c path="luxe.tween.actuators.IGenericActuator"/>
</f></tween>
		<_refresh public="1" set="method" line="397"><f a=""><c path="phoenix.ColorHSL"/></f></_refresh>
		<clone public="1" set="method" line="406" override="1"><f a=""><c path="phoenix.ColorHSL"/></f></clone>
		<toColor public="1" set="method" line="410"><f a=""><c path="phoenix.Color"/></f></toColor>
		<fromColor public="1" set="method" line="414"><f a="_color">
	<c path="phoenix.Color"/>
	<c path="phoenix.ColorHSL"/>
</f></fromColor>
		<toString public="1" set="method" line="451" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="306"><f a="?_h:?_s:?_l:?_a" v="0.0f:1.0f:1.0f:1.0f">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.ColorHSV" params="" file="/Users/sven/dev/luxe/luxe/phoenix/Color.hx" module="phoenix.Color">
		<extends path="phoenix.Color"/>
		<h public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</h>
		<s public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</s>
		<v public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</v>
		<set_h set="method" line="465"><f a="_h">
	<x path="Float"/>
	<x path="Float"/>
</f></set_h>
		<set_s set="method" line="470"><f a="_s">
	<x path="Float"/>
	<x path="Float"/>
</f></set_s>
		<set_v set="method" line="475"><f a="_v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_v>
		<set public="1" set="method" line="496" override="1"><f a="?_h:?_s:?_v:?_a" v="null:null:null:null">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="phoenix.Color"/>
</f></set>
		<tween public="1" set="method" line="521" override="1"><f a="?_time_in_seconds:?_dest:?_override" v="0.5f:null:true">
	<x path="Float"/>
	<t path="luxe.options.ColorOptions"/>
	<x path="Bool"/>
	<c path="luxe.tween.actuators.IGenericActuator"/>
</f></tween>
		<_refresh public="1" set="method" line="573"><f a=""><c path="phoenix.ColorHSV"/></f></_refresh>
		<clone public="1" set="method" line="582" override="1"><f a=""><c path="phoenix.ColorHSV"/></f></clone>
		<toColor public="1" set="method" line="586"><f a=""><c path="phoenix.Color"/></f></toColor>
		<toColorHSL public="1" set="method" line="591" override="1"><f a=""><c path="phoenix.ColorHSL"/></f></toColorHSL>
		<fromColorHSL public="1" set="method" line="596" override="1"><f a="_color_hsl">
	<c path="phoenix.ColorHSL"/>
	<c path="phoenix.ColorHSV"/>
</f></fromColorHSL>
		<fromColor public="1" set="method" line="602"><f a="_color">
	<c path="phoenix.Color"/>
	<c path="phoenix.ColorHSV"/>
</f></fromColor>
		<toString public="1" set="method" line="636" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="481"><f a="?_h:?_s:?_v:?_a" v="0.0f:0.0f:1.0f:1.0f">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="phoenix.MatrixTransform" params="" file="/Users/sven/dev/luxe/luxe/phoenix/Matrix4.hx" module="phoenix.Matrix4"><a>
	<scale><c path="phoenix.Vector"/></scale>
	<rotation><c path="phoenix.Quaternion"/></rotation>
	<pos><c path="phoenix.Vector"/></pos>
</a></typedef>
	<class path="phoenix.Matrix4" params="" file="/Users/sven/dev/luxe/luxe/phoenix/Matrix4.hx">
		<GetLeft public="1" set="method" line="984" static="1"><f a="_m">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Vector"/>
</f></GetLeft>
		<GetRight public="1" set="method" line="988" static="1"><f a="_m">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Vector"/>
</f></GetRight>
		<GetUp public="1" set="method" line="992" static="1"><f a="_m">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Vector"/>
</f></GetUp>
		<GetDown public="1" set="method" line="996" static="1"><f a="_m">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Vector"/>
</f></GetDown>
		<GetForward public="1" set="method" line="1000" static="1"><f a="_m">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Vector"/>
</f></GetForward>
		<GetBackward public="1" set="method" line="1004" static="1"><f a="_m">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Vector"/>
</f></GetBackward>
		<elements public="1"><c path="Array"><x path="Float"/></c></elements>
		<M11 public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</M11>
		<M21 public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</M21>
		<M31 public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</M31>
		<M41 public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</M41>
		<M12 public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</M12>
		<M22 public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</M22>
		<M32 public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</M32>
		<M42 public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</M42>
		<M13 public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</M13>
		<M23 public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</M23>
		<M33 public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</M33>
		<M43 public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</M43>
		<M14 public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</M14>
		<M24 public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</M24>
		<M34 public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</M34>
		<M44 public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</M44>
		<set public="1" set="method" line="59"><f a="n11:n12:n13:n14:n21:n22:n23:n24:n31:n32:n33:n34:n41:n42:n43:n44">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="phoenix.Matrix4"/>
</f></set>
		<toString public="1" set="method" line="76"><f a=""><c path="String"/></f></toString>
		<get_M11 set="method" line="85"><f a=""><x path="Float"/></f></get_M11>
		<get_M12 set="method" line="86"><f a=""><x path="Float"/></f></get_M12>
		<get_M13 set="method" line="87"><f a=""><x path="Float"/></f></get_M13>
		<get_M14 set="method" line="88"><f a=""><x path="Float"/></f></get_M14>
		<get_M21 set="method" line="90"><f a=""><x path="Float"/></f></get_M21>
		<get_M22 set="method" line="91"><f a=""><x path="Float"/></f></get_M22>
		<get_M23 set="method" line="92"><f a=""><x path="Float"/></f></get_M23>
		<get_M24 set="method" line="93"><f a=""><x path="Float"/></f></get_M24>
		<get_M31 set="method" line="95"><f a=""><x path="Float"/></f></get_M31>
		<get_M32 set="method" line="96"><f a=""><x path="Float"/></f></get_M32>
		<get_M33 set="method" line="97"><f a=""><x path="Float"/></f></get_M33>
		<get_M34 set="method" line="98"><f a=""><x path="Float"/></f></get_M34>
		<get_M41 set="method" line="100"><f a=""><x path="Float"/></f></get_M41>
		<get_M42 set="method" line="101"><f a=""><x path="Float"/></f></get_M42>
		<get_M43 set="method" line="102"><f a=""><x path="Float"/></f></get_M43>
		<get_M44 set="method" line="103"><f a=""><x path="Float"/></f></get_M44>
		<set_M11 set="method" line="105"><f a="_value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_M11>
		<set_M12 set="method" line="106"><f a="_value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_M12>
		<set_M13 set="method" line="107"><f a="_value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_M13>
		<set_M14 set="method" line="108"><f a="_value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_M14>
		<set_M21 set="method" line="110"><f a="_value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_M21>
		<set_M22 set="method" line="111"><f a="_value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_M22>
		<set_M23 set="method" line="112"><f a="_value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_M23>
		<set_M24 set="method" line="113"><f a="_value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_M24>
		<set_M31 set="method" line="115"><f a="_value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_M31>
		<set_M32 set="method" line="116"><f a="_value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_M32>
		<set_M33 set="method" line="117"><f a="_value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_M33>
		<set_M34 set="method" line="118"><f a="_value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_M34>
		<set_M41 set="method" line="120"><f a="_value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_M41>
		<set_M42 set="method" line="121"><f a="_value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_M42>
		<set_M43 set="method" line="122"><f a="_value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_M43>
		<set_M44 set="method" line="123"><f a="_value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_M44>
		<float32array public="1" set="method" line="125"><f a=""><c path="lime.utils.Float32Array"/></f></float32array>
		<identity public="1" set="method" line="129"><f a=""><c path="phoenix.Matrix4"/></f></identity>
		<copy public="1" set="method" line="142"><f a="m">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Matrix4"/>
</f></copy>
		<make2D public="1" set="method" line="156"><f a="_x:_y:?_scale:?_rotation" v="::1:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="phoenix.Matrix4"/>
</f></make2D>
		<copyPosition public="1" set="method" line="173"><f a="m">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Matrix4"/>
</f></copyPosition>
		<getPosition public="1" set="method" line="183"><f a=""><c path="phoenix.Vector"/></f></getPosition>
		<extractRotation public="1" set="method" line="187"><f a="m">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Matrix4"/>
</f></extractRotation>
		<makeRotationFromEuler public="1" set="method" line="211"><f a="_v:?_order" v=":'XYZ'">
	<c path="phoenix.Vector"/>
	<c path="String"/>
	<c path="phoenix.Matrix4"/>
</f></makeRotationFromEuler>
		<makeRotationFromQuaternion public="1" set="method" line="336"><f a="q">
	<c path="phoenix.Quaternion"/>
	<c path="phoenix.Matrix4"/>
</f></makeRotationFromQuaternion>
		<lookAt public="1" set="method" line="373"><f a="_eye:_target:_up">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
	<c path="phoenix.Matrix4"/>
</f></lookAt>
		<multiply public="1" set="method" line="405"><f a="_m">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Matrix4"/>
</f></multiply>
		<multiplyMatrices public="1" set="method" line="412"><f a="_a:_b">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Matrix4"/>
</f></multiplyMatrices>
		<multiplyToArray public="1" set="method" line="453"><f a="_a:_b:_r">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Matrix4"/>
	<c path="Array"><x path="Float"/></c>
	<c path="phoenix.Matrix4"/>
</f></multiplyToArray>
		<multiplyScalar public="1" set="method" line="469"><f a="_s">
	<x path="Float"/>
	<c path="phoenix.Matrix4"/>
</f></multiplyScalar>
		<multiplyVector3Array public="1" set="method" line="483"><f a="_a">
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Float"/></c>
</f></multiplyVector3Array>
		<determinant public="1" set="method" line="509"><f a=""><x path="Float"/></f></determinant>
		<transpose public="1" set="method" line="554"><f a=""><c path="phoenix.Matrix4"/></f></transpose>
		<flattenToArray public="1" set="method" line="571"><f a="?_flat" v="null">
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Float"/></c>
</f></flattenToArray>
		<flattenToArrayOffset public="1" set="method" line="590"><f a="_flat:_offset">
	<c path="Array"><x path="Float"/></c>
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
</f></flattenToArrayOffset>
		<setPosition public="1" set="method" line="619"><f a="_v">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Matrix4"/>
</f></setPosition>
		<inverse public="1" set="method" line="631"><f a=""><c path="phoenix.Matrix4"/></f></inverse>
		<getInverse public="1" set="method" line="635"><f a="_m">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Matrix4"/>
</f></getInverse>
		<scale public="1" set="method" line="683"><f a="_v">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Matrix4"/>
</f></scale>
		<getMaxScaleOnAxis public="1" set="method" line="701"><f a=""><x path="Float"/></f></getMaxScaleOnAxis>
		<makeTranslation public="1" set="method" line="714"><f a="_x:_y:_z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="phoenix.Matrix4"/>
</f></makeTranslation>
		<makeRotationX public="1" set="method" line="728"><f a="_theta">
	<x path="Float"/>
	<c path="phoenix.Matrix4"/>
</f></makeRotationX>
		<makeRotationY public="1" set="method" line="745"><f a="_theta">
	<x path="Float"/>
	<c path="phoenix.Matrix4"/>
</f></makeRotationY>
		<makeRotationZ public="1" set="method" line="762"><f a="_theta">
	<x path="Float"/>
	<c path="phoenix.Matrix4"/>
</f></makeRotationZ>
		<makeRotationAxis public="1" set="method" line="779"><f a="_axis:_angle">
	<c path="phoenix.Vector"/>
	<x path="Float"/>
	<c path="phoenix.Matrix4"/>
</f></makeRotationAxis>
		<makeScale public="1" set="method" line="804"><f a="_x:_y:_z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="phoenix.Matrix4"/>
</f></makeScale>
		<compose_with_origin public="1" set="method" line="818"><f a="_position:_origin:_quaternion:_scale">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
	<c path="phoenix.Quaternion"/>
	<c path="phoenix.Vector"/>
	<c path="phoenix.Matrix4"/>
</f></compose_with_origin>
		<compose public="1" set="method" line="837"><f a="_position:_quaternion:_scale">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Quaternion"/>
	<c path="phoenix.Vector"/>
	<c path="phoenix.Matrix4"/>
</f></compose>
		<decompose public="1" set="method" line="847"><f a="?_position:?_quaternion:?_scale" v="null:null:null">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Quaternion"/>
	<c path="phoenix.Vector"/>
	<t path="phoenix.MatrixTransform"/>
</f></decompose>
		<makeFrustum public="1" set="method" line="897"><f a="_left:_right:_bottom:_top:_near:_far">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="phoenix.Matrix4"/>
</f></makeFrustum>
		<makePerspective public="1" set="method" line="919"><f a="_fov:_aspect:_near:_far">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="phoenix.Matrix4"/>
</f></makePerspective>
		<makeOrthographic public="1" set="method" line="931"><f a="_left:_right:_top:_bottom:_near:_far">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="phoenix.Matrix4"/>
</f></makeOrthographic>
		<fromArray public="1" set="method" line="952"><f a="_from">
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></fromArray>
		<toArray public="1" set="method" line="958"><f a=""><c path="Array"><x path="Float"/></c></f></toArray>
		<clone public="1" set="method" line="971"><f a=""><c path="phoenix.Matrix4"/></f></clone>
		<new public="1" set="method" line="39"><f a="?n11:?n12:?n13:?n14:?n21:?n22:?n23:?n24:?n31:?n32:?n33:?n34:?n41:?n42:?n43:?n44" v="1:0:0:0:0:1:0:0:0:0:1:0:0:0:0:1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.Quaternion" params="" file="/Users/sven/dev/luxe/luxe/phoenix/Quaternion.hx">
		<Slerp public="1" set="method" line="403" static="1"><f a="_qa:_qb:_qm:_t">
	<c path="phoenix.Quaternion"/>
	<c path="phoenix.Quaternion"/>
	<c path="phoenix.Quaternion"/>
	<x path="Float"/>
	<c path="phoenix.Quaternion"/>
</f></Slerp>
		<Dot public="1" set="method" line="409" static="1"><f a="_a:_b">
	<c path="phoenix.Quaternion"/>
	<c path="phoenix.Quaternion"/>
	<x path="Float"/>
</f></Dot>
		<x public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</x>
		<y public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</y>
		<z public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</z>
		<w public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</w>
		<euler><c path="phoenix.Vector"/></euler>
		<toString public="1" set="method" line="27"><f a=""><c path="String"/></f></toString>
		<set public="1" set="method" line="33"><f a="_x:_y:_z:_w">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="phoenix.Quaternion"/>
</f></set>
		<copy public="1" set="method" line="45"><f a="_quaternion">
	<c path="phoenix.Quaternion"/>
	<c path="phoenix.Quaternion"/>
</f></copy>
		<dot public="1" set="method" line="56"><f a="_other">
	<c path="phoenix.Quaternion"/>
	<x path="Float"/>
</f></dot>
		<setFromEuler public="1" set="method" line="61"><f a="_euler:?_order" v=":'XYZ'">
	<c path="phoenix.Vector"/>
	<c path="String"/>
	<c path="phoenix.Quaternion"/>
</f></setFromEuler>
		<setFromAxisAngle public="1" set="method" line="124"><f a="_axis:_angle">
	<c path="phoenix.Vector"/>
	<x path="Float"/>
	<c path="phoenix.Quaternion"/>
</f></setFromAxisAngle>
		<setFromRotationMatrix public="1" set="method" line="142"><f a="_m">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Quaternion"/>
</f></setFromRotationMatrix>
		<inverse public="1" set="method" line="200"><f a=""><c path="phoenix.Quaternion"/></f></inverse>
		<conjugate public="1" set="method" line="207"><f a=""><c path="phoenix.Quaternion"/></f></conjugate>
		<lengthSq public="1" set="method" line="218"><f a=""><x path="Float"/></f></lengthSq>
		<length public="1" set="method" line="225"><f a=""><x path="Float"/></f></length>
		<normalize public="1" set="method" line="232"><f a=""><c path="phoenix.Quaternion"/></f></normalize>
		<multiply public="1" set="method" line="259"><f a="_quaternion">
	<c path="phoenix.Quaternion"/>
	<c path="phoenix.Quaternion"/>
</f></multiply>
		<add public="1" set="method" line="265"><f a="_quaternion">
	<c path="phoenix.Quaternion"/>
	<c path="phoenix.Quaternion"/>
</f></add>
		<addQuaternions public="1" set="method" line="271"><f a="_a:_b">
	<c path="phoenix.Quaternion"/>
	<c path="phoenix.Quaternion"/>
	<c path="phoenix.Quaternion"/>
</f></addQuaternions>
		<multiplyScalar public="1" set="method" line="282"><f a="_scalar">
	<x path="Float"/>
	<c path="phoenix.Quaternion"/>
</f></multiplyScalar>
		<multiplyQuaternions public="1" set="method" line="293"><f a="_a:_b">
	<c path="phoenix.Quaternion"/>
	<c path="phoenix.Quaternion"/>
	<c path="phoenix.Quaternion"/>
</f></multiplyQuaternions>
		<slerp public="1" set="method" line="308"><f a="_qb:_t">
	<c path="phoenix.Quaternion"/>
	<x path="Float"/>
	<c path="phoenix.Quaternion"/>
</f></slerp>
		<equals public="1" set="method" line="372"><f a="_q">
	<c path="phoenix.Quaternion"/>
	<x path="Bool"/>
</f></equals>
		<fromArray public="1" set="method" line="379"><f a="_a">
	<c path="Array"><x path="Float"/></c>
	<c path="phoenix.Quaternion"/>
</f></fromArray>
		<toArray public="1" set="method" line="391"><f a=""><c path="Array"><x path="Float"/></c></f></toArray>
		<clone public="1" set="method" line="397"><f a=""><c path="phoenix.Quaternion"/></f></clone>
		<update_euler set="method" line="413"><f a=""><x path="Void"/></f></update_euler>
		<set_x set="method" line="419"><f a="_v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y set="method" line="429"><f a="_v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<set_z set="method" line="439"><f a="_v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_z>
		<set_w set="method" line="449"><f a="_v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_w>
		<new public="1" set="method" line="16"><f a="?_x:?_y:?_z:?_w" v="0:0:0:1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.Ray" params="" file="/Users/sven/dev/luxe/luxe/phoenix/Ray.hx">
		<origin public="1"><c path="phoenix.Vector"/></origin>
		<end public="1"><c path="phoenix.Vector"/></end>
		<dir public="1"><c path="phoenix.Vector"/></dir>
		<camera><c path="phoenix.Camera"/></camera>
		<viewport><c path="phoenix.Rectangle"/></viewport>
		<refresh public="1" set="method" line="32"><f a="_screen_pos">
	<c path="phoenix.Vector"/>
	<x path="Void"/>
</f></refresh>
		<new public="1" set="method" line="17"><f a="_screen_pos:_camera:?_viewport" v="::null">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Camera"/>
	<c path="phoenix.Rectangle"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.Rectangle" params="" file="/Users/sven/dev/luxe/luxe/phoenix/Rectangle.hx">
		<x public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</x>
		<y public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</y>
		<w public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</w>
		<h public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</h>
		<serialized public="1" get="accessor" set="null">
			<d/>
			<meta><m n=":isVar"/></meta>
		</serialized>
		<ignore_listeners public="1"><x path="Bool"/></ignore_listeners>
		<listen_x public="1">
			<f a="">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":isVar"/></meta>
		</listen_x>
		<listen_y public="1">
			<f a="">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":isVar"/></meta>
		</listen_y>
		<listen_w public="1">
			<f a="">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":isVar"/></meta>
		</listen_w>
		<listen_h public="1">
			<f a="">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":isVar"/></meta>
		</listen_h>
		<toString public="1" set="method" line="29"><f a=""><c path="String"/></f></toString>
		<point_inside public="1" set="method" line="35"><f a="_p">
	<c path="phoenix.Vector"/>
	<x path="Bool"/>
</f></point_inside>
		<overlaps public="1" set="method" line="46"><f a="_other">
	<c path="phoenix.Rectangle"/>
	<x path="Bool"/>
</f></overlaps>
		<clone public="1" set="method" line="64"><f a=""><c path="phoenix.Rectangle"/></f></clone>
		<equal public="1" set="method" line="71"><f a="_other">
	<c path="phoenix.Rectangle"/>
	<x path="Bool"/>
</f></equal>
		<copy_from public="1" set="method" line="81"><f a="_rect">
	<c path="phoenix.Rectangle"/>
	<x path="Void"/>
</f></copy_from>
		<set public="1" set="method" line="90"><f a="?_x:?_y:?_w:?_h" v="null:null:null:null">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="phoenix.Rectangle"/>
</f></set>
		<set_x set="method" line="112"><f a="_x">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y set="method" line="124"><f a="_y">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<set_w set="method" line="136"><f a="_w">
	<x path="Float"/>
	<x path="Float"/>
</f></set_w>
		<set_h set="method" line="148"><f a="_h">
	<x path="Float"/>
	<x path="Float"/>
</f></set_h>
		<get_serialized set="method" line="160"><f a=""><d/></f></get_serialized>
		<new public="1" set="method" line="20"><f a="?_x:?_y:?_w:?_h" v="0:0:0:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.RenderPath" params="" file="/Users/sven/dev/luxe/luxe/phoenix/RenderPath.hx">
		<renderer public="1"><c path="phoenix.Renderer"/></renderer>
		<render public="1" set="method" line="18"><f a="_batchers:_stats">
	<c path="Array"><c path="phoenix.Batcher"/></c>
	<c path="phoenix.RendererStats"/>
	<x path="Void"/>
</f></render>
		<new public="1" set="method" line="13"><f a="_renderer">
	<c path="phoenix.Renderer"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.RenderState" params="" file="/Users/sven/dev/luxe/luxe/phoenix/RenderState.hx">
		<cull_face><x path="Bool"/></cull_face>
		<depth_test><x path="Bool"/></depth_test>
		<renderer><c path="phoenix.Renderer"/></renderer>
		<_viewport><c path="phoenix.Rectangle"/></_viewport>
		<enable public="1" set="method" line="20"><f a="what">
	<x path="Int"/>
	<x path="Void"/>
</f></enable>
		<disable public="1" set="method" line="37"><f a="what">
	<x path="Int"/>
	<x path="Void"/>
</f></disable>
		<viewport public="1" set="method" line="54"><f a="x:y:w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></viewport>
		<_used_program><c path="lime.gl.GLProgram"/></_used_program>
		<useProgram public="1" set="method" line="73"><f a="program">
	<c path="lime.gl.GLProgram"/>
	<x path="Void"/>
</f></useProgram>
		<_active_texture><x path="Int"/></_active_texture>
		<activeTexture public="1" set="method" line="81"><f a="val">
	<x path="Int"/>
	<x path="Void"/>
</f></activeTexture>
		<_bound_texture_2D><c path="lime.gl.GLTexture"/></_bound_texture_2D>
		<bindTexture2D public="1" set="method" line="89"><f a="tex">
	<c path="lime.gl.GLTexture"/>
	<x path="Void"/>
</f></bindTexture2D>
		<_last_line_width><x path="Float"/></_last_line_width>
		<lineWidth public="1" set="method" line="97"><f a="_width">
	<x path="Float"/>
	<x path="Void"/>
</f></lineWidth>
		<new public="1" set="method" line="15"><f a="_renderer">
	<c path="phoenix.Renderer"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.Texture" params="" file="/Users/sven/dev/luxe/luxe/phoenix/Texture.hx">
		<extends path="luxe.Resource"/>
		<lime_bitmap_data_from_bytes line="572" static="1"><f a=":">
	<c path="haxe.io.Bytes"/>
	<unknown/>
	<unknown/>
</f></lime_bitmap_data_from_bytes>
		<lime_bitmap_data_height line="573" static="1"><f a="">
	<unknown/>
	<x path="Int"/>
</f></lime_bitmap_data_height>
		<lime_bitmap_data_width line="574" static="1"><f a="">
	<unknown/>
	<x path="Int"/>
</f></lime_bitmap_data_width>
		<lime_bitmap_data_get_pixels line="575" static="1"><f a=":">
	<unknown/>
	<a>
		<y><x path="Int"/></y>
		<x><x path="Int"/></x>
		<width><x path="Int"/></width>
		<height><x path="Int"/></height>
	</a>
	<unknown/>
</f></lime_bitmap_data_get_pixels>
		<texture public="1"><c path="lime.gl.GLTexture"/></texture>
		<data public="1"><c path="lime.utils.UInt8Array"/></data>
		<actual_width public="1"><x path="Int"/></actual_width>
		<actual_height public="1"><x path="Int"/></actual_height>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<loaded public="1"><x path="Bool"/></loaded>
		<slot public="1"><x path="Int"/></slot>
		<_onload_handlers public="1"><c path="Array"><f a="">
	<c path="phoenix.Texture"/>
	<x path="Void"/>
</f></c></_onload_handlers>
		<onload public="1" get="null" set="accessor">
			<f a="">
				<c path="phoenix.Texture"/>
				<x path="Void"/>
			</f>
			<meta><m n=":isVar"/></meta>
		</onload>
		<filter public="1" set="accessor">
			<e path="phoenix.FilterType"/>
			<meta><m n=":isVar"/></meta>
		</filter>
		<filter_min public="1" set="accessor">
			<e path="phoenix.FilterType"/>
			<meta><m n=":isVar"/></meta>
		</filter_min>
		<filter_mag public="1" set="accessor">
			<e path="phoenix.FilterType"/>
			<meta><m n=":isVar"/></meta>
		</filter_mag>
		<clamp public="1" set="accessor">
			<e path="phoenix.ClampType"/>
			<meta><m n=":isVar"/></meta>
		</clamp>
		<set_onload public="1" set="method" line="65"><f a="f">
	<f a="">
		<c path="phoenix.Texture"/>
		<x path="Void"/>
	</f>
	<f a="">
		<c path="phoenix.Texture"/>
		<x path="Void"/>
	</f>
</f></set_onload>
		<do_onload public="1" set="method" line="80"><f a=""><x path="Void"/></f></do_onload>
		<toString public="1" set="method" line="92"><f a=""><c path="String"/></f></toString>
		<build public="1" set="method" line="96">
			<f a="_size:_color">
				<c path="phoenix.Vector"/>
				<c path="phoenix.Color"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</build>
		<estimated_memory public="1" set="method" line="130"><f a=""><c path="String"/></f></estimated_memory>
		<create_from_bytes_html public="1" set="method" line="138"><f a="_asset_name:_asset_bytes:_width:_height">
	<c path="String"/>
	<unknown/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></create_from_bytes_html>
		<create_from_bytes public="1" set="method" line="171"><f a="_asset_name:_asset_bytes">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></create_from_bytes>
		<create_from_bytes_using_haxe public="1" set="method" line="247"><f a="_asset_name:_asset_bytes">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></create_from_bytes_using_haxe>
		<generate_mipmaps public="1" set="method" line="309"><f a=""><x path="Void"/></f></generate_mipmaps>
		<bind public="1" set="method" line="320"><f a=""><x path="Void"/></f></bind>
		<get_pixel public="1" set="method" line="344"><f a="_pos">
	<c path="phoenix.Vector"/>
	<a>
		<r><x path="Float"/></r>
		<g><x path="Float"/></g>
		<b><x path="Float"/></b>
		<a><x path="Float"/></a>
	</a>
</f></get_pixel>
		<set_pixel public="1" set="method" line="360"><f a="_pos:_color">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Color"/>
	<x path="Void"/>
</f></set_pixel>
		<lock public="1" set="method" line="374"><f a=""><x path="Bool"/></f></lock>
		<unlock public="1" set="method" line="387"><f a=""><x path="Void"/></f></unlock>
		<drop public="1" set="method" line="400" override="1"><f a=""><x path="Void"/></f></drop>
		<activate public="1" set="method" line="407"><f a="att">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Void"/>
</f></activate>
		<destroy public="1" set="method" line="409"><f a=""><x path="Void"/></f></destroy>
		<_set_clamp set="method" line="417"><f a="_clamp">
	<e path="phoenix.ClampType"/>
	<x path="Void"/>
</f></_set_clamp>
		<set_clamp set="method" line="433"><f a="_clamp">
	<e path="phoenix.ClampType"/>
	<e path="phoenix.ClampType"/>
</f></set_clamp>
		<_set_filter set="method" line="449"><f a="_filter">
	<e path="phoenix.FilterType"/>
	<x path="Void"/>
</f></_set_filter>
		<_set_filter_min set="method" line="479"><f a="_filter">
	<e path="phoenix.FilterType"/>
	<x path="Void"/>
</f></_set_filter_min>
		<_set_filter_mag set="method" line="502"><f a="_filter">
	<e path="phoenix.FilterType"/>
	<x path="Void"/>
</f></_set_filter_mag>
		<set_filter set="method" line="524"><f a="_filter">
	<e path="phoenix.FilterType"/>
	<e path="phoenix.FilterType"/>
</f></set_filter>
		<set_filter_min set="method" line="540"><f a="_filter">
	<e path="phoenix.FilterType"/>
	<e path="phoenix.FilterType"/>
</f></set_filter_min>
		<set_filter_mag set="method" line="556"><f a="_filter">
	<e path="phoenix.FilterType"/>
	<e path="phoenix.FilterType"/>
</f></set_filter_mag>
		<new public="1" set="method" line="54"><f a="_manager:?_type" v=":null">
	<c path="luxe.ResourceManager"/>
	<e path="luxe.ResourceType"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.RenderTexture" params="" file="/Users/sven/dev/luxe/luxe/phoenix/RenderTexture.hx">
		<extends path="phoenix.Texture"/>
		<fbo public="1"><c path="lime.gl.GLFramebuffer"/></fbo>
		<destroy public="1" set="method" line="71" override="1"><f a=""><x path="Void"/></f></destroy>
		<bindBuffer public="1" set="method" line="78"><f a=""><x path="Void"/></f></bindBuffer>
		<unbindBuffer public="1" set="method" line="82"><f a="?_other" v="null">
	<c path="lime.gl.GLFramebuffer"/>
	<x path="Void"/>
</f></unbindBuffer>
		<new public="1" set="method" line="17"><f a="_manager:?_size" v=":null">
	<c path="luxe.ResourceManager"/>
	<c path="phoenix.Vector"/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="phoenix.BatcherKey" params="" file="/Users/sven/dev/luxe/luxe/phoenix/Renderer.hx" module="phoenix.Renderer"><a>
	<uuid><c path="String"/></uuid>
	<layer><x path="Int"/></layer>
</a></typedef>
	<class path="phoenix.Renderer" params="" file="/Users/sven/dev/luxe/luxe/phoenix/Renderer.hx">
		<resource_manager public="1"><c path="luxe.ResourceManager"/></resource_manager>
		<batchers public="1"><c path="Array"><c path="phoenix.Batcher"/></c></batchers>
		<state public="1"><c path="phoenix.RenderState"/></state>
		<default_shader public="1"><c path="phoenix.Shader"/></default_shader>
		<default_shader_textured public="1"><c path="phoenix.Shader"/></default_shader_textured>
		<default_batcher public="1"><c path="phoenix.Batcher"/></default_batcher>
		<default_camera public="1"><c path="phoenix.Camera"/></default_camera>
		<default_font public="1"><c path="phoenix.BitmapFont"/></default_font>
		<render_path public="1"><c path="phoenix.RenderPath"/></render_path>
		<default_render_path public="1"><c path="phoenix.RenderPath"/></default_render_path>
		<should_clear public="1"><x path="Bool"/></should_clear>
		<stop public="1"><x path="Bool"/></stop>
		<stop_count public="1"><x path="Int"/></stop_count>
		<clear_color public="1"><c path="phoenix.Color"/></clear_color>
		<stats public="1"><c path="phoenix.RendererStats"/></stats>
		<init public="1" set="method" line="68"><f a=""><x path="Void"/></f></init>
		<destroy public="1" set="method" line="142"><f a=""><x path="Void"/></f></destroy>
		<sort_batchers public="1" set="method" line="146">
			<f a="a:b">
				<c path="phoenix.Batcher"/>
				<c path="phoenix.Batcher"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</sort_batchers>
		<add_batch public="1" set="method" line="152"><f a="batch">
	<c path="phoenix.Batcher"/>
	<x path="Void"/>
</f></add_batch>
		<remove_batch public="1" set="method" line="158"><f a="batch">
	<c path="phoenix.Batcher"/>
	<x path="Void"/>
</f></remove_batch>
		<clear public="1" set="method" line="163"><f a="_color">
	<c path="phoenix.Color"/>
	<x path="Void"/>
</f></clear>
		<_debug set="method" line="178"><f a="v">
	<d/>
	<x path="Void"/>
</f></_debug>
		<load_font public="1" set="method" line="182"><f a="_fontid:?_path:?_onloaded" v=":'assets/':null">
	<c path="String"/>
	<c path="String"/>
	<f a="">
		<c path="phoenix.BitmapFont"/>
		<x path="Void"/>
	</f>
	<c path="phoenix.BitmapFont"/>
</f></load_font>
		<load_shader public="1" set="method" line="193"><f a="_psid:?_vsid:?_onloaded" v=":null:null">
	<c path="String"/>
	<c path="String"/>
	<f a="">
		<c path="phoenix.Shader"/>
		<x path="Void"/>
	</f>
	<c path="phoenix.Shader"/>
</f></load_shader>
		<load_texture_from_string_byte_array public="1" set="method" line="245"><f a="?_name:_string_byte_array:_width:_height" v="'untitled texture':::">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="phoenix.Texture"/>
</f></load_texture_from_string_byte_array>
		<load_textures public="1" set="method" line="290"><f a="_names:?_onloaded:?_silent" v=":null:false">
	<c path="Array"><c path="String"/></c>
	<f a="">
		<c path="Array"><c path="phoenix.Texture"/></c>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Void"/>
</f></load_textures>
		<load_texture public="1" set="method" line="309"><f a="_name:?_onloaded:?_silent:?asset_bytes" v=":null:false:null">
	<c path="String"/>
	<f a="">
		<c path="phoenix.Texture"/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<t path="lime.utils.ByteArray"/>
	<c path="phoenix.Texture"/>
</f></load_texture>
		<process public="1" set="method" line="425"><f a=""><x path="Void"/></f></process>
		<onresize public="1" set="method" line="446"><f a="e">
	<d/>
	<x path="Void"/>
</f></onresize>
		<new public="1" set="method" line="66"><f a="_core">
	<c path="luxe.Core"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.RendererStats" params="" file="/Users/sven/dev/luxe/luxe/phoenix/Renderer.hx" module="phoenix.Renderer">
		<batchers public="1"><x path="Int"/></batchers>
		<geometry_count public="1"><x path="Int"/></geometry_count>
		<dynamic_batched_count public="1"><x path="Int"/></dynamic_batched_count>
		<static_batched_count public="1"><x path="Int"/></static_batched_count>
		<visible_count public="1"><x path="Int"/></visible_count>
		<draw_calls public="1"><x path="Int"/></draw_calls>
		<group_count public="1"><x path="Int"/></group_count>
		<reset public="1" set="method" line="464"><f a=""><x path="Void"/></f></reset>
		<toString public="1" set="method" line="472"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="455"><f a=""><x path="Void"/></f></new>
	</class>
	<enum path="phoenix.UniformValueType" params="" file="/Users/sven/dev/luxe/luxe/phoenix/Shader.hx" module="phoenix.Shader">
		<int/>
		<float/>
		<vector2/>
		<vector3/>
		<vector4/>
		<color/>
		<texture/>
		<unknown/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<typedef path="phoenix.UniformValue" params="T" file="/Users/sven/dev/luxe/luxe/phoenix/Shader.hx" module="phoenix.Shader"><a>
	<value><c path="phoenix.UniformValue.T"/></value>
	<type><e path="phoenix.UniformValueType"/></type>
	<name><c path="String"/></name>
	<location><t path="lime.gl.GLUniformLocation"/></location>
</a></typedef>
	<class path="phoenix.Shader" params="" file="/Users/sven/dev/luxe/luxe/phoenix/Shader.hx">
		<extends path="luxe.Resource"/>
		<errors public="1"><c path="String"/></errors>
		<log public="1"><c path="String"/></log>
		<vert_shader public="1"><c path="lime.gl.GLShader"/></vert_shader>
		<frag_shader public="1"><c path="lime.gl.GLShader"/></frag_shader>
		<program public="1"><c path="lime.gl.GLProgram"/></program>
		<shader public="1"><c path="lime.gl.GLShader"/></shader>
		<vert_attribute public="1"><x path="Int"/></vert_attribute>
		<tcoord_attribute public="1"><x path="Int"/></tcoord_attribute>
		<color_attribute public="1"><x path="Int"/></color_attribute>
		<normal_attribute public="1"><x path="Int"/></normal_attribute>
		<projectionmatrix_attribute public="1"><t path="lime.gl.GLUniformLocation"/></projectionmatrix_attribute>
		<modelviewmatrix_attribute public="1"><t path="lime.gl.GLUniformLocation"/></modelviewmatrix_attribute>
		<tex0_attribute public="1"><t path="lime.gl.GLUniformLocation"/></tex0_attribute>
		<tex1_attribute public="1"><t path="lime.gl.GLUniformLocation"/></tex1_attribute>
		<tex2_attribute public="1"><t path="lime.gl.GLUniformLocation"/></tex2_attribute>
		<tex3_attribute public="1"><t path="lime.gl.GLUniformLocation"/></tex3_attribute>
		<tex4_attribute public="1"><t path="lime.gl.GLUniformLocation"/></tex4_attribute>
		<tex5_attribute public="1"><t path="lime.gl.GLUniformLocation"/></tex5_attribute>
		<tex6_attribute public="1"><t path="lime.gl.GLUniformLocation"/></tex6_attribute>
		<tex7_attribute public="1"><t path="lime.gl.GLUniformLocation"/></tex7_attribute>
		<uniforms public="1"><x path="Map">
	<c path="String"/>
	<t path="phoenix.UniformValue"><d/></t>
</x></uniforms>
		<uniform_textures><x path="Map">
	<c path="String"/>
	<c path="phoenix.Texture"/>
</x></uniform_textures>
		<activate public="1" set="method" line="71"><f a=""><x path="Void"/></f></activate>
		<deactivate public="1" set="method" line="80"><f a=""><x path="Void"/></f></deactivate>
		<set_uniform_int public="1" set="method" line="84"><f a="_name:_value">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set_uniform_int>
		<set_uniform_float public="1" set="method" line="100"><f a="_name:_value">
	<c path="String"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set_uniform_float>
		<set_uniform_vector2 public="1" set="method" line="117"><f a="_name:_value">
	<c path="String"/>
	<c path="phoenix.Vector"/>
	<x path="Void"/>
</f></set_uniform_vector2>
		<set_uniform_vector3 public="1" set="method" line="137"><f a="_name:_value">
	<c path="String"/>
	<c path="phoenix.Vector"/>
	<x path="Void"/>
</f></set_uniform_vector3>
		<set_uniform_vector4 public="1" set="method" line="159"><f a="_name:_value">
	<c path="String"/>
	<c path="phoenix.Vector"/>
	<x path="Void"/>
</f></set_uniform_vector4>
		<set_uniform_color public="1" set="method" line="181"><f a="_name:_value">
	<c path="String"/>
	<c path="phoenix.Color"/>
	<x path="Void"/>
</f></set_uniform_color>
		<set_uniform_texture public="1" set="method" line="203"><f a="_name:_value">
	<c path="String"/>
	<c path="phoenix.Texture"/>
	<x path="Void"/>
</f></set_uniform_texture>
		<compile public="1" set="method" line="225"><f a="_type:_source:?_verbose" v="::false">
	<x path="Int"/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="lime.gl.GLShader"/>
</f></compile>
		<link public="1" set="method" line="270"><f a=""><c path="lime.gl.GLProgram"/></f></link>
		<drop public="1" set="method" line="319" override="1"><f a=""><x path="Void"/></f></drop>
		<destroy public="1" set="method" line="324"><f a=""><x path="Void"/></f></destroy>
		<load_from_string public="1" set="method" line="331"><f a="_vertex_source:_fragment_source:?_verbose" v="::false">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></load_from_string>
		<apply_uniforms public="1" set="method" line="374">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</apply_uniforms>
		<getUniform public="1" set="method" line="408">
			<f a="uniform_name">
				<c path="String"/>
				<t path="lime.gl.GLUniformLocation"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</getUniform>
		<setUniformInt public="1" set="method" line="412">
			<f a="uniform_name:value:?location" v="::null">
				<c path="String"/>
				<x path="Int"/>
				<t path="lime.gl.GLUniformLocation"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</setUniformInt>
		<setUniformFloat public="1" set="method" line="415">
			<f a="uniform_name:value:?location" v="::null">
				<c path="String"/>
				<x path="Float"/>
				<t path="lime.gl.GLUniformLocation"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</setUniformFloat>
		<setUniformVector2 public="1" set="method" line="418">
			<f a="uniform_name:value:?location" v="::null">
				<c path="String"/>
				<c path="phoenix.Vector"/>
				<t path="lime.gl.GLUniformLocation"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</setUniformVector2>
		<setUniformVector3 public="1" set="method" line="421">
			<f a="uniform_name:value:?location" v="::null">
				<c path="String"/>
				<c path="phoenix.Vector"/>
				<t path="lime.gl.GLUniformLocation"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</setUniformVector3>
		<setUniformVector4 public="1" set="method" line="424">
			<f a="uniform_name:value:?location" v="::null">
				<c path="String"/>
				<c path="phoenix.Vector"/>
				<t path="lime.gl.GLUniformLocation"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</setUniformVector4>
		<setUniformColor public="1" set="method" line="427">
			<f a="uniform_name:value:?location" v="::null">
				<c path="String"/>
				<c path="phoenix.Color"/>
				<t path="lime.gl.GLUniformLocation"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</setUniformColor>
		<setUniformTexture public="1" set="method" line="430">
			<f a="uniform_name:value:?location" v="::null">
				<c path="String"/>
				<c path="phoenix.Texture"/>
				<t path="lime.gl.GLUniformLocation"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</setUniformTexture>
		<addLog public="1" set="method" line="436"><f a="_log">
	<c path="String"/>
	<x path="Void"/>
</f></addLog>
		<addError public="1" set="method" line="440"><f a="_error">
	<c path="String"/>
	<x path="Void"/>
</f></addError>
		<new public="1" set="method" line="63"><f a="_manager">
	<c path="luxe.ResourceManager"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="phoenix.FilterType" params="" file="/Users/sven/dev/luxe/luxe/phoenix/Texture.hx" module="phoenix.Texture">
		<nearest/>
		<linear/>
		<mip_nearest_nearest/>
		<mip_linear_nearest/>
		<mip_nearest_linear/>
		<mip_linear_linear/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="phoenix.ClampType" params="" file="/Users/sven/dev/luxe/luxe/phoenix/Texture.hx" module="phoenix.Texture">
		<edge/>
		<repeat/>
		<mirror/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="phoenix.Vector" params="" file="/Users/sven/dev/luxe/luxe/phoenix/Vector.hx">
		<Add public="1" set="method" line="119" static="1"><f a="a:b">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></Add>
		<Subtract public="1" set="method" line="127" static="1"><f a="a:b">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></Subtract>
		<MultiplyVector public="1" set="method" line="135" static="1"><f a="a:b">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></MultiplyVector>
		<DivideVector public="1" set="method" line="143" static="1"><f a="a:b">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></DivideVector>
		<Multiply public="1" set="method" line="151" static="1"><f a="a:b">
	<c path="phoenix.Vector"/>
	<x path="Float"/>
	<c path="phoenix.Vector"/>
</f></Multiply>
		<Divide public="1" set="method" line="159" static="1"><f a="a:b">
	<c path="phoenix.Vector"/>
	<x path="Float"/>
	<c path="phoenix.Vector"/>
</f></Divide>
		<AddScalar public="1" set="method" line="167" static="1"><f a="a:b">
	<c path="phoenix.Vector"/>
	<x path="Float"/>
	<c path="phoenix.Vector"/>
</f></AddScalar>
		<SubtractScalar public="1" set="method" line="175" static="1"><f a="a:b">
	<c path="phoenix.Vector"/>
	<x path="Float"/>
	<c path="phoenix.Vector"/>
</f></SubtractScalar>
		<Cross public="1" set="method" line="183" static="1"><f a="a:b">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></Cross>
		<RotationTo public="1" set="method" line="191" static="1"><f a="a:b">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
	<x path="Float"/>
</f></RotationTo>
		<ToDegrees public="1" set="method" line="612" static="1"><f a="_radian_vector">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></ToDegrees>
		<ToRadians public="1" set="method" line="616" static="1"><f a="_degree_vector">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></ToRadians>
		<x public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</x>
		<y public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</y>
		<z public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</z>
		<w public="1">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</w>
		<length public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</length>
		<lengthsq public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</lengthsq>
		<angle2D public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</angle2D>
		<normalized public="1" get="accessor" set="null">
			<c path="phoenix.Vector"/>
			<meta><m n=":isVar"/></meta>
		</normalized>
		<inverted public="1" get="accessor" set="null">
			<c path="phoenix.Vector"/>
			<meta><m n=":isVar"/></meta>
		</inverted>
		<serialized public="1" get="accessor" set="null">
			<d/>
			<meta><m n=":isVar"/></meta>
		</serialized>
		<get_serialized set="method" line="20"><f a=""><d/></f></get_serialized>
		<ignore_listeners public="1"><x path="Bool"/></ignore_listeners>
		<listen_x public="1">
			<f a="">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":isVar"/></meta>
		</listen_x>
		<listen_y public="1">
			<f a="">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":isVar"/></meta>
		</listen_y>
		<listen_z public="1">
			<f a="">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":isVar"/></meta>
		</listen_z>
		<copy_from public="1" set="method" line="37"><f a="_other">
	<c path="phoenix.Vector"/>
	<x path="Void"/>
</f></copy_from>
		<set_xyz public="1" set="method" line="44"><f a="_x:_y:_z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set_xyz>
		<set_xyzw public="1" set="method" line="49"><f a="_x:_y:_z:_w">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set_xyzw>
		<set_xy public="1" set="method" line="56"><f a="_x:_y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set_xy>
		<set public="1" set="method" line="61"><f a="?_x:?_y:?_z:?_w" v="null:null:null:null">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="phoenix.Vector"/>
</f></set>
		<toString public="1" set="method" line="83"><f a=""><c path="String"/></f></toString>
		<equals public="1" set="method" line="87"><f a="other">
	<c path="phoenix.Vector"/>
	<x path="Bool"/>
</f></equals>
		<clone public="1" set="method" line="91"><f a=""><c path="phoenix.Vector"/></f></clone>
		<normalize public="1" set="method" line="95"><f a=""><c path="phoenix.Vector"/></f></normalize>
		<dot public="1" set="method" line="100"><f a="other">
	<c path="phoenix.Vector"/>
	<x path="Float"/>
</f></dot>
		<cross public="1" set="method" line="107"><f a="a:b">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></cross>
		<add public="1" set="method" line="197"><f a="other">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></add>
		<subtract public="1" set="method" line="211"><f a="other">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></subtract>
		<multiply public="1" set="method" line="225"><f a="other">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></multiply>
		<divide public="1" set="method" line="239"><f a="other">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></divide>
		<addScalar public="1" set="method" line="253"><f a="v">
	<x path="Float"/>
	<c path="phoenix.Vector"/>
</f></addScalar>
		<subtractScalar public="1" set="method" line="263"><f a="v">
	<x path="Float"/>
	<c path="phoenix.Vector"/>
</f></subtractScalar>
		<multiplyScalar public="1" set="method" line="273"><f a="v">
	<x path="Float"/>
	<c path="phoenix.Vector"/>
</f></multiplyScalar>
		<divideScalar public="1" set="method" line="283"><f a="v">
	<x path="Float"/>
	<c path="phoenix.Vector"/>
</f></divideScalar>
		<set_length set="method" line="302"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_length>
		<get_length set="method" line="310"><f a=""><x path="Float"/></f></get_length>
		<get_lengthsq set="method" line="317"><f a=""><x path="Float"/></f></get_lengthsq>
		<get_normalized set="method" line="323"><f a=""><c path="phoenix.Vector"/></f></get_normalized>
		<set_x set="method" line="329"><f a="_x">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y set="method" line="339"><f a="_y">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<set_z set="method" line="349"><f a="_z">
	<x path="Float"/>
	<x path="Float"/>
</f></set_z>
		<get_inverted set="method" line="359"><f a=""><c path="phoenix.Vector"/></f></get_inverted>
		<set_angle2D set="method" line="368"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_angle2D>
		<get_angle2D set="method" line="379"><f a=""><x path="Float"/></f></get_angle2D>
		<truncate public="1" set="method" line="390"><f a="max">
	<x path="Float"/>
	<c path="phoenix.Vector"/>
</f></truncate>
		<rotationTo public="1" set="method" line="398"><f a="other">
	<c path="phoenix.Vector"/>
	<x path="Float"/>
</f></rotationTo>
		<applyQuaternion public="1" set="method" line="406"><f a="q">
	<c path="phoenix.Quaternion"/>
	<c path="phoenix.Vector"/>
</f></applyQuaternion>
		<applyProjection public="1" set="method" line="426"><f a="m">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Vector"/>
</f></applyProjection>
		<applyMatrix4 public="1" set="method" line="440"><f a="_m">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Vector"/>
</f></applyMatrix4>
		<transformDirection public="1" set="method" line="456"><f a="m">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Vector"/>
</f></transformDirection>
		<setEulerFromRotationMatrix public="1" set="method" line="471"><f a="m:?order" v=":'XYZ'">
	<c path="phoenix.Matrix4"/>
	<c path="String"/>
	<c path="phoenix.Vector"/>
</f></setEulerFromRotationMatrix>
		<setEulerFromQuaternion public="1" set="method" line="557"><f a="q:?order" v=":'XYZ'">
	<c path="phoenix.Quaternion"/>
	<c path="String"/>
	<c path="phoenix.Vector"/>
</f></setEulerFromQuaternion>
		<toDegrees public="1" set="method" line="594"><f a=""><c path="phoenix.Vector"/></f></toDegrees>
		<toRadians public="1" set="method" line="603"><f a=""><c path="phoenix.Vector"/></f></toRadians>
		<new public="1" set="method" line="28"><f a="?_x:?_y:?_z:?_w" v="0:0:0:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<abstract path="phoenix.Vec" params="" file="/Users/sven/dev/luxe/luxe/phoenix/Vector.hx" module="phoenix.Vector">
		<from><icast><c path="phoenix.Vector"/></icast></from>
		<this><c path="phoenix.Vector"/></this>
		<to><icast><c path="phoenix.Vector"/></icast></to>
		<impl><class path="phoenix._Vector.Vec_Impl_" params="" file="/Users/sven/dev/luxe/luxe/phoenix/Vector.hx" private="1" module="phoenix.Vector">
	<_new public="1" get="inline" set="null" line="626" static="1">
		<f a="?_x:?_y:?_z:?_w" v="null:null:null:null">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<c path="phoenix.Vector"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<_multiply public="1" set="method" line="630" static="1">
		<f a="lhs:rhs">
			<x path="phoenix.Vec"/>
			<x path="phoenix.Vec"/>
			<x path="phoenix.Vec"/>
		</f>
		<meta>
			<m n=":communitative"/>
			<m n=":op"><e>A*B</e></m>
		</meta>
	</_multiply>
	<_multiply_scalar public="1" set="method" line="633" static="1">
		<f a="lhs:rhs">
			<x path="phoenix.Vec"/>
			<x path="Float"/>
			<x path="phoenix.Vec"/>
		</f>
		<meta>
			<m n=":communitative"/>
			<m n=":op"><e>A*B</e></m>
		</meta>
	</_multiply_scalar>
	<_multiply_scalar_int public="1" set="method" line="636" static="1">
		<f a="lhs:rhs">
			<x path="phoenix.Vec"/>
			<x path="Int"/>
			<x path="phoenix.Vec"/>
		</f>
		<meta>
			<m n=":communitative"/>
			<m n=":op"><e>A*B</e></m>
		</meta>
	</_multiply_scalar_int>
	<_divide public="1" set="method" line="640" static="1">
		<f a="lhs:rhs">
			<x path="phoenix.Vec"/>
			<x path="phoenix.Vec"/>
			<x path="phoenix.Vec"/>
		</f>
		<meta>
			<m n=":communitative"/>
			<m n=":op"><e>A/B</e></m>
		</meta>
	</_divide>
	<_divide_scalar public="1" set="method" line="643" static="1">
		<f a="lhs:rhs">
			<x path="phoenix.Vec"/>
			<x path="Float"/>
			<x path="phoenix.Vec"/>
		</f>
		<meta>
			<m n=":communitative"/>
			<m n=":op"><e>A/B</e></m>
		</meta>
	</_divide_scalar>
	<_divide_scalar_int public="1" set="method" line="646" static="1">
		<f a="lhs:rhs">
			<x path="phoenix.Vec"/>
			<x path="Int"/>
			<x path="phoenix.Vec"/>
		</f>
		<meta>
			<m n=":communitative"/>
			<m n=":op"><e>A/B</e></m>
		</meta>
	</_divide_scalar_int>
	<_add public="1" set="method" line="650" static="1">
		<f a="lhs:rhs">
			<x path="phoenix.Vec"/>
			<x path="phoenix.Vec"/>
			<x path="phoenix.Vec"/>
		</f>
		<meta>
			<m n=":communitative"/>
			<m n=":op"><e>A+B</e></m>
		</meta>
	</_add>
	<_add_scalar public="1" set="method" line="653" static="1">
		<f a="lhs:rhs">
			<x path="phoenix.Vec"/>
			<x path="Float"/>
			<x path="phoenix.Vec"/>
		</f>
		<meta>
			<m n=":communitative"/>
			<m n=":op"><e>A+B</e></m>
		</meta>
	</_add_scalar>
	<_add_scalar_int public="1" set="method" line="656" static="1">
		<f a="lhs:rhs">
			<x path="phoenix.Vec"/>
			<x path="Int"/>
			<x path="phoenix.Vec"/>
		</f>
		<meta>
			<m n=":communitative"/>
			<m n=":op"><e>A+B</e></m>
		</meta>
	</_add_scalar_int>
	<_subtract public="1" set="method" line="660" static="1">
		<f a="lhs:rhs">
			<x path="phoenix.Vec"/>
			<x path="phoenix.Vec"/>
			<x path="phoenix.Vec"/>
		</f>
		<meta>
			<m n=":communitative"/>
			<m n=":op"><e>A-B</e></m>
		</meta>
	</_subtract>
	<_subtract_scalar public="1" set="method" line="663" static="1">
		<f a="lhs:rhs">
			<x path="phoenix.Vec"/>
			<x path="Float"/>
			<x path="phoenix.Vec"/>
		</f>
		<meta>
			<m n=":communitative"/>
			<m n=":op"><e>A-B</e></m>
		</meta>
	</_subtract_scalar>
	<_subtract_scalar_int public="1" set="method" line="666" static="1">
		<f a="lhs:rhs">
			<x path="phoenix.Vec"/>
			<x path="Int"/>
			<x path="phoenix.Vec"/>
		</f>
		<meta>
			<m n=":communitative"/>
			<m n=":op"><e>A-B</e></m>
		</meta>
	</_subtract_scalar_int>
</class></impl>
	</abstract>
	<class path="phoenix._Vector.Vec_Impl_" params="" file="/Users/sven/dev/luxe/luxe/phoenix/Vector.hx" private="1" module="phoenix.Vector">
		<_new public="1" get="inline" set="null" line="626" static="1">
			<f a="?_x:?_y:?_z:?_w" v="null:null:null:null">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="phoenix.Vector"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<_multiply public="1" set="method" line="630" static="1">
			<f a="lhs:rhs">
				<x path="phoenix.Vec"/>
				<x path="phoenix.Vec"/>
				<x path="phoenix.Vec"/>
			</f>
			<meta>
				<m n=":communitative"/>
				<m n=":op"><e>A*B</e></m>
			</meta>
		</_multiply>
		<_multiply_scalar public="1" set="method" line="633" static="1">
			<f a="lhs:rhs">
				<x path="phoenix.Vec"/>
				<x path="Float"/>
				<x path="phoenix.Vec"/>
			</f>
			<meta>
				<m n=":communitative"/>
				<m n=":op"><e>A*B</e></m>
			</meta>
		</_multiply_scalar>
		<_multiply_scalar_int public="1" set="method" line="636" static="1">
			<f a="lhs:rhs">
				<x path="phoenix.Vec"/>
				<x path="Int"/>
				<x path="phoenix.Vec"/>
			</f>
			<meta>
				<m n=":communitative"/>
				<m n=":op"><e>A*B</e></m>
			</meta>
		</_multiply_scalar_int>
		<_divide public="1" set="method" line="640" static="1">
			<f a="lhs:rhs">
				<x path="phoenix.Vec"/>
				<x path="phoenix.Vec"/>
				<x path="phoenix.Vec"/>
			</f>
			<meta>
				<m n=":communitative"/>
				<m n=":op"><e>A/B</e></m>
			</meta>
		</_divide>
		<_divide_scalar public="1" set="method" line="643" static="1">
			<f a="lhs:rhs">
				<x path="phoenix.Vec"/>
				<x path="Float"/>
				<x path="phoenix.Vec"/>
			</f>
			<meta>
				<m n=":communitative"/>
				<m n=":op"><e>A/B</e></m>
			</meta>
		</_divide_scalar>
		<_divide_scalar_int public="1" set="method" line="646" static="1">
			<f a="lhs:rhs">
				<x path="phoenix.Vec"/>
				<x path="Int"/>
				<x path="phoenix.Vec"/>
			</f>
			<meta>
				<m n=":communitative"/>
				<m n=":op"><e>A/B</e></m>
			</meta>
		</_divide_scalar_int>
		<_add public="1" set="method" line="650" static="1">
			<f a="lhs:rhs">
				<x path="phoenix.Vec"/>
				<x path="phoenix.Vec"/>
				<x path="phoenix.Vec"/>
			</f>
			<meta>
				<m n=":communitative"/>
				<m n=":op"><e>A+B</e></m>
			</meta>
		</_add>
		<_add_scalar public="1" set="method" line="653" static="1">
			<f a="lhs:rhs">
				<x path="phoenix.Vec"/>
				<x path="Float"/>
				<x path="phoenix.Vec"/>
			</f>
			<meta>
				<m n=":communitative"/>
				<m n=":op"><e>A+B</e></m>
			</meta>
		</_add_scalar>
		<_add_scalar_int public="1" set="method" line="656" static="1">
			<f a="lhs:rhs">
				<x path="phoenix.Vec"/>
				<x path="Int"/>
				<x path="phoenix.Vec"/>
			</f>
			<meta>
				<m n=":communitative"/>
				<m n=":op"><e>A+B</e></m>
			</meta>
		</_add_scalar_int>
		<_subtract public="1" set="method" line="660" static="1">
			<f a="lhs:rhs">
				<x path="phoenix.Vec"/>
				<x path="phoenix.Vec"/>
				<x path="phoenix.Vec"/>
			</f>
			<meta>
				<m n=":communitative"/>
				<m n=":op"><e>A-B</e></m>
			</meta>
		</_subtract>
		<_subtract_scalar public="1" set="method" line="663" static="1">
			<f a="lhs:rhs">
				<x path="phoenix.Vec"/>
				<x path="Float"/>
				<x path="phoenix.Vec"/>
			</f>
			<meta>
				<m n=":communitative"/>
				<m n=":op"><e>A-B</e></m>
			</meta>
		</_subtract_scalar>
		<_subtract_scalar_int public="1" set="method" line="666" static="1">
			<f a="lhs:rhs">
				<x path="phoenix.Vec"/>
				<x path="Int"/>
				<x path="phoenix.Vec"/>
			</f>
			<meta>
				<m n=":communitative"/>
				<m n=":op"><e>A-B</e></m>
			</meta>
		</_subtract_scalar_int>
	</class>
	<class path="phoenix.defaults.FontBytes" params="" file="/Users/sven/dev/luxe/luxe/phoenix/defaults/FontBytes.hx"><data public="1" set="method" line="5" static="1"><f a=""><c path="String"/></f></data></class>
	<class path="phoenix.defaults.FontString" params="" file="/Users/sven/dev/luxe/luxe/phoenix/defaults/FontString.hx"><data public="1" set="method" line="5" static="1"><f a=""><c path="String"/></f></data></class>
	<class path="phoenix.defaults.Shaders" params="" file="/Users/sven/dev/luxe/luxe/phoenix/defaults/Shaders.hx">
		<vertex_shader public="1" set="method" line="5" static="1"><f a=""><c path="String"/></f></vertex_shader>
		<fragment_textured public="1" set="method" line="36" static="1"><f a=""><c path="String"/></f></fragment_textured>
		<fragment_untextured public="1" set="method" line="66" static="1"><f a=""><c path="String"/></f></fragment_untextured>
	</class>
	<class path="phoenix.geometry.Geometry" params="" file="/Users/sven/dev/luxe/luxe/phoenix/geometry/Geometry.hx">
		<vertices public="1"><c path="Array"><c path="phoenix.geometry.Vertex"/></c></vertices>
		<submitted public="1"><x path="Bool"/></submitted>
		<static_vertex_buffer public="1"><c path="lime.gl.GLBuffer"/></static_vertex_buffer>
		<static_tcoord_buffer public="1"><c path="lime.gl.GLBuffer"/></static_tcoord_buffer>
		<static_vcolor_buffer public="1"><c path="lime.gl.GLBuffer"/></static_vcolor_buffer>
		<static_normal_buffer public="1"><c path="lime.gl.GLBuffer"/></static_normal_buffer>
		<added public="1"><x path="Bool"/></added>
		<batchers public="1"><c path="Array"><c path="phoenix.Batcher"/></c></batchers>
		<state public="1"><c path="phoenix.geometry.GeometryState"/></state>
		<dropped public="1"><x path="Bool"/></dropped>
		<uuid public="1"><c path="String"/></uuid>
		<id public="1"><c path="String"/></id>
		<primitive_type public="1" get="accessor" set="accessor">
			<e path="phoenix.PrimitiveType"/>
			<meta><m n=":isVar"/></meta>
		</primitive_type>
		<texture public="1" get="accessor" set="accessor">
			<c path="phoenix.Texture"/>
			<meta><m n=":isVar"/></meta>
		</texture>
		<shader public="1" get="accessor" set="accessor">
			<c path="phoenix.Shader"/>
			<meta><m n=":isVar"/></meta>
		</shader>
		<depth public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</depth>
		<group public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":isVar"/></meta>
		</group>
		<clip public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</clip>
		<clip_rect public="1" get="accessor" set="accessor">
			<c path="phoenix.Rectangle"/>
			<meta><m n=":isVar"/></meta>
		</clip_rect>
		<shadow_primitive_type><e path="phoenix.PrimitiveType"/></shadow_primitive_type>
		<shadow_texture><c path="phoenix.Texture"/></shadow_texture>
		<shadow_shader><c path="phoenix.Shader"/></shadow_shader>
		<shadow_group><x path="Int"/></shadow_group>
		<shadow_depth><x path="Float"/></shadow_depth>
		<shadow_clip><x path="Bool"/></shadow_clip>
		<dirty_primitive_type><x path="Bool"/></dirty_primitive_type>
		<dirty_texture><x path="Bool"/></dirty_texture>
		<dirty_shader><x path="Bool"/></dirty_shader>
		<dirty_group><x path="Bool"/></dirty_group>
		<dirty_depth><x path="Bool"/></dirty_depth>
		<dirty_clip><x path="Bool"/></dirty_clip>
		<visible public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</visible>
		<locked public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</locked>
		<dirty public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</dirty>
		<immediate public="1">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</immediate>
		<color public="1" set="accessor">
			<c path="phoenix.Color"/>
			<meta><m n=":isVar"/></meta>
		</color>
		<pos public="1" get="accessor" set="accessor">
			<c path="phoenix.Vector"/>
			<meta><m n=":isVar"/></meta>
		</pos>
		<rotation public="1" get="accessor" set="accessor">
			<c path="phoenix.Quaternion"/>
			<meta><m n=":isVar"/></meta>
		</rotation>
		<scale public="1" get="accessor" set="accessor">
			<c path="phoenix.Vector"/>
			<meta><m n=":isVar"/></meta>
		</scale>
		<_pos_dirty><x path="Bool"/></_pos_dirty>
		<_rotation_dirty><x path="Bool"/></_rotation_dirty>
		<_scale_dirty><x path="Bool"/></_scale_dirty>
		<origin public="1" set="accessor">
			<c path="phoenix.Vector"/>
			<meta><m n=":isVar"/></meta>
		</origin>
		<matrix public="1"><c path="phoenix.Matrix4"/></matrix>
		<_final_vert_position><c path="phoenix.Vector"/></_final_vert_position>
		<key public="1"><t path="phoenix.geometry.GeometryKey"/></key>
		<key_string public="1" set="method" line="163"><f a=""><c path="String"/></f></key_string>
		<refresh_key public="1" set="method" line="174"><f a=""><x path="Void"/></f></refresh_key>
		<short_id public="1" set="method" line="185"><f a=""><c path="String"/></f></short_id>
		<str public="1" set="method" line="191"><f a=""><x path="Void"/></f></str>
		<drop public="1" set="method" line="199"><f a="?remove" v="true">
	<x path="Bool"/>
	<x path="Void"/>
</f></drop>
		<add public="1" set="method" line="213"><f a="v">
	<c path="phoenix.geometry.Vertex"/>
	<x path="Void"/>
</f></add>
		<remove public="1" set="method" line="219"><f a="v">
	<c path="phoenix.geometry.Vertex"/>
	<x path="Void"/>
</f></remove>
		<batch_into_float32array public="1" set="method" line="225"><f a="vert_index:tcoord_index:color_index:normal_index:vertlist:tcoordlist:colorlist:normallist">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.Float32Array"/>
	<c path="lime.utils.Float32Array"/>
	<c path="lime.utils.Float32Array"/>
	<c path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></batch_into_float32array>
		<batch public="1" set="method" line="281"><f a="vertlist:tcoordlist:colorlist:normallist">
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></batch>
		<translate public="1" set="method" line="336"><f a="_offset">
	<c path="phoenix.Vector"/>
	<x path="Void"/>
</f></translate>
		<set_origin public="1" set="method" line="342"><f a="_origin">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></set_origin>
		<set_pos public="1" set="method" line="348"><f a="_position">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></set_pos>
		<get_pos public="1" set="method" line="355"><f a=""><c path="phoenix.Vector"/></f></get_pos>
		<set_locked public="1" set="method" line="361"><f a="_locked">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_locked>
		<get_locked public="1" set="method" line="367"><f a=""><x path="Bool"/></f></get_locked>
		<set_dirty public="1" set="method" line="373"><f a="_dirty">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_dirty>
		<get_dirty public="1" set="method" line="379"><f a=""><x path="Bool"/></f></get_dirty>
		<set_rotation public="1" set="method" line="385"><f a="_rotation">
	<c path="phoenix.Quaternion"/>
	<c path="phoenix.Quaternion"/>
</f></set_rotation>
		<get_rotation public="1" set="method" line="397"><f a=""><c path="phoenix.Quaternion"/></f></get_rotation>
		<set_scale public="1" set="method" line="403"><f a="_scale">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></set_scale>
		<get_scale public="1" set="method" line="415"><f a=""><c path="phoenix.Vector"/></f></get_scale>
		<refresh set="method" line="423"><f a=""><x path="Void"/></f></refresh>
		<get_primitive_type set="method" line="472"><f a=""><e path="phoenix.PrimitiveType"/></f></get_primitive_type>
		<set_primitive_type set="method" line="478"><f a="val">
	<e path="phoenix.PrimitiveType"/>
	<e path="phoenix.PrimitiveType"/>
</f></set_primitive_type>
		<get_texture public="1" set="method" line="492"><f a=""><c path="phoenix.Texture"/></f></get_texture>
		<set_texture public="1" set="method" line="498"><f a="val">
	<c path="phoenix.Texture"/>
	<c path="phoenix.Texture"/>
</f></set_texture>
		<set_visible public="1" set="method" line="512"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<set_color public="1" set="method" line="520"><f a="val">
	<c path="phoenix.Color"/>
	<c path="phoenix.Color"/>
</f></set_color>
		<get_shader public="1" set="method" line="532"><f a=""><c path="phoenix.Shader"/></f></get_shader>
		<set_shader public="1" set="method" line="538"><f a="val">
	<c path="phoenix.Shader"/>
	<c path="phoenix.Shader"/>
</f></set_shader>
		<get_depth public="1" set="method" line="552"><f a=""><x path="Float"/></f></get_depth>
		<set_depth public="1" set="method" line="559"><f a="val">
	<x path="Float"/>
	<x path="Float"/>
</f></set_depth>
		<get_group public="1" set="method" line="573"><f a=""><x path="Int"/></f></get_group>
		<set_group public="1" set="method" line="579"><f a="val">
	<x path="Int"/>
	<x path="Int"/>
</f></set_group>
		<get_clip public="1" set="method" line="593"><f a=""><x path="Bool"/></f></get_clip>
		<set_clip public="1" set="method" line="599"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_clip>
		<get_clip_rect public="1" set="method" line="613"><f a=""><c path="phoenix.Rectangle"/></f></get_clip_rect>
		<set_clip_rect public="1" set="method" line="619"><f a="val">
	<c path="phoenix.Rectangle"/>
	<c path="phoenix.Rectangle"/>
</f></set_clip_rect>
		<new public="1" set="method" line="102"><f a="options">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.geometry.CircleGeometry" params="" file="/Users/sven/dev/luxe/luxe/phoenix/geometry/CircleGeometry.hx">
		<extends path="phoenix.geometry.Geometry"/>
		<set public="1" set="method" line="61"><f a="_x:_y:_rx:_ry:_steps:?_start_angle:?_end_angle" v=":::::0:360">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set>
		<new public="1" set="method" line="12"><f a="options">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.geometry.ArcGeometry" params="" file="/Users/sven/dev/luxe/luxe/phoenix/geometry/ArcGeometry.hx">
		<extends path="phoenix.geometry.CircleGeometry"/>
		<new public="1" set="method" line="12"><f a="options">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="phoenix.geometry.ComplexQuad" params="" file="/Users/sven/dev/luxe/luxe/phoenix/geometry/ComplexGeometry.hx" module="phoenix.geometry.ComplexGeometry"><a>
	<verts><c path="Array"><c path="phoenix.geometry.Vertex"/></c></verts>
	<uuid><c path="String"/></uuid>
	<flipy><x path="Bool"/></flipy>
	<flipx><x path="Bool"/></flipx>
	<_uv_cache><c path="phoenix.Rectangle"/></_uv_cache>
</a></typedef>
	<class path="phoenix.geometry.ComplexGeometry" params="" file="/Users/sven/dev/luxe/luxe/phoenix/geometry/ComplexGeometry.hx">
		<extends path="phoenix.geometry.Geometry"/>
		<quads public="1"><x path="Map">
	<c path="String"/>
	<t path="phoenix.geometry.ComplexQuad"/>
</x></quads>
		<clear public="1" set="method" line="40"><f a=""><x path="Void"/></f></clear>
		<quad_add public="1" set="method" line="46"><f a="_options">
	<d/>
	<c path="String"/>
</f></quad_add>
		<quad_remove public="1" set="method" line="97"><f a="_quad_id">
	<c path="String"/>
	<x path="Void"/>
</f></quad_remove>
		<quad_hide public="1" set="method" line="119"><f a="_quad_id">
	<c path="String"/>
	<x path="Void"/>
</f></quad_hide>
		<quad_show public="1" set="method" line="140"><f a="_quad_id">
	<c path="String"/>
	<x path="Void"/>
</f></quad_show>
		<quad_resize public="1" set="method" line="160"><f a="_quad_id:_quad">
	<c path="String"/>
	<c path="phoenix.Rectangle"/>
	<x path="Void"/>
</f></quad_resize>
		<quad_pos public="1" set="method" line="181"><f a="_quad_id:_p">
	<c path="String"/>
	<c path="phoenix.Vector"/>
	<x path="Void"/>
</f></quad_pos>
		<quad_color public="1" set="method" line="215"><f a="_quad_id:_c">
	<c path="String"/>
	<c path="phoenix.Color"/>
	<x path="Void"/>
</f></quad_color>
		<quad_alpha public="1" set="method" line="230"><f a="_quad_id:_a">
	<c path="String"/>
	<x path="Float"/>
	<x path="Void"/>
</f></quad_alpha>
		<quad_uv_space public="1" set="method" line="245"><f a="_quad_id:_uv">
	<c path="String"/>
	<c path="phoenix.Rectangle"/>
	<x path="Void"/>
</f></quad_uv_space>
		<quad_uv public="1" set="method" line="323"><f a="_quad_id:_uv">
	<c path="String"/>
	<c path="phoenix.Rectangle"/>
	<x path="Void"/>
</f></quad_uv>
		<quad_flipx public="1" set="method" line="339"><f a="_quad_id:_flip">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></quad_flipx>
		<quad_flipy public="1" set="method" line="350"><f a="_quad_id:_flip">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></quad_flipy>
		<new public="1" set="method" line="31"><f a="_options">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.geometry.CompositeGeometry" params="" file="/Users/sven/dev/luxe/luxe/phoenix/geometry/CompositeGeometry.hx">
		<extends path="phoenix.geometry.Geometry"/>
		<geometry public="1"><c path="Array"><c path="phoenix.geometry.Geometry"/></c></geometry>
		<toString public="1" set="method" line="21"><f a=""><c path="String"/></f></toString>
		<clear public="1" set="method" line="25"><f a=""><x path="Void"/></f></clear>
		<replace public="1" set="method" line="32"><f a="_geometry">
	<c path="Array"><c path="phoenix.geometry.Geometry"/></c>
	<x path="Void"/>
</f></replace>
		<has_geometry public="1" set="method" line="41"><f a="g">
	<c path="phoenix.geometry.Geometry"/>
	<x path="Bool"/>
</f></has_geometry>
		<add_geometry public="1" set="method" line="47"><f a="g">
	<c path="phoenix.geometry.Geometry"/>
	<x path="Void"/>
</f></add_geometry>
		<remove_geometry public="1" set="method" line="53"><f a="g">
	<c path="phoenix.geometry.Geometry"/>
	<x path="Void"/>
</f></remove_geometry>
		<add_to_batcher public="1" set="method" line="59"><f a="_batcher">
	<c path="phoenix.Batcher"/>
	<x path="Void"/>
</f></add_to_batcher>
		<drop public="1" set="method" line="65" override="1"><f a="?remove" v="true">
	<x path="Bool"/>
	<x path="Void"/>
</f></drop>
		<translate public="1" set="method" line="75" override="1"><f a="_offset">
	<c path="phoenix.Vector"/>
	<x path="Void"/>
</f></translate>
		<set_origin public="1" set="method" line="83" override="1"><f a="_origin">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></set_origin>
		<set_pos public="1" set="method" line="92" override="1"><f a="_position">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></set_pos>
		<set_rotation public="1" set="method" line="101" override="1"><f a="_rotation">
	<c path="phoenix.Quaternion"/>
	<c path="phoenix.Quaternion"/>
</f></set_rotation>
		<set_color public="1" set="method" line="110" override="1"><f a="_color">
	<c path="phoenix.Color"/>
	<c path="phoenix.Color"/>
</f></set_color>
		<set_primitive_type public="1" set="method" line="119" override="1"><f a="val">
	<e path="phoenix.PrimitiveType"/>
	<e path="phoenix.PrimitiveType"/>
</f></set_primitive_type>
		<set_shader public="1" set="method" line="128" override="1"><f a="val">
	<c path="phoenix.Shader"/>
	<c path="phoenix.Shader"/>
</f></set_shader>
		<set_texture public="1" set="method" line="137" override="1"><f a="val">
	<c path="phoenix.Texture"/>
	<c path="phoenix.Texture"/>
</f></set_texture>
		<set_depth public="1" set="method" line="146" override="1"><f a="val">
	<x path="Float"/>
	<x path="Float"/>
</f></set_depth>
		<set_group public="1" set="method" line="155" override="1"><f a="val">
	<x path="Int"/>
	<x path="Int"/>
</f></set_group>
		<set_clip public="1" set="method" line="164" override="1"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_clip>
		<set_locked public="1" set="method" line="173" override="1"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_locked>
		<set_dirty public="1" set="method" line="182" override="1"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_dirty>
		<set_clip_rect public="1" set="method" line="191" override="1"><f a="val">
	<c path="phoenix.Rectangle"/>
	<c path="phoenix.Rectangle"/>
</f></set_clip_rect>
		<set_visible public="1" set="method" line="200" override="1"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<new public="1" set="method" line="13"><f a="?options" v="null">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="phoenix.geometry.GeometryKey" params="" file="/Users/sven/dev/luxe/luxe/phoenix/geometry/Geometry.hx" module="phoenix.geometry.Geometry"><a>
	<uuid><c path="String"/></uuid>
	<timestamp><x path="Float"/></timestamp>
	<texture><c path="phoenix.Texture"/></texture>
	<shader><c path="phoenix.Shader"/></shader>
	<primitive_type><e path="phoenix.PrimitiveType"/></primitive_type>
	<group><x path="Int"/></group>
	<depth><x path="Float"/></depth>
	<clip><x path="Bool"/></clip>
</a></typedef>
	<class path="phoenix.geometry.GeometryState" params="" file="/Users/sven/dev/luxe/luxe/phoenix/geometry/GeometryState.hx">
		<dirty public="1"><x path="Bool"/></dirty>
		<primitive_type public="1" set="accessor">
			<e path="phoenix.PrimitiveType"/>
			<meta><m n=":isVar"/></meta>
		</primitive_type>
		<shader public="1" set="accessor">
			<c path="phoenix.Shader"/>
			<meta><m n=":isVar"/></meta>
		</shader>
		<texture public="1" set="accessor">
			<c path="phoenix.Texture"/>
			<meta><m n=":isVar"/></meta>
		</texture>
		<depth public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</depth>
		<group public="1" set="accessor">
			<x path="Int"/>
			<meta><m n=":isVar"/></meta>
		</group>
		<clip public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</clip>
		<clip_rect public="1" set="accessor">
			<c path="phoenix.Rectangle"/>
			<meta><m n=":isVar"/></meta>
		</clip_rect>
		<log public="1"><x path="Bool"/></log>
		<clone_onto public="1" set="method" line="36"><f a="_other">
	<c path="phoenix.geometry.GeometryState"/>
	<x path="Void"/>
</f></clone_onto>
		<str public="1" set="method" line="49"><f a=""><x path="Void"/></f></str>
		<clean public="1" set="method" line="66"><f a=""><x path="Void"/></f></clean>
		<update public="1" set="method" line="71"><f a="other">
	<c path="phoenix.geometry.GeometryState"/>
	<x path="Void"/>
</f></update>
		<set_primitive_type public="1" set="method" line="106"><f a="val">
	<e path="phoenix.PrimitiveType"/>
	<e path="phoenix.PrimitiveType"/>
</f></set_primitive_type>
		<set_texture public="1" set="method" line="111"><f a="val">
	<c path="phoenix.Texture"/>
	<c path="phoenix.Texture"/>
</f></set_texture>
		<set_shader public="1" set="method" line="116"><f a="val">
	<c path="phoenix.Shader"/>
	<c path="phoenix.Shader"/>
</f></set_shader>
		<set_depth public="1" set="method" line="121"><f a="val">
	<x path="Float"/>
	<x path="Float"/>
</f></set_depth>
		<set_group public="1" set="method" line="125"><f a="val">
	<x path="Int"/>
	<x path="Int"/>
</f></set_group>
		<set_clip public="1" set="method" line="130"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_clip>
		<set_clip_rect public="1" set="method" line="135"><f a="val">
	<c path="phoenix.Rectangle"/>
	<c path="phoenix.Rectangle"/>
</f></set_clip_rect>
		<new public="1" set="method" line="22"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="phoenix.geometry.LineGeometry" params="" file="/Users/sven/dev/luxe/luxe/phoenix/geometry/LineGeometry.hx">
		<extends path="phoenix.geometry.Geometry"/>
		<p0 public="1" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</p0>
		<p1 public="1" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</p1>
		<set_p0 public="1" set="method" line="28"><f a="_p">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_p0>
		<set_p1 public="1" set="method" line="38"><f a="_p">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_p1>
		<set public="1" set="method" line="48"><f a="options">
	<d/>
	<x path="Void"/>
</f></set>
		<new public="1" set="method" line="13"><f a="options">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.geometry.PlaneGeometry" params="" file="/Users/sven/dev/luxe/luxe/phoenix/geometry/PlaneGeometry.hx">
		<extends path="phoenix.geometry.Geometry"/>
		<flipx public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</flipx>
		<flipy public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</flipy>
		<_uv_cache><t path="luxe.Rectangle"/></_uv_cache>
		<is_set><x path="Bool"/></is_set>
		<uv public="1" set="method" line="39"><f a="_rect">
	<t path="luxe.Rectangle"/>
	<x path="Void"/>
</f></uv>
		<uv_space public="1" set="method" line="55"><f a="_rect">
	<t path="luxe.Rectangle"/>
	<x path="Void"/>
</f></uv_space>
		<set public="1" set="method" line="124"><f a="quad:y">
	<t path="luxe.Rectangle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set>
		<set_flipx public="1" set="method" line="182"><f a="_val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_flipx>
		<set_flipy public="1" set="method" line="193"><f a="_val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_flipy>
		<new public="1" set="method" line="18"><f a="options">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.geometry.QuadGeometry" params="" file="/Users/sven/dev/luxe/luxe/phoenix/geometry/QuadGeometry.hx">
		<extends path="phoenix.geometry.Geometry"/>
		<flipx public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</flipx>
		<flipy public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</flipy>
		<_uv_cache><t path="luxe.Rectangle"/></_uv_cache>
		<is_set><x path="Bool"/></is_set>
		<uv public="1" set="method" line="39"><f a="_rect">
	<t path="luxe.Rectangle"/>
	<x path="Void"/>
</f></uv>
		<uv_space public="1" set="method" line="55"><f a="_rect">
	<t path="luxe.Rectangle"/>
	<x path="Void"/>
</f></uv_space>
		<resize public="1" set="method" line="124"><f a="quad">
	<t path="luxe.Vector"/>
	<x path="Void"/>
</f></resize>
		<set public="1" set="method" line="136"><f a="quad">
	<t path="luxe.Rectangle"/>
	<x path="Void"/>
</f></set>
		<set_flipx public="1" set="method" line="194"><f a="_val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_flipx>
		<set_flipy public="1" set="method" line="205"><f a="_val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_flipy>
		<new public="1" set="method" line="18"><f a="options">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.geometry.RectangleGeometry" params="" file="/Users/sven/dev/luxe/luxe/phoenix/geometry/RectangleGeometry.hx">
		<extends path="phoenix.geometry.Geometry"/>
		<set public="1" set="method" line="15"><f a="options">
	<d/>
	<x path="Void"/>
</f></set>
		<new public="1" set="method" line="10"><f a="options">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.geometry.RingGeometry" params="" file="/Users/sven/dev/luxe/luxe/phoenix/geometry/RingGeometry.hx">
		<extends path="phoenix.geometry.CircleGeometry"/>
		<new public="1" set="method" line="12"><f a="options">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.geometry.TextureCoordSet" params="" file="/Users/sven/dev/luxe/luxe/phoenix/geometry/TextureCoord.hx" module="phoenix.geometry.TextureCoord">
		<uv0 public="1"><c path="phoenix.geometry.TextureCoord"/></uv0>
		<uv1 public="1"><c path="phoenix.geometry.TextureCoord"/></uv1>
		<uv2 public="1"><c path="phoenix.geometry.TextureCoord"/></uv2>
		<uv3 public="1"><c path="phoenix.geometry.TextureCoord"/></uv3>
		<uv4 public="1"><c path="phoenix.geometry.TextureCoord"/></uv4>
		<uv5 public="1"><c path="phoenix.geometry.TextureCoord"/></uv5>
		<uv6 public="1"><c path="phoenix.geometry.TextureCoord"/></uv6>
		<uv7 public="1"><c path="phoenix.geometry.TextureCoord"/></uv7>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="phoenix.geometry.TextureCoord" params="" file="/Users/sven/dev/luxe/luxe/phoenix/geometry/TextureCoord.hx">
		<u public="1"><x path="Float"/></u>
		<v public="1"><x path="Float"/></v>
		<w public="1"><x path="Float"/></w>
		<t public="1"><x path="Float"/></t>
		<set public="1" set="method" line="42"><f a="?_u:?_v:?_w:?_t" v="null:null:null:null">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="phoenix.geometry.TextureCoord"/>
</f></set>
		<toString public="1" set="method" line="63"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="35"><f a="?_u:?_v:?_w:?_t" v="0.0f:0.0f:0.0f:0.0f">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.geometry.Vertex" params="" file="/Users/sven/dev/luxe/luxe/phoenix/geometry/Vertex.hx">
		<pos public="1"><c path="phoenix.Vector"/></pos>
		<color public="1"><c path="phoenix.Color"/></color>
		<uv public="1"><c path="phoenix.geometry.TextureCoordSet"/></uv>
		<normal public="1"><c path="phoenix.Vector"/></normal>
		<new public="1" set="method" line="16"><f a="_pos:?_normal:?_color" v=":null:null">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
	<c path="phoenix.Color"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.utils.Rendering" params="" file="/Users/sven/dev/luxe/luxe/phoenix/utils/Rendering.hx">
		<gl_blend_mode_from_BlendMode public="1" set="method" line="9" static="1"><f a="_b">
	<e path="phoenix.BlendMode"/>
	<x path="Int"/>
</f></gl_blend_mode_from_BlendMode>
		<get_elements_for_type public="1" set="method" line="38" static="1"><f a="type:length">
	<e path="phoenix.PrimitiveType"/>
	<x path="Int"/>
	<x path="Int"/>
</f></get_elements_for_type>
		<get_opengl_primitive_type public="1" set="method" line="58" static="1"><f a="type">
	<e path="phoenix.PrimitiveType"/>
	<x path="Int"/>
</f></get_opengl_primitive_type>
	</class>
	<typedef path="sys.FileStat" params="" file="/usr/lib/haxe/std/sys/FileStat.hx">
		<a>
			<uid>
				<x path="Int"/>
				<haxe_doc>the user id for the file</haxe_doc>
			</uid>
			<size>
				<x path="Int"/>
				<haxe_doc>the size of the file</haxe_doc>
			</size>
			<rdev><x path="Int"/></rdev>
			<nlink><x path="Int"/></nlink>
			<mtime>
				<c path="Date"/>
				<haxe_doc>the last modification time for the file</haxe_doc>
			</mtime>
			<mode><x path="Int"/></mode>
			<ino><x path="Int"/></ino>
			<gid>
				<x path="Int"/>
				<haxe_doc>the user group id for the file</haxe_doc>
			</gid>
			<dev><x path="Int"/></dev>
			<ctime>
				<c path="Date"/>
				<haxe_doc>the creation time for the file</haxe_doc>
			</ctime>
			<atime>
				<c path="Date"/>
				<haxe_doc>the last access time for the file (when enabled by the file system)</haxe_doc>
			</atime>
		</a>
		<haxe_doc>File informations, as given by [sys.FileSystem.stat]</haxe_doc>
	</typedef>
	<class path="sys.FileSystem" params="" file="/usr/lib/haxe/std/cpp/_std/sys/FileSystem.hx">
		<createDirectory public="1" set="method" line="69" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a directory specified by `path`.

		This method is recursive: The parent directories don't have to exist.

		If the directory cannot be created, an exception is thrown.

		If `path` is null, the result is unspecified.</haxe_doc>
		</createDirectory>
		<sys_exists line="93" static="1"><f a="">
	<c path="String"/>
	<x path="Bool"/>
</f></sys_exists>
		<sys_create_dir line="98" static="1"><f a=":">
	<c path="String"/>
	<x path="Int"/>
	<unknown/>
</f></sys_create_dir>
		<haxe_doc>This class allows you to get information about the files and directories.

	See `sys.io.File` for the complementary file API.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.io.File" params="" file="/usr/lib/haxe/std/cpp/_std/sys/io/File.hx">
		<saveContent public="1" set="method" line="37" static="1">
			<f a="path:content">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores `content` in the file specified by `path`.

		If the file cannot be written to, an exception is thrown.

		If `path` or `content` are null, the result is unspecified.</haxe_doc>
		</saveContent>
		<write public="1" set="method" line="53" static="1">
			<f a="path:?binary" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="sys.io.FileOutput"/>
			</f>
			<haxe_doc>Returns an `FileOutput` handle to the file specified by `path`.

		If `binary` is true, the file is opened in binary mode. Otherwise it is
		opened in non-binary mode.

		If the file cannot be written to, an exception is thrown.

		Operations on the returned `FileOutput` handle write to the opened file.
		If the file existed, its previous content is overwritten.

		File handles should be closed via `FileOutput.close` once the operation
		is complete.

		If `path` is null, the result is unspecified.</haxe_doc>
		</write>
		<file_open line="70" static="1"><f a=":">
	<c path="String"/>
	<c path="String"/>
	<unknown/>
</f></file_open>
		<haxe_doc>API for reading and writing to files.

	See `sys.FileSystem` for the complementary file system API.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.io.FileOutput" params="" file="/usr/lib/haxe/std/cpp/_std/sys/io/FileOutput.hx">
		<extends path="haxe.io.Output"/>
		<file_close line="59" static="1"><f a="">
	<d/>
	<unknown/>
</f></file_close>
		<file_write line="64" static="1"><f a=":::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></file_write>
		<file_write_char line="65" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<unknown/>
</f></file_write_char>
		<__f><d/></__f>
		<writeByte public="1" set="method" line="34" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="38" override="1"><f a="s:p:l">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<close public="1" set="method" line="46" override="1"><f a=""><x path="Void"/></f></close>
		<new set="method" line="30"><f a="f">
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Use [sys.io.File.write] to create a [FileOutput]</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
</haxe>