<haxe>
	<class path="ApplicationMain" params="" file="bin/mac64/cpp/haxe/ApplicationMain.hx">
		<_main_ public="1" static="1"><c path="Game"/></_main_>
		<_core public="1" static="1"><c path="luxe.Core"/></_core>
		<_lime public="1" static="1"><c path="lime.LiME"/></_lime>
		<main public="1" set="method" line="12" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</main>
	</class>
	<class path="Array" params="T" file="/usr/lib/haxe/std/Array.hx" extern="1">
		<filter public="1" set="method"><f a="f">
	<f a="">
		<c path="Array.T"/>
		<x path="Bool"/>
	</f>
	<c path="Array"><c path="Array.T"/></c>
</f></filter>
		<map public="1" params="S" set="method"><f a="f">
	<f a="">
		<c path="Array.T"/>
		<c path="map.S"/>
	</f>
	<c path="Array"><c path="map.S"/></c>
</f></map>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of [this] Array.
		
		The elements are not copied and retain their identity, so
		a[i] == a.copy()[i] is true for any valid i. However, a == a.copy() is
		always false.</haxe_doc>
		</copy>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurence of [x] in [this] Array.
		
		This operation modifies [this] Array in place.
		
		If [x] is found by checking standard equality, it is removed from [this]
		Array and all following elements are reindexed acoordingly. The function
		then returns true.
		
		If [x] is not found, [this] Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<insert public="1" set="method">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element [x] at the position [pos].
		
		This operation modifies [this] Array in place.
		
		The offset is calculated like so:
			
		- If [pos] exceeds [this].length, the offset is [this].length.
		- If [pos] is negative, the offset is calculated from the end of [this]
		Array, i.e. [this].length + [pos]. If this yields a negative value,
		the offset is 0.
		- Otherwise, the offset is [pos].
		
		If the resulting offset does not exceed [this].length, all elements from
		and including that offset to the end of [this] Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element [x] at the start of [this] Array.
		
		This operation modifies [this] Array in place.
		
		[this].length and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of [this] Array.
		
		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use Std.string() to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<splice public="1" set="method">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes [len] elements from [this] Array, starting at and including
		[pos], an returns them.
		
		This operation modifies [this] Array in place.
		
		If [len] is < 0 or [pos] exceeds [this].length, the result is the empty
		Array [].
		
		If [pos] is negative, its value is calculated from the end	of [this]
		Array by [this].length + [pos]. If this yields a negative value, 0 is
		used instead.
		
		If the sum of the resulting values for [len] and [pos] exceed
		[this].length, this operation will affect the elements from [pos] to the
		end of [this] Array.
		
		The length of the returned Array is equal to the new length of [this]
		Array subtracted from the original length of [this] Array. In other
		words, each element of the original [this] Array either remains in
		[this] Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts [this] Array according to the comparison function [f], where
		[f(x,y)] returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.
		
		This operation modifies [this] Array in place.
		
		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, haxe.ds.sort.MergeSort.sort() can be used instead.
		
		If [f] is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<slice public="1" set="method">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of [this] Array, starting at and
		including [pos], up to but not including [end].
		
		This operation does not modify [this] Array.
		
		The elements are not copied and retain their identity.
		
		If [end] is omitted or exceeds [this].length, it defaults to the end of
		[this] Array.
		
		If [pos] or [end] are negative, their offsets are calculated from the
		end	of [this] Array by [this].length + [pos] and [this].length + [end]
		respectively. If this yields a negative value, 0 is used instead.
		
		If [pos] exceeds [this].length or if [end} exceeds or equals [pos],
		the result is [].</haxe_doc>
		</slice>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the first element of [this] Array and returns it.
		
		This operation modifies [this] Array in place.
		
		If [this] has at least one element, [this].length and the index of each
		remaining element is decreased by 1.
		
		If [this] is the empty Array [], null is returned and the length remains
		0.</haxe_doc>
		</shift>
		<reverse public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of [this] Array.
		
		This operation modifies [this] Array in place.
		
		If [this].length < 2, [this] remains unchanged.]]></haxe_doc>
		</reverse>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element [x] at the end of [this] Array and returns the offset
		it was added at.
		
		This operation modifies [this] Array in place.
		
		[this].length increases by 1.</haxe_doc>
		</push>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the last element of [this] Array and returns it.
		
		This operation modifies [this] Array in place.
		
		If [this] has at least one element, [this].length will decrease by 1.
		
		If [this] is the empty Array [], null is returned and the length remains
		0.</haxe_doc>
		</pop>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of [this] Array, with [sep] separating
		each element.
		
		The result of this operation is equal to Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1]).
		
		If [this] is the empty Array [], the result is the empty String "". If
		[this] has exactly one element, the result is equal to a call to
		Std.string(this[0]).
		
		If [sep] is null, the result is unspecified.</haxe_doc>
		</join>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of [a] to the elements of
		[this] Array.
		
		This operation does not modify [this] Array.
		
		If [a] is the empty Array [], a copy of [this] Array is returned.
		
		The length of the returned Array is equal to the sum of [this].length
		and [a].length.
		
		If [a] is null, the result is unspecified.</haxe_doc>
		</concat>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of [this] Array.</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.</haxe_doc>
	</class>
	<abstract path="Class" params="T" file="/usr/lib/haxe/std/Class.hx">
		<haxe_doc>An abstract type that represents a Class.
	
	See [Type] for the haXe Reflection API.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="cpp.Lib" params="" file="/usr/lib/haxe/std/cpp/Lib.hx">
		<load public="1" set="method" line="29" static="1">
			<f a="lib:prim:nargs">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>Load and return a Cpp primitive from a DLL library.</haxe_doc>
		</load>
		<loadLazy public="1" set="method" line="48" static="1">
			<f a="lib:prim:nargs">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>Tries to load, and always returns a valid function, but the function may throw
		if called.</haxe_doc>
		</loadLazy>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="EReg" params="" file="/usr/lib/haxe/std/cpp/_std/EReg.hx">
		<regexp_new_options line="174" static="1"><f a=":">
	<c path="String"/>
	<c path="String"/>
	<d/>
</f></regexp_new_options>
		<regexp_match line="175" static="1"><f a=":::">
	<d/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></regexp_match>
		<regexp_matched_pos line="177" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<a>
		<pos><x path="Int"/></pos>
		<len><x path="Int"/></len>
	</a>
</f></regexp_matched_pos>
		<replace public="1" set="method" line="98">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replaces the first substring of [s] which [this] EReg matches with [by].
		
		If [this] EReg does not match any substring, the result is [s].
		
		By default, this method replaces only the first matched substring. If
		the global g modifier is in place, all matched substrings are replaced.
		
		If [by] contains [$1] to [$9], the digit corresponds to number of a
		matched sub-group and its value is used instead. If no such sub-group
		exists, the replacement is unspecified. The string [$$] becomes [$].
		
		If [s] or [by] are null, the result is unspecified.</haxe_doc>
		</replace>
		<match public="1" set="method" line="36">
			<f a="s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if [this] regular expression matches String [s].
		
		This method modifies the internal state.
		
		If [s] is null, the result is unspecified.</haxe_doc>
		</match>
		<global><x path="Bool"/></global>
		<last><c path="String"/></last>
		<r><d/></r>
		<new public="1" set="method" line="28">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new regular expression with pattern [r] and modifiers [opt].
		
		This is equivalent to the shorthand syntax ~/r/opt
		
		If [r] or [opt] are null, the result is unspecified.</haxe_doc>
		</new>
		<haxe_doc>The EReg class represents regular expressions.
	
	While basic usage and patterns consistently work across platforms, some more
	complex operations may yield different results. This is a necessary trade-
	off to retain a certain level of performance.
	
	EReg instances can be created by calling the constructor, or with the
	special syntax ~/pattern/modifier
	
	EReg instances maintain an internal state, which is affected by several of
	its methods.
	
	A detailed explanation of the supported operations is available at
	http://haxe.org/doc/cross/regexp</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Enum" params="T" file="/usr/lib/haxe/std/Enum.hx">
		<haxe_doc>An abstract type that represents an Enum type.
	
	The corresponding enum instance type is EnumValue.
	
	See [Type] for the haXe Reflection API.</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="/usr/lib/haxe/std/EnumValue.hx">
		<haxe_doc>An abstract type that represents any enum value.
	See [Type] for the haXe Reflection API.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<enum path="GameMode" params="" file="src/Game.hx" module="Game">
		<twovtwo/>
		<deathmatch/>
	</enum>
	<class path="luxe.Game" params="" file="/Users/Sven/dev/lab/luxe/luxe/Game.hx">
		<luxecore public="1"><c path="luxe.Core"/></luxecore>
		<new public="1" set="method" line="10"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="Game" params="" file="src/Game.hx">
		<extends path="luxe.Game"/>
		<manager public="1" static="1"><c path="game.Manager"/></manager>
		<level public="1" static="1"><c path="game.Level"/></level>
		<update public="1" set="method" line="87"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<onkeyup public="1" set="method" line="83"><f a="e">
	<t path="luxe.KeyEvent"/>
	<x path="Void"/>
</f></onkeyup>
		<onkeydown public="1" set="method" line="79"><f a="e">
	<t path="luxe.KeyEvent"/>
	<x path="Void"/>
</f></onkeydown>
		<oninputdown public="1" set="method" line="75"><f a="_input:_event">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></oninputdown>
		<oninputup public="1" set="method" line="71"><f a="_input:_event">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></oninputup>
		<onmouseup public="1" set="method" line="67"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></onmouseup>
		<onmousedown public="1" set="method" line="63"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></onmousedown>
		<onmousemove public="1" set="method" line="59"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></onmousemove>
		<ready public="1" set="method" line="32"><f a=""><x path="Void"/></f></ready>
		<current_game_mode public="1"><e path="GameMode"/></current_game_mode>
		<blackcolor public="1"><t path="luxe.Color"/></blackcolor>
		<whitecolor public="1"><t path="luxe.Color"/></whitecolor>
		<team2color public="1"><t path="luxe.Color"/></team2color>
		<team1color public="1"><t path="luxe.Color"/></team1color>
		<font public="1"><c path="phoenix.BitmapFont"/></font>
		<modes><c path="luxe.Modes"/></modes>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="Lambda" params="" file="/usr/lib/haxe/std/Lambda.hx">
		<array public="1" params="A" set="method" line="42" static="1">
			<f a="it">
				<t path="Iterable"><c path="array.A"/></t>
				<c path="Array"><c path="array.A"/></c>
			</f>
			<haxe_doc>Creates an Array from Iterable [it].
		
		If [it] is an Array, this function returns a copy of it.</haxe_doc>
		</array>
		<has public="1" params="A" set="method" line="98" static="1">
			<f a="it:elt">
				<t path="Iterable"><c path="has.A"/></t>
				<c path="has.A"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if [it] contains [elt].
		
		This function returns true as soon as an element is found which is equal
		to [elt] according to the [==] operator.
		
		If no such element is found, the result is false.</haxe_doc>
		</has>
		<count public="1" params="A" set="method" line="191" static="1">
			<f a="it:?pred">
				<t path="Iterable"><c path="count.A"/></t>
				<f a="">
					<c path="count.A"/>
					<x path="Bool"/>
				</f>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the number of elements in [it] for which [pred] is true, or the
		total number of elements in [it] if [pred] is null.
		
		This function traverses all elements.</haxe_doc>
		</count>
		<indexOf public="1" params="T" set="method" line="217" static="1">
			<f a="it:v">
				<t path="Iterable"><c path="indexOf.T"/></t>
				<c path="indexOf.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of the first element [v] within Iterable [it].
		
		This function uses operator [==] to check for equality.
		
		If [v] does not exist in [it], the result is -1.</haxe_doc>
		</indexOf>
		<haxe_doc>The [Lambda] class is a collection of methods to support functional
	programming. It is ideally used with 'using Lambda' and then acts as an
	extension to Iterable types.
	
	On static platforms, working with the Iterable structure might be slower
	than performing the operations directly on known types, such as Array and
	List.
	
	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="List" params="T" file="/usr/lib/haxe/std/List.hx">
		<iterator public="1" set="method" line="161">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>Returns an iterator on the elements of the list.</haxe_doc>
		</iterator>
		<add public="1" set="method" line="49">
			<f a="item">
				<c path="List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element [item] at the end of [this] List.
		
		[this].length increases by 1.</haxe_doc>
		</add>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of [this] List.</haxe_doc>
		</length>
		<q><c path="Array"><d/></c></q>
		<h><c path="Array"><d/></c></h>
		<new public="1" set="method" line="40">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It is optimized so that adding or removing an
	element does not imply copying the whole array content every time.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="Luxe" params="" file="/Users/Sven/dev/lab/luxe/Luxe.hx">
		<dt public="1" line="14" static="1"><x path="Float"/></dt>
		<timescale public="1" line="15" static="1"><x path="Float"/></timescale>
		<mouse public="1" static="1"><t path="luxe.Vector"/></mouse>
		<core public="1" static="1"><c path="luxe.Core"/></core>
		<debug public="1" static="1"><c path="luxe.Debug"/></debug>
		<draw public="1" static="1"><c path="luxe.Draw"/></draw>
		<audio public="1" static="1"><c path="luxe.Audio"/></audio>
		<time public="1" static="1"><c path="luxe.Time"/></time>
		<events public="1" static="1"><c path="luxe.Events"/></events>
		<input public="1" static="1"><c path="luxe.Input"/></input>
		<scene public="1" static="1"><c path="luxe.Scene"/></scene>
		<utils public="1" static="1"><c path="luxe.utils.Utils"/></utils>
		<camera public="1" static="1"><c path="luxe.Camera"/></camera>
		<renderer public="1" static="1"><c path="phoenix.Renderer"/></renderer>
		<resources public="1" static="1"><c path="phoenix.ResourceManager"/></resources>
		<screen public="1" get="accessor" set="null" static="1">
			<t path="luxe.Rectangle"/>
			<meta><m n=":isVar"/></meta>
		</screen>
		<get_screen public="1" set="method" line="37" static="1"><f a=""><t path="luxe.Rectangle"/></f></get_screen>
		<shutdown public="1" set="method" line="39" static="1"><f a=""><x path="Void"/></f></shutdown>
		<showCursor public="1" set="method" line="44" static="1"><f a="_show">
	<x path="Bool"/>
	<x path="Void"/>
</f></showCursor>
		<lockCursor public="1" set="method" line="47" static="1"><f a="_lock">
	<x path="Bool"/>
	<x path="Void"/>
</f></lockCursor>
		<cursorShown public="1" set="method" line="50" static="1"><f a=""><x path="Bool"/></f></cursorShown>
		<cursorLocked public="1" set="method" line="53" static="1"><f a=""><x path="Bool"/></f></cursorLocked>
		<setCursorPosition public="1" set="method" line="56" static="1"><f a="_x:_y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setCursorPosition>
		<loadText public="1" set="method" line="60" static="1"><f a="_id">
	<c path="String"/>
	<c path="String"/>
</f></loadText>
		<loadData public="1" set="method" line="64" static="1"><f a="_id">
	<c path="String"/>
	<t path="lime.utils.ByteArray"/>
</f></loadData>
		<loadTexture public="1" set="method" line="68" static="1"><f a="_id:?_onloaded">
	<c path="String"/>
	<f a="">
		<c path="phoenix.Texture"/>
		<x path="Void"/>
	</f>
	<c path="phoenix.Texture"/>
</f></loadTexture>
		<loadFont public="1" set="method" line="72" static="1"><f a="_id:?_path:?_onloaded">
	<c path="String"/>
	<c path="String"/>
	<f a=""><x path="Void"/></f>
	<c path="phoenix.BitmapFont"/>
</f></loadFont>
		<loadShader public="1" set="method" line="76" static="1"><f a="?_ps_id:?_vs_id:?_onloaded">
	<c path="String"/>
	<c path="String"/>
	<f a="">
		<c path="phoenix.Shader"/>
		<x path="Void"/>
	</f>
	<c path="phoenix.Shader"/>
</f></loadShader>
		<openURL public="1" set="method" line="80" static="1"><f a="_url">
	<c path="String"/>
	<x path="Void"/>
</f></openURL>
		<fileDialogFolder public="1" set="method" line="84" static="1"><f a="_title:_text">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></fileDialogFolder>
		<fileDialogOpen public="1" set="method" line="87" static="1"><f a="_title:_text">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></fileDialogOpen>
		<fileDialogSave public="1" set="method" line="90" static="1"><f a="_title:_text">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></fileDialogSave>
		<addGeometry public="1" set="method" line="94" static="1"><f a="_geom">
	<c path="phoenix.geometry.Geometry"/>
	<x path="Void"/>
</f></addGeometry>
		<removeGeometry public="1" set="method" line="98" static="1"><f a="_geom">
	<c path="phoenix.geometry.Geometry"/>
	<x path="Void"/>
</f></removeGeometry>
	</class>
	<abstract path="Map" params="K:V" file="/usr/lib/haxe/std/Map.hx">
		<from>
			<c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c>
			<c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c>
			<c path="haxe.ds.ObjectMap">
				<c path="fromObjectMap.K"/>
				<c path="fromObjectMap.V"/>
			</c>
		</from>
		<to>
			<c path="haxe.ds.StringMap"><c path="Map.V"/></c>
			<c path="haxe.ds.IntMap"><c path="Map.V"/></c>
			<c path="haxe.ds.EnumValueMap">
				<c path="toEnumValueMapMap.K"/>
				<c path="Map.V"/>
			</c>
			<c path="haxe.ds.ObjectMap">
				<c path="toObjectMap.K"/>
				<c path="Map.V"/>
			</c>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.
		
	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.
	
	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.
	
	Maps can also be created with [key1 => value1, key2 => value2] syntax.
	
	Map is an abstract type, it is not available at runtime.]]></haxe_doc>
		<meta><m n=":multiType"/></meta>
	</abstract>
	<class path="_Map.Map_Impl_" params="" file="/usr/lib/haxe/std/Map.hx" private="1" module="Map"><meta><m n=":keep"/></meta></class>
	<class path="IMap" params="K:V" file="/usr/lib/haxe/std/Map.hx" module="Map" interface="1"><meta><m n=":keep"/></meta></class>
	<typedef path="_Map.Hashable" params="" file="/usr/lib/haxe/std/Map.hx" private="1" module="Map"><a><hashCode set="method"><f a=""><x path="Int"/></f></hashCode></a></typedef>
	<class path="Math" params="" file="/usr/lib/haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><x path="Float"/></PI>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes negative infinity.
		
		For example, this is the result of -1.0 / 0.0.
		
		Operations with NEGATIVE_INFINITY as an operand may result in
		Operations with NEGATIVE_INFINITY as an operand may result in
		NEGATIVE_INFINITY, POSITIVE_INFINITY or NaN. For detailed information,
		see ...
		
		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.</haxe_doc>
		</NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes negative infinity.
		
		For example, this is the result of 1.0 / 0.0.
		
		Operations with POSITIVE_INFINITY as an operand may result in
		NEGATIVE_INFINITY, POSITIVE_INFINITY or NaN. For detailed information,
		see ...
	
		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.</haxe_doc>
		</POSITIVE_INFINITY>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes an invalid number.
		
		NaN stands for "Not a Number". It occurs when a mathematically incorrect
		operation is executed, such as taking the square root of a negative
		number: Math.sqrt(-1).
		
		All further operations with NaN as an operand will result in NaN.
		
		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.
		
		In order to test if a value is NaN, you should use Math.isNaN() function.
		
		(Php) In PHP versions prior to 5.3.1 VC 9 there may be unexpected
		results when performing arithmetic operations with NaN on Windows, see:
			https://bugs.php.net/bug.php?id=42143</haxe_doc>
		</NaN>
		<abs public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of [v].
		
		If [v] is positive or 0, the result is unchanged. Otherwise the result
		is -[v].
		
		If [v] is NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is
		POSITIVE_INFINITY.
		
		If [v] is NaN, the result is NaN.</haxe_doc>
		</abs>
		<min public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smaller of values [a] and [b].
		
		If [a] or [b] are NaN, the result is NaN.
		
		If [a] or [b] are NEGATIVE_INFINITY, the result is NEGATIVE_INFINITY.
		
		If [a] and [b] are POSITIVE_INFINITY, the result is POSITIVE_INFINITY.</haxe_doc>
		</min>
		<max public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the greater of values [a] and [b].
		
		If [a] or [b] are NaN, the result is NaN.
		
		If [a] or [b] are POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		
		If [a] and [b] are NEGATIVE_INFINITY, the result is NEGATIVE_INFINITY.</haxe_doc>
		</max>
		<sin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric sine of [v].
		
		The unit of [v] is radians.
		
		If [v] is NaN or infinite, the result is NaN.</haxe_doc>
		</sin>
		<cos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric cosine of [v].
		
		The unit of [v] is radians.
		
		If [v] is NaN or infinite, the result is NaN.</haxe_doc>
		</cos>
		<tan public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></tan>
		<asin public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></asin>
		<acos public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></acos>
		<atan public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></atan>
		<atan2 public="1" set="method" static="1"><f a="y:x">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></atan2>
		<exp public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns Euler's number, raised to the power of [v].
		
		exp(1.0) is approximately 2.718281828459.
		
		If [v] is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		
		If [v] is NEGATIVE_INFINITY, the result is 0.0.
		
		If [v] is NaN, the result is NaN.</haxe_doc>
		</exp>
		<log public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of [v].
		
		If [v] is negative (including NEGATIVE_INFINITY) or NaN, the result is
		NaN.
		
		If [v] is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		
		If [v] is 0.0, the result is NEGATIVE_INFINITY.
		
		This is the inverse operation of exp, i.e. log(exp(v)) == v always
		holds.</haxe_doc>
		</log>
		<pow public="1" set="method" static="1"><f a="v:exp">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></pow>
		<sqrt public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of [v].
		
		If [v] is negative (including NEGATIVE_INFINITY) or NaN, the result is
		NaN.
		
		If [v] is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		
		If [v] is 0.0, the result is 0.0.</haxe_doc>
		</sqrt>
		<round public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Rounds [v] to the nearest Int value.

		If v is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.
		
		TODO: need spec</haxe_doc>
		</round>
		<floor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest Int value that is not greater than [v].
		
		If v is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.		
		
		TODO: need spec</haxe_doc>
		</floor>
		<ceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest Int value that is not less than [v].

		If v is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.
		
		TODO: need spec</haxe_doc>
		</ceil>
		<random public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a pseudo-random number which is greater than or equal to 0.0,
		and less than 1.0.</haxe_doc>
		</random>
		<ffloor public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></ffloor>
		<fceil public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fceil>
		<fround public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fround>
		<isFinite public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if [f] is a finite number.
		
		If [f] is POSITIVE_INFINITY, NEGATIVE_INFINITY or NaN, the result is
		false.
		
		Otherwise the result is true.</haxe_doc>
		</isFinite>
		<isNaN public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if [f] is not a valid number.
		
		If [f] is NaN, the result is true.
		
		Otherwise the result is false. In particular, both POSITIVE_INFINITY and
		NEGATIVE_INFINITY are not considered NaN.</haxe_doc>
		</isNaN>
		<haxe_doc>This class defines mathematical functions and constants.</haxe_doc>
		<meta><m n=":include"><e>"hxMath"</e></m></meta>
	</class>
	<class path="Reflect" params="" file="/usr/lib/haxe/std/cpp/_std/Reflect.hx">
		<hasField public="1" set="method" line="24" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if structure [o] has a field named [field].
		
		This is only guaranteed to work for anonymous structures. Refer to
		[Type.getInstanceFields] for a function supporting class instances.
		
		If [o] or [field] are null, the result is unspecified.</haxe_doc>
		</hasField>
		<field public="1" set="method" line="28" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the value of the field named [field] on object [o].
		
		If [o] is not an object or has no field named [field], the result is
		null.
		
		If the field is defined as a property, its accessors are ignored. Refer
		to [Reflect.getProperty] for a function supporting property accessors.
		
		If [field] is null, the result is unspecified.
		
		(As3) If used on a property field, the getter will be invoked. It is
		not possible to obtain the value directly.</haxe_doc>
		</field>
		<callMethod public="1" set="method" line="46" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>Call a method with the given object and arguments.</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="53" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the fields of structure [o].
		
		This method is only guaranteed to work on anonymous structures. Refer to
		[Type.getInstanceFields()] for a function supporting class instances.
		
		If [o] is null, the result is unspecified.</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="60" static="1">
			<f a="f">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if [f] is a function, false otherwise.
		
		If [f] is null, the result is false.</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" line="64" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Compares [a] and [b].
		
		If [a] is less than [b], the result is negative. If [b] is less than
		[a], the result is positive. If [a] and [b] are equal, the result is 0.
		
		This function is only defined if [a] and [b] are of the same type.
		
		If that type is a function, the result is unspecified and
		[Reflect.compareMethods] should be used instead.
		
		For all other types, the result is 0 if [a] and [b] are equal. If they
		are not equal, the result depends on the type and is negative if:
			Numeric types: a is less than b
			String: a is lexicographically less than b
			Other: unspecified
		
		If [a] and [b] are null, the result is 0. If only one of them is null,
		the result is unspecified.</haxe_doc>
		</compare>
		<isObject public="1" set="method" line="76" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[Tells if [v] is an object.
		
		The result is true if [v] is one of the following:
			- class instance
			- structure
			- Class<T>
			- Enum<T>
			
		Otherwise, including if [v] is null, the result is false.]]></haxe_doc>
		</isObject>
		<isEnumValue public="1" set="method" line="83" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if [v] is an enum value.
		
		The result is true if [v] is of type EnumValue, i.e. an enum
		constructor.
		
		Otherwise, including if [v] is null, the result is false.</haxe_doc>
		</isEnumValue>
		<haxe_doc>The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Std" params="" file="/usr/lib/haxe/std/cpp/_std/Std.hx">
		<is public="1" set="method" line="23" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if a value v is of the type t. Returns false if v or t are null.</haxe_doc>
		</is>
		<string public="1" set="method" line="27" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Converts any value to a String.

		If s is of String, Int, Float or Bool, its value is returned.

		If s is an instance of a class and that class or one of its parent classes has
		a toString() method, that method is called. If no such method is present, the result
		is unspecified.

		If s is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If s is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<int public="1" set="method" line="31" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Converts a Float to an Int, rounded towards 0.

		If x is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="35" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<haxe_doc>Converts a String to an Int.

		Leading whitespaces are ignored.

		If x starts with 0x or 0X, hexadecimal notation is recognized where the following digits may
		contain 0-9 and A-F.

		Otherwise x is read as decimal number with 0-9 being allowed characters. x may also start with
		a - to denote a negative value.

		In decimal mode, parsing continues until an invalid character is detected, in which case the
		result up to that point is returned. For hexadecimal notation, the effect of invalid characters
		is unspecified.

		Leading 0s that are not part of the 0x/0X hexadecimal notation are ignored, which means octal
		notation is not supported.

		If the input cannot be recognized, the result is null.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="39" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Converts a String to a Float.

		The parsing rules for parseInt() apply here as well, with the exception of invalid input
		resulting in a NaN value instead of null.

		Additionally, decimal notation may contain a single . to denote the start of the fractions.</haxe_doc>
		</parseFloat>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<haxe_doc>The standard Void type. Only [null] values can be of the type [Void].</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<haxe_doc>The standard Float type, this is a double-precision IEEE 64bit float.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<to><x path="Float"/></to>
		<haxe_doc>The standard Int type. Its precision depends on the platform.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Null" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.</haxe_doc>
	</typedef>
	<abstract path="Bool" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<haxe_doc>The standard Boolean type is represented as an enum with two choices.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<haxe_doc>Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the Iterator and advances to the next one.
		
		This method is not required to check hasNext() first. A call to this
		method while hasNext() is false yields unspecified behavior.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns false if the iteration is complete, true otherwise.
		
		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to next(). However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An Iterator is a structure that permits iteration over elements of type T.

	Any class with matching hasNext and next fields is considered an Iterator
	and can then be used e.g. in for-loops. This makes it easy to implement
	custom iterators.</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.</haxe_doc></class>
	<class path="String" params="" file="/usr/lib/haxe/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code [code].
		
		If [code] is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of [this] String from [startIndex] to [endIndex].
		
		If [startIndex] or [endIndex] are negative, 0 is used instead.
		
		If [startIndex] exceeds [endIndex], they are swapped.
		
		If the (possibly swapped) [endIndex] is omitted or exceeds
		[this].length, [this].length is used instead.
		
		If the (possibly swapped) [startIndex] exceeds [this].length, the empty
		String "" is returned.</haxe_doc>
		</substring>
		<substr public="1" set="method">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns [len] characters of [this] String, starting at position [pos].
		
		If [len] is omitted, all characters from position [pos] to the end of
		[this] String are included.
		
		If [pos] is negative, its value is calculated from the end of [this]
		String by [this].length + [pos]. If this yields a negative value, 0 is
		used instead.
		
		If the calculated position + [len] exceeds [this].length, the characters
		from that position to the end of [this] String are returned.
		
		If [len] is negative, the result is unspecified.</haxe_doc>
		</substr>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits [this] String at each occurence of [delimiter].
		
		If [delimiter] is the empty String "", [this] String is split into an
		Array of [this].length elements, where the elements correspond to the
		characters of [this] String.
		
		If [delimiter] is not found within [this] String, the result is an Array
		with one element, which equals [this] String.
		
		If [delimiter] is null, the result is unspecified.
		
		Otherwise, [this] String is split into parts at each occurence of
		[delimiter]. If [this] String starts (or ends) with [delimiter}, the
		result Array contains a leading (or trailing) empty String "" element.
		Two subsequent delimiters also result in an empty String "" element.</haxe_doc>
		</split>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurence of [str] within [this]
		String.
		
		If [startIndex] is given, the search is performed within the substring
		of [this] String from 0 to [startIndex]. Otherwise the search is
		performed within [this] String. In either case, the returned position
		is relative to the beginning of [this] String.
		
		If [str] cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurence of [str] within [this]
		String.
		
		If [startIndex] is given, the search is performed within the substring
		of [this] String starting from [startIndex]. Otherwise the search is
		performed within [this] String. In either case, the returned position
		is relative to the beginning of [this] String.
		
		If [str] cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<charCodeAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<haxe_doc>Returns the character code at position [index] of [this] String.
		
		If [index] is negative or exceeds [this].length, null is returned.
		
		To obtain the character code of a single character, "x".code can be used
		instead to inline the character code at compile time. Note that this
		only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position [index] of [this] String.
		
		If [index] is negative or exceeds [this].length, the empty String ""
		is returned.</haxe_doc>
		</charAt>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of [this] String are lower case.
		
		Affects the characters [A-Z]. Other characters remain unchanged.</haxe_doc>
		</toLowerCase>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of [this] String are upper case.
		
		Affects the characters [a-z]. Other characters remain unchanged.</haxe_doc>
		</toUpperCase>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in [this] String.</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.
	
	A haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of [this] String.
	
	Strings can be constructed using the string literal syntax "string value".
	
	String can be concatenated by using the + operator. If an operand is not a
	String, it is passed through Std.string() first.</haxe_doc>
	</class>
	<class path="StringBuf" params="" file="/usr/lib/haxe/std/cpp/_std/StringBuf.hx">
		<addChar public="1" get="inline" set="null" line="39">
			<f a="c">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends the character identified by [c] to [this] StringBuf.
		
		If [c] is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</addChar>
		<add public="1" set="method" line="31">
			<f a="x">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends the representation of [x] to [this] StringBuf.
		
		The exact representation of [x] may vary per platform. To get more
		consistent behavior, this function should be called with
		Std.string(x).
		
		If [x] is null, the String "null" is appended.</haxe_doc>
		</add>
		<b><c path="Array"><c path="String"/></c></b>
		<new public="1" set="method" line="27">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringBuf instance.
		
		This may involve initialization of the internal buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by appending small
	elements together.
	
	Its cross-platform implementation uses String concatenation internally, but
	StringBuf may be optimized for different targets.
	
	Unlike String, an instance of StringBuf is not immutable in the sense that
	it can be passed as argument to functions which modify it by appending more
	values. However, the internal buffer cannot be modified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="StringTools" params="" file="/usr/lib/haxe/std/StringTools.hx">
		<replace public="1" set="method" line="288" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replace all occurences of the String [sub] in the String [s] by the
		String [by].

		If [sub] is the empty String "", [by] is inserted after each character
		of [s]. If [by] is also the empty String "", [s] remains unchanged.

		This is a convenience function for [s].split([sub]).join([by]).

		If [sub] or [by] are null, the result is unspecified.</haxe_doc>
		</replace>
		<hex public="1" set="method" line="310" static="1">
			<f a="n:?digits">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes [n] into a hexadecimal representation.

		If [digits] is specified, the resulting String is padded with "0" until
		its length equals [digits].</haxe_doc>
		</hex>
		<haxe_doc>This class provides advanced methods on Strings. It is ideally used with
	'using StringTools' and then acts as an extension to the String class.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="Sys" params="" file="/usr/lib/haxe/std/cpp/_std/Sys.hx">
		<print public="1" set="method" line="24" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print any value on the standard output.</haxe_doc>
		</print>
		<println public="1" set="method" line="28" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print any value on the standard output, followed by a newline</haxe_doc>
		</println>
		<haxe_doc>This class gives you access to many base functionalities of system platforms. Looks in [sys] sub packages for more system APIs.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Type" params="" file="/usr/lib/haxe/std/cpp/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="35" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<x path="Class"><c path="getClass.T"/></x>
			</f>
			<haxe_doc>Returns the class of [o], if [o] is a class instance.
		
		If [o] is null or of a different type, null is returned.
		
		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" line="46" static="1">
			<f a="o">
				<x path="EnumValue"/>
				<x path="Enum"><d/></x>
			</f>
			<haxe_doc><![CDATA[Returns the enum of enum instance [o].
		
		An enum instance is the result of using an enum constructor. Given an
		enum Color { Red; }, getEnum(Red) returns Enum<Color>.
		
		If [o] is null, null is returned.
		
		In general, type parameter information cannot be obtained at runtime.]]></haxe_doc>
		</getEnum>
		<resolveClass public="1" set="method" line="66" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<haxe_doc>Resolves a class by name.
		
		If [name] is the path of an existing class, that class is returned.
		
		Otherwise null is returned.
		
		If [name] is null or the path to a different type, the result is
		unspecified.
		
		The class name must not include any type parameters.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="73" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Enum"><d/></x>
			</f>
			<haxe_doc>Resolves an enum by name.
		
		If [name] is the path of an existing enum, that enum is returned.
		
		Otherwise null is returned.
		
		If [name] is null the result is unspecified.
		
		If [name] is the path to a different type, null is returned.
		
		The enum name must not include any type parameters.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="80" static="1">
			<f a="cl:args">
				<x path="Class"><c path="createInstance.T"/></x>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class [cl], using [args] as arguments to the
		class constructor.
		
		This function guarantees that the class constructor is called.
		
		Default values of constructors arguments are not guaranteed to be
		taken into account.
		
		If [cl] or [args] are null, or if the number of elements in [args] does
		not match the expected number of constructor arguments, or if any
		argument has an invalid type,  or if [cl] has no own constructor, the
		result is unspecified.
		
		In particular, default values of constructor arguments are not
		guaranteed to be taken into account.</haxe_doc>
		</createInstance>
		<getInstanceFields public="1" set="method" line="100" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the instance fields of class [c].
		
		This only includes fields which are known at compile-time. In
		particular, using getInstanceFields(getClass(obj)) will not include
		any fields which were added to obj at runtime.
		
		The order of the fields in the returned Array is unspecified.
		
		If [c] is null, the result is unspecified.
		
		(As3) This method only returns instance fields that are public.</haxe_doc>
		</getInstanceFields>
		<enumParameters public="1" set="method" line="136" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance [e].
		
		If [e] has no arguments, the result is [].
		
		Otherwise the result are the values that were used as arguments to [e],
		in the order of their declaration.
		
		If [e] is null, the result is unspecified.</haxe_doc>
		</enumParameters>
		<haxe_doc>The haxe Reflection API allows retrieval of type information at runtime.
	
	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="cpp.rtti.FieldNumericIntegerLookup" params="" file="/usr/lib/haxe/std/cpp/rtti/FieldNumericIntegerLookup.hx" interface="1">
		<haxe_doc>If you implement this interface, then the backend will generate code that
	allows fast numeric access to fields by integer id.  This should speed up the CFFI.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="cpp.zip.Compress" params="" file="/usr/lib/haxe/std/cpp/zip/Compress.hx">
		<run public="1" set="method" line="44" static="1"><f a="s:level">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></run>
		<_deflate_init line="55" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></_deflate_init>
		<_deflate_bound line="56" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
</f></_deflate_bound>
		<_deflate_buffer line="57" static="1"><f a="::::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<a>
		<write><x path="Int"/></write>
		<read><x path="Int"/></read>
		<done><x path="Bool"/></done>
	</a>
</f></_deflate_buffer>
		<_deflate_end line="58" static="1"><f a="">
	<d/>
	<unknown/>
</f></_deflate_end>
		<_set_flush_mode line="59" static="1"><f a=":">
	<d/>
	<c path="String"/>
	<unknown/>
</f></_set_flush_mode>
		<close public="1" set="method" line="40"><f a=""><x path="Void"/></f></close>
		<setFlushMode public="1" set="method" line="36"><f a="f">
	<e path="cpp.zip.Flush"/>
	<x path="Void"/>
</f></setFlushMode>
		<execute public="1" set="method" line="32"><f a="src:srcPos:dst:dstPos">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<a>
		<write><x path="Int"/></write>
		<read><x path="Int"/></read>
		<done><x path="Bool"/></done>
	</a>
</f></execute>
		<s><d/></s>
		<new public="1" set="method" line="28"><f a="level">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<enum path="cpp.zip.Flush" params="" file="/usr/lib/haxe/std/cpp/zip/Flush.hx">
		<SYNC/>
		<NO/>
		<FULL/>
		<FINISH/>
		<BLOCK/>
	</enum>
	<class path="cpp.zip.Uncompress" params="" file="/usr/lib/haxe/std/cpp/zip/Uncompress.hx">
		<run public="1" set="method" line="43" static="1"><f a="src:?bufsize">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></run>
		<_inflate_init line="61" static="1"><f a="">
	<t path="Null"><x path="Int"/></t>
	<unknown/>
</f></_inflate_init>
		<_inflate_buffer line="62" static="1"><f a="::::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<a>
		<write><x path="Int"/></write>
		<read><x path="Int"/></read>
		<done><x path="Bool"/></done>
	</a>
</f></_inflate_buffer>
		<_inflate_end line="63" static="1"><f a="">
	<d/>
	<unknown/>
</f></_inflate_end>
		<_set_flush_mode line="64" static="1"><f a=":">
	<d/>
	<unknown/>
	<unknown/>
</f></_set_flush_mode>
		<close public="1" set="method" line="39"><f a=""><x path="Void"/></f></close>
		<setFlushMode public="1" set="method" line="35"><f a="f">
	<e path="cpp.zip.Flush"/>
	<x path="Void"/>
</f></setFlushMode>
		<this_run public="1" set="method" line="31"><f a="src:srcPos:dst:dstPos">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<a>
		<write><x path="Int"/></write>
		<read><x path="Int"/></read>
		<done><x path="Bool"/></done>
	</a>
</f></this_run>
		<s><d/></s>
		<new public="1" set="method" line="27"><f a="windowBits">
	<t path="Null"><x path="Int"/></t>
	<x path="Void"/>
</f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<enum path="format.png.Color" params="" file="/usr/lib/haxe/lib/format/3,0,4/format/png/Data.hx" module="format.png.Data">
		<ColTrue a="alpha"><x path="Bool"/></ColTrue>
		<ColIndexed/>
		<ColGrey a="alpha"><x path="Bool"/></ColGrey>
	</enum>
	<typedef path="format.png.Header" params="" file="/usr/lib/haxe/lib/format/3,0,4/format/png/Data.hx" module="format.png.Data"><a>
	<width><x path="Int"/></width>
	<interlaced><x path="Bool"/></interlaced>
	<height><x path="Int"/></height>
	<color><e path="format.png.Color"/></color>
	<colbits><x path="Int"/></colbits>
</a></typedef>
	<enum path="format.png.Chunk" params="" file="/usr/lib/haxe/lib/format/3,0,4/format/png/Data.hx" module="format.png.Data">
		<CUnknown a="id:data">
			<c path="String"/>
			<c path="haxe.io.Bytes"/>
		</CUnknown>
		<CPalette a="b"><c path="haxe.io.Bytes"/></CPalette>
		<CHeader a="h"><t path="format.png.Header"/></CHeader>
		<CEnd/>
		<CData a="b"><c path="haxe.io.Bytes"/></CData>
	</enum>
	<typedef path="format.png.Data" params="" file="/usr/lib/haxe/lib/format/3,0,4/format/png/Data.hx"><c path="List"><e path="format.png.Chunk"/></c></typedef>
	<class path="format.png.Reader" params="" file="/usr/lib/haxe/lib/format/3,0,4/format/png/Reader.hx">
		<readChunk set="method" line="91"><f a=""><e path="format.png.Chunk"/></f></readChunk>
		<readHeader set="method" line="56"><f a="i">
	<c path="haxe.io.Input"/>
	<t path="format.png.Header"/>
</f></readHeader>
		<read public="1" set="method" line="41"><f a=""><t path="format.png.Data"/></f></read>
		<checkCRC public="1"><x path="Bool"/></checkCRC>
		<i><c path="haxe.io.Input"/></i>
		<new public="1" set="method" line="35"><f a="i">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="format.png.Tools" params="" file="/usr/lib/haxe/lib/format/3,0,4/format/png/Tools.hx">
		<getHeader public="1" set="method" line="35" static="1">
			<f a="d">
				<t path="format.png.Data"/>
				<t path="format.png.Header"/>
			</f>
			<haxe_doc>Returns the PNG header informations. Throws an exception if no header found.</haxe_doc>
		</getHeader>
		<getPalette public="1" set="method" line="47" static="1">
			<f a="d">
				<t path="format.png.Data"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Return the PNG palette colors, or null if no palette chunk was found</haxe_doc>
		</getPalette>
		<filter get="inline" set="null" line="56" static="1"><f a="data:x:y:stride:prev:p:?numChannels">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></filter>
		<reverseBytes public="1" set="method" line="69" static="1">
			<f a="b">
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Converts from BGRA to ARGB and the other way by reversing bytes.</haxe_doc>
		</reverseBytes>
		<extractGrey public="1" set="method" line="106" static="1">
			<f a="d">
				<t path="format.png.Data"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":noDebug"/></meta>
			<haxe_doc>Decode the greyscale PNG data and apply nilters, extracting only the grey channel if alpha is present.</haxe_doc>
		</extractGrey>
		<extract32 public="1" set="method" line="205" static="1">
			<f a="d:?bytes">
				<t path="format.png.Data"/>
				<c path="haxe.io.Bytes"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":noDebug"/></meta>
			<haxe_doc>Decode the PNG data and apply filters. By default this will output BGRA low-endian format. You can use the [reverseBytes] function to inverse the bytes to ARGB big-endian format.</haxe_doc>
		</extract32>
		<buildGrey public="1" set="method" line="584" static="1">
			<f a="width:height:data">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<t path="format.png.Data"/>
			</f>
			<haxe_doc>Creates PNG data from bytes that contains one bytes (grey values) for each pixel.</haxe_doc>
		</buildGrey>
		<buildRGB public="1" set="method" line="603" static="1">
			<f a="width:height:data">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<t path="format.png.Data"/>
			</f>
			<haxe_doc>Creates PNG data from bytes that contains three bytes (R,G and B values) for each pixel.</haxe_doc>
		</buildRGB>
		<build32ARGB public="1" set="method" line="626" static="1">
			<f a="width:height:data">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<t path="format.png.Data"/>
			</f>
			<haxe_doc>Creates PNG data from bytes that contains four bytes in ARGB format for each pixel.</haxe_doc>
		</build32ARGB>
		<build32BGRA public="1" set="method" line="650" static="1">
			<f a="width:height:data">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<t path="format.png.Data"/>
			</f>
			<haxe_doc>Creates PNG data from bytes that contains four bytes in BGRA format for each pixel.</haxe_doc>
		</build32BGRA>
	</class>
	<class path="format.tools.Deflate" params="" file="/usr/lib/haxe/lib/format/3,0,4/format/tools/Deflate.hx"><run public="1" set="method" line="31" static="1"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></run></class>
	<class path="format.tools.Inflate" params="" file="/usr/lib/haxe/lib/format/3,0,4/format/tools/Inflate.hx"><run public="1" set="method" line="31" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></run></class>
	<class path="luxe.Objects" params="" file="/Users/Sven/dev/lab/luxe/luxe/Objects.hx">
		<_show_debug public="1" line="25" static="1"><x path="Bool"/></_show_debug>
		<_debug set="method" line="26"><f a="v">
	<c path="String"/>
	<x path="Void"/>
</f></_debug>
		<_call set="method" line="16"><f a="_object:_name:?args">
	<c path="luxe.Objects"/>
	<c path="String"/>
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></_call>
		<name public="1"><c path="String"/></name>
		<id public="1"><c path="String"/></id>
		<new public="1" set="method" line="10"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="luxe.components.Component" params="" file="/Users/Sven/dev/lab/luxe/luxe/components/Components.hx" module="luxe.components.Components">
		<extends path="luxe.Objects"/>
		<entity_rotation_change public="1" set="method" line="67">
			<f a="_p">
				<t path="luxe.Vector"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</entity_rotation_change>
		<entity_scale_change public="1" set="method" line="66">
			<f a="_p">
				<t path="luxe.Vector"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</entity_scale_change>
		<entity_pos_change public="1" set="method" line="65">
			<f a="_p">
				<t path="luxe.Vector"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</entity_pos_change>
		<get public="1" set="method" line="61"><f a="_name:?in_children:?first_only">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<d/>
</f></get>
		<add public="1" params="T" set="method" line="57"><f a="type:?_name">
	<x path="Class"><c path="add.T"/></x>
	<c path="String"/>
	<c path="add.T"/>
</f></add>
		<get_scaleRelative set="method" line="53"><f a=""><t path="luxe.Vector"/></f></get_scaleRelative>
		<get_scale set="method" line="50"><f a=""><t path="luxe.Vector"/></f></get_scale>
		<set_scaleRelative set="method" line="47"><f a="_s">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_scaleRelative>
		<set_scale set="method" line="44"><f a="_s">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_scale>
		<get_rotationRelative set="method" line="40"><f a=""><t path="luxe.Vector"/></f></get_rotationRelative>
		<get_rotation set="method" line="37"><f a=""><t path="luxe.Vector"/></f></get_rotation>
		<set_rotationRelative set="method" line="34"><f a="_r">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_rotationRelative>
		<set_rotation set="method" line="31"><f a="_r">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_rotation>
		<get_posRelative set="method" line="27"><f a=""><t path="luxe.Vector"/></f></get_posRelative>
		<get_pos set="method" line="24"><f a=""><t path="luxe.Vector"/></f></get_pos>
		<set_posRelative set="method" line="21"><f a="_p">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_posRelative>
		<set_pos set="method" line="18"><f a="_p">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_pos>
		<scaleRelative public="1" get="accessor" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</scaleRelative>
		<scale public="1" get="accessor" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</scale>
		<rotationRelative public="1" get="accessor" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</rotationRelative>
		<rotation public="1" get="accessor" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</rotation>
		<posRelative public="1" get="accessor" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</posRelative>
		<pos public="1" get="accessor" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</pos>
		<entity public="1"><c path="luxe.Entity"/></entity>
		<new public="1" set="method" line="14"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="game.Bullet" params="" file="src/game/Bullet.hx">
		<extends path="luxe.components.Component"/>
		<fixed_update public="1" set="method" line="68"><f a=""><x path="Void"/></f></fixed_update>
		<onspawn public="1" set="method" line="55"><f a="_pos">
	<t path="luxe.Vector"/>
	<x path="Void"/>
</f></onspawn>
		<kill public="1" set="method" line="37"><f a="_pos:_shape">
	<t path="luxe.Vector"/>
	<c path="hxcollision.shapes.BaseShape"/>
	<x path="Void"/>
</f></kill>
		<init public="1" set="method" line="29"><f a=""><x path="Void"/></f></init>
		<bounds><t path="luxe.Rectangle"/></bounds>
		<collider public="1">
			<c path="hxcollision.shapes.Circle"/>
			<meta><m n=":hide"/></meta>
		</collider>
		<ignored_colliders><c path="Array"><c path="hxcollision.shapes.BaseShape"/></c></ignored_colliders>
		<spawn_pos public="1"><t path="luxe.Vector"/></spawn_pos>
		<speed public="1"><x path="Float"/></speed>
		<dir public="1"><t path="luxe.Vector"/></dir>
		<alive public="1"><x path="Bool"/></alive>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="hxcollision.ShapeDrawer" params="" file="/Users/Sven/dev/hxcollision/hxcollision/ShapeDrawer.hx">
		<drawCircle public="1" set="method" line="48"><f a="circle">
	<c path="hxcollision.shapes.Circle"/>
	<x path="Void"/>
</f></drawCircle>
		<drawVertList set="method" line="31"><f a="_verts">
	<c path="Array"><c path="hxcollision.math.Vector2D"/></c>
	<x path="Void"/>
</f></drawVertList>
		<drawVector public="1" set="method" line="25"><f a="v:start">
	<c path="hxcollision.math.Vector2D"/>
	<c path="hxcollision.math.Vector2D"/>
	<x path="Void"/>
</f></drawVector>
		<drawPolygon public="1" set="method" line="17"><f a="poly">
	<c path="hxcollision.shapes.Polygon"/>
	<x path="Void"/>
</f></drawPolygon>
		<drawLine public="1" set="method" line="13"><f a="p0:p1">
	<c path="hxcollision.math.Vector2D"/>
	<c path="hxcollision.math.Vector2D"/>
	<x path="Void"/>
</f></drawLine>
		<new public="1" set="method" line="9"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="game.LuxeDrawer" params="" file="src/game/Level.hx" module="game.Level">
		<extends path="hxcollision.ShapeDrawer"/>
		<drawLine public="1" set="method" line="19" override="1"><f a="start:end">
	<c path="hxcollision.math.Vector2D"/>
	<c path="hxcollision.math.Vector2D"/>
	<x path="Void"/>
</f></drawLine>
		<new public="1" set="method" line="18"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="luxe.Mode" params="" file="/Users/Sven/dev/lab/luxe/luxe/Modes.hx" module="luxe.Modes">
		<_update public="1" set="method" line="22"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></_update>
		<set_next_tick public="1" set="method" line="17"><f a="_f">
	<f a=""><x path="Void"/></f>
	<f a=""><x path="Void"/></f>
</f></set_next_tick>
		<ticks><c path="Array"><f a=""><x path="Void"/></f></c></ticks>
		<next_tick public="1" get="null" set="accessor">
			<f a=""><x path="Void"/></f>
			<meta><m n=":isVar"/></meta>
		</next_tick>
		<name public="1"><c path="String"/></name>
		<active public="1"><x path="Bool"/></active>
		<modes public="1"><c path="luxe.Modes"/></modes>
		<new public="1" set="method" line="14"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="game.Level" params="" file="src/game/Level.hx">
		<extends path="luxe.Mode"/>
		<disable public="1" set="method" line="186"><f a=""><x path="Void"/></f></disable>
		<enable public="1" set="method" line="178"><f a=""><x path="Void"/></f></enable>
		<update public="1" set="method" line="174"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<oninputup public="1" set="method" line="167"><f a="_name:_event">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></oninputup>
		<rect_from_dynamic public="1" set="method" line="159"><f a="d">
	<d/>
	<t path="luxe.Rectangle"/>
</f></rect_from_dynamic>
		<create_collision_rectangles public="1" set="method" line="153"><f a="list:target">
	<c path="Array"><t path="luxe.Rectangle"/></c>
	<c path="Array"><c path="hxcollision.shapes.BaseShape"/></c>
	<x path="Void"/>
</f></create_collision_rectangles>
		<create_collision_rectangle public="1" set="method" line="149"><f a="_rect">
	<t path="luxe.Rectangle"/>
	<c path="hxcollision.shapes.Polygon"/>
</f></create_collision_rectangle>
		<create_item public="1" set="method" line="125"><f a="item">
	<d/>
	<c path="luxe.Sprite"/>
</f></create_item>
		<init public="1" set="method" line="50"><f a="_manager">
	<c path="game.Manager"/>
	<x path="Void"/>
</f></init>
		<scale><x path="Float"/></scale>
		<drawer public="1"><c path="game.LuxeDrawer"/></drawer>
		<air_collision_shapes public="1"><c path="Array"><c path="hxcollision.shapes.BaseShape"/></c></air_collision_shapes>
		<ground_collision_shapes public="1"><c path="Array"><c path="hxcollision.shapes.BaseShape"/></c></ground_collision_shapes>
		<item_collision_rects><c path="Array"><t path="luxe.Rectangle"/></c></item_collision_rects>
		<air_collision_rects><c path="Array"><t path="luxe.Rectangle"/></c></air_collision_rects>
		<ground_collision_rects><c path="Array"><t path="luxe.Rectangle"/></c></ground_collision_rects>
		<items public="1"><c path="Array"><c path="luxe.Sprite"/></c></items>
		<top public="1"><c path="luxe.Sprite"/></top>
		<bg public="1"><c path="luxe.Sprite"/></bg>
		<manager><c path="game.Manager"/></manager>
		<new public="1" set="method" line="30"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="game.Manager" params="" file="src/game/Manager.hx">
		<extends path="luxe.Mode"/>
		<leave public="1" set="method" line="531"><f a=""><x path="Void"/></f></leave>
		<enter public="1" set="method" line="527"><f a=""><x path="Void"/></f></enter>
		<create_controllers set="method" line="495"><f a=""><x path="Void"/></f></create_controllers>
		<onkeyup public="1" set="method" line="491"><f a="e">
	<t path="luxe.KeyEvent"/>
	<x path="Void"/>
</f></onkeyup>
		<oninputup public="1" set="method" line="481"><f a="_name:_event">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></oninputup>
		<oninputdown public="1" set="method" line="475"><f a="_name:_event">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></oninputdown>
		<create_menu_texts set="method" line="429"><f a=""><x path="Void"/></f></create_menu_texts>
		<create_texts set="method" line="291"><f a=""><x path="Void"/></f></create_texts>
		<create_bars set="method" line="217"><f a=""><x path="Void"/></f></create_bars>
		<onplayeruievent set="method" line="203"><f a="e">
	<d/>
	<x path="Void"/>
</f></onplayeruievent>
		<create_players set="method" line="112"><f a=""><x path="Void"/></f></create_players>
		<init public="1" set="method" line="51"><f a="_game">
	<c path="Game"/>
	<x path="Void"/>
</f></init>
		<level_running public="1"><x path="Bool"/></level_running>
		<midx><x path="Float"/></midx>
		<players public="1"><x path="Map">
	<c path="String"/>
	<c path="luxe.Sprite"/>
</x></players>
		<bar_borders><x path="Map">
	<c path="String"/>
	<c path="phoenix.geometry.RectangleGeometry"/>
</x></bar_borders>
		<bar_sprites><x path="Map">
	<c path="String"/>
	<c path="luxe.Sprite"/>
</x></bar_sprites>
		<team_texts><x path="Map">
	<c path="String"/>
	<c path="luxe.Text"/>
</x></team_texts>
		<ability_text><x path="Map">
	<c path="String"/>
	<c path="luxe.Text"/>
</x></ability_text>
		<weapon_text><x path="Map">
	<c path="String"/>
	<c path="luxe.Text"/>
</x></weapon_text>
		<class_text><x path="Map">
	<c path="String"/>
	<c path="luxe.Text"/>
</x></class_text>
		<midline><c path="phoenix.geometry.LineGeometry"/></midline>
		<player_tex1><c path="phoenix.Texture"/></player_tex1>
		<player_tex><c path="phoenix.Texture"/></player_tex>
		<controller_tex><c path="phoenix.Texture"/></controller_tex>
		<controller_sprites><x path="Map">
	<c path="String"/>
	<c path="luxe.Sprite"/>
</x></controller_sprites>
		<game public="1"><c path="Game"/></game>
		<new public="1" set="method" line="25"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="game.PlayerAim" params="" file="src/game/PlayerAim.hx">
		<extends path="luxe.components.Component"/>
		<update public="1" set="method" line="49"><f a=""><x path="Void"/></f></update>
		<behind><x path="Bool"/></behind>
		<last_r><x path="Float"/></last_r>
		<last_frame><x path="Int"/></last_frame>
		<spriteflipx><x path="Bool"/></spriteflipx>
		<init public="1" set="method" line="27"><f a=""><x path="Void"/></f></init>
		<team><c path="game.PlayerTeam"/></team>
		<weapon><c path="game.PlayerWeapon"/></weapon>
		<animator><c path="game.PlayerAnimator"/></animator>
		<sprite><c path="luxe.Sprite"/></sprite>
		<rot public="1"><x path="Float"/></rot>
		<reticule public="1"><c path="luxe.Sprite"/></reticule>
		<direction public="1"><t path="luxe.Vector"/></direction>
		<facing public="1"><x path="Int"/></facing>
		<new public="1" set="method" line="14"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="game.PlayerAnimator" params="" file="src/game/PlayerAnimator.hx">
		<extends path="luxe.components.Component"/>
		<onstopping set="method" line="46"><f a="e">
	<unknown/>
	<x path="Void"/>
</f></onstopping>
		<onmoving set="method" line="37"><f a="e">
	<unknown/>
	<x path="Void"/>
</f></onmoving>
		<facing public="1" set="method" line="32"><f a="_which">
	<x path="Int"/>
	<x path="Void"/>
</f></facing>
		<init public="1" set="method" line="20"><f a=""><x path="Void"/></f></init>
		<idle><x path="Bool"/></idle>
		<moving><x path="Bool"/></moving>
		<anim><c path="luxe.components.sprite.SpriteAnimation"/></anim>
		<aim><c path="game.PlayerAim"/></aim>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="game.PlayerKeyInput" params="" file="src/game/PlayerKeyInput.hx">
		<extends path="luxe.components.Component"/>
		<oninput public="1" set="method" line="91"><f a="_event">
	<d/>
	<x path="Void"/>
</f></oninput>
		<update public="1" set="method" line="72"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<init public="1" set="method" line="30"><f a=""><x path="Void"/></f></init>
		<sprite><c path="luxe.Sprite"/></sprite>
		<aim><c path="game.PlayerAim"/></aim>
		<weapons><c path="game.PlayerWeapon"/></weapons>
		<shoot><c path="game.PlayerShoot"/></shoot>
		<move><c path="game.PlayerMovement"/></move>
		<sprint><x path="Bool"/></sprint>
		<down><x path="Bool"/></down>
		<up><x path="Bool"/></up>
		<right><x path="Bool"/></right>
		<left><x path="Bool"/></left>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="game.PlayerMovement" params="" file="src/game/PlayerMovement.hx">
		<extends path="luxe.components.Component"/>
		<fixed_update public="1" set="method" line="87"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></fixed_update>
		<update public="1" set="method" line="41"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<init public="1" set="method" line="30"><f a=""><x path="Void"/></f></init>
		<skip_physics><x path="Bool"/></skip_physics>
		<next_pos><t path="luxe.Vector"/></next_pos>
		<collider public="1"><c path="hxcollision.shapes.Polygon"/></collider>
		<speed public="1"><x path="Float"/></speed>
		<linear_drag public="1"><x path="Float"/></linear_drag>
		<moving public="1"><x path="Bool"/></moving>
		<velocity public="1"><t path="luxe.Vector"/></velocity>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="game.PlayerShoot" params="" file="src/game/PlayerShoot.hx">
		<extends path="luxe.components.Component"/>
		<spawn public="1" set="method" line="84"><f a=""><x path="Void"/></f></spawn>
		<update public="1" set="method" line="75"><f a=""><x path="Void"/></f></update>
		<fire public="1" set="method" line="71"><f a=""><x path="Void"/></f></fire>
		<onfiring public="1" set="method" line="65"><f a=""><x path="Void"/></f></onfiring>
		<onstopfiring public="1" set="method" line="61"><f a=""><x path="Void"/></f></onstopfiring>
		<init public="1" set="method" line="31"><f a=""><x path="Void"/></f></init>
		<sprite><c path="luxe.Sprite"/></sprite>
		<weapon><c path="game.PlayerWeapon"/></weapon>
		<aim><c path="game.PlayerAim"/></aim>
		<next_fire><x path="Float"/></next_fire>
		<current><x path="Int"/></current>
		<firing public="1"><x path="Bool"/></firing>
		<bullet_texture public="1"><c path="phoenix.Texture"/></bullet_texture>
		<precache public="1"><x path="Bool"/></precache>
		<poolsize public="1"><x path="Int"/></poolsize>
		<bullet_pool><c path="Array"><c path="luxe.Sprite"/></c></bullet_pool>
		<new public="1" set="method" line="14"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="game.PlayerTeam" params="" file="src/game/PlayerTeam.hx">
		<extends path="luxe.components.Component"/>
		<update public="1" set="method" line="50"><f a=""><x path="Void"/></f></update>
		<onflip set="method" line="44"><f a="_event">
	<d/>
	<x path="Void"/>
</f></onflip>
		<set_team_color public="1" set="method" line="38"><f a="_team_color">
	<t path="luxe.Color"/>
	<x path="Void"/>
</f></set_team_color>
		<init public="1" set="method" line="17"><f a=""><x path="Void"/></f></init>
		<teamcolor><t path="luxe.Color"/></teamcolor>
		<flag public="1"><c path="luxe.Sprite"/></flag>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
	</class>
	<typedef path="game.WeaponDesc" params="" file="src/game/PlayerWeapon.hx" module="game.PlayerWeapon"><a>
	<velocity><x path="Float"/></velocity>
	<spawn_offset><x path="Float"/></spawn_offset>
	<reloadtime><x path="Float"/></reloadtime>
	<rate><x path="Float"/></rate>
	<name><c path="String"/></name>
	<image><c path="phoenix.Texture"/></image>
	<desc><c path="String"/></desc>
	<damage><x path="Float"/></damage>
	<clipammo><x path="Int"/></clipammo>
	<ammo><x path="Int"/></ammo>
</a></typedef>
	<class path="game.PlayerWeapon" params="" file="src/game/PlayerWeapon.hx">
		<extends path="luxe.components.Component"/>
		<update public="1" set="method" line="157"><f a=""><x path="Void"/></f></update>
		<onflip set="method" line="151"><f a="_event">
	<d/>
	<x path="Void"/>
</f></onflip>
		<cycle public="1" set="method" line="136"><f a="?_dir">
	<x path="Int"/>
	<x path="Void"/>
</f></cycle>
		<set_weapon public="1" set="method" line="116"><f a="_name">
	<c path="String"/>
	<x path="Void"/>
</f></set_weapon>
		<init public="1" set="method" line="36"><f a=""><x path="Void"/></f></init>
		<weapon_names public="1"><c path="Array"><c path="String"/></c></weapon_names>
		<weapon_list public="1"><x path="Map">
	<c path="String"/>
	<t path="game.WeaponDesc"/>
</x></weapon_list>
		<current public="1"><x path="Int"/></current>
		<spawn_offset public="1"><x path="Float"/></spawn_offset>
		<rate public="1"><x path="Float"/></rate>
		<speed public="1"><x path="Float"/></speed>
		<image public="1"><c path="luxe.Sprite"/></image>
		<new public="1" set="method" line="23"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="game.items.Explosive" params="" file="src/game/items/Explosive.hx">
		<extends path="luxe.components.Component"/>
		<on_impact_from_bullet set="method" line="20"><f a="_data">
	<d/>
	<x path="Void"/>
</f></on_impact_from_bullet>
		<init public="1" set="method" line="15"><f a=""><x path="Void"/></f></init>
		<desc public="1"><d/></desc>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="haxe.EnumTools" params="" file="/usr/lib/haxe/std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="41" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum [e], including its path.
		
		If [e] is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
			pack1.pack2.(...).packN.EnumName
		If [e] is a sub-type of a haxe module, that module is not part of the
		package structure.
			
		If [e] has no package, the enum name is returned.
		
		If [e] is null, the result is unspecified.
		
		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="54" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum [e] by calling its constructor [constr] with
		arguments [params].
		
		If [e] or [constr] is null, or if enum [e] has no constructor named
		[constr], or if the number of elements in [params] does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="70" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum [e] by calling its constructor number
		[index] with arguments [params].
		
		The constructor indices are preserved from haxe syntax, so the first
		declared is index 0, the next index 1 etc.
		
		If [e] or [constr] is null, or if enum [e] has no constructor named
		[constr], or if the number of elements in [params] does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="87" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum [e] that require no
		arguments.
		
		This may return the empty Array [] if all constructors of [e] require
		arguments.
		
		Otherwise an instance of [e] constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.
		
		If [e] is null, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="99" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum [e].
		
		The order of the constructor names in the returned Array is preserved
		from the original syntax.
		
		If [c] is null, the result is unspecified.</haxe_doc>
		</getConstructors>
	</class>
	<class path="haxe.EnumValueTools" params="" file="/usr/lib/haxe/std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="114" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances [a] and [b] by value.
		
		Unlike [a] == [b], this function performs a deep equality check on the
		arguments of the constructors, if exists.
		
		If [a] or [b] are null, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="125" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance [e].
		
		The result String does not contain any constructor arguments.
		
		If [e] is null, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="139" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance [e].
		
		If [e] has no arguments, the result is [].
		
		Otherwise the result are the values that were used as arguments to [e],
		in the order of their declaration.
		
		If [e] is null, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="151" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance [e].
		
		This corresponds to the original syntactic position of [e]. The index of
		the first declared constructor is 0, the next one is 1 etc.
		
		If [e] is null, the result is unspecified.</haxe_doc>
		</getIndex>
	</class>
	<class path="haxe.Log" params="" file="/usr/lib/haxe/std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="45" static="1">
			<f a="v:?infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Outputs [v] in a platform-dependent way.

		The second parameter [infos] is injected by the compiler and contains
		information about the position where the trace() call was made.

		This method can be rebound to a custom function:
			var oldTrace = haxe.Log.trace; // store old function
			haxe.Log.trace = function(v,infos) { // handle trace }
			...
			haxe.Log.trace = oldTrace;

		If it is bound to null, subsequent calls to trace() will cause an
		exception.</haxe_doc>
		</trace>
		<haxe_doc>Log primarily provides the trace() method, which is invoked upon a call to
	trace() in haxe code.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/usr/lib/haxe/std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<c path="Array"><d/></c>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>PosInfos is a magic type which can be used to generate position information
	into the output for debugging use.
	
	If a function has a final optional argument of this type, i.e.
	(..., ?pos:haxe.PosInfos), each call to that function which does not assign
	a value to that argument has its position added as call argument.
	
	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<class path="lime.utils.Libs" params="" file="/Users/Sven/dev/lab/lime/lime/utils/Libs.hx">
		<__moduleNames line="6" static="1">
			<x path="Map">
				<c path="String"/>
				<c path="String"/>
			</x>
			<meta><m n=":noCompletion"/></meta>
		</__moduleNames>
		<tryLoad set="method" line="12" static="1"><f a="name:library:func:args">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<d/>
</f></tryLoad>
		<findHaxeLib set="method" line="68" static="1"><f a="library">
	<c path="String"/>
	<c path="String"/>
</f></findHaxeLib>
		<sysName set="method" line="112" static="1"><f a=""><c path="String"/></f></sysName>
		<load public="1" set="method" line="163" static="1"><f a="library:method:?args">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<d/>
</f></load>
		<loaderTrace set="method" line="227" static="1"><f a="message">
	<c path="String"/>
	<x path="Void"/>
</f></loaderTrace>
	</class>
	<class path="sys.io.Process" params="" file="/usr/lib/haxe/std/cpp/_std/sys/io/Process.hx">
		<_run line="123" static="1"><f a=":">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<unknown/>
</f></_run>
		<_close line="126" static="1"><f a="">
	<d/>
	<unknown/>
</f></_close>
		<close public="1" set="method" line="115"><f a=""><x path="Void"/></f></close>
		<stdin public="1" set="null"><c path="haxe.io.Output"/></stdin>
		<stderr public="1" set="null"><c path="haxe.io.Input"/></stderr>
		<stdout public="1" set="null"><c path="haxe.io.Input"/></stdout>
		<p><d/></p>
		<new public="1" set="method" line="100"><f a="cmd:args">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.io.Output" params="" file="/usr/lib/haxe/std/haxe/io/Output.hx">
		<writeString public="1" set="method" line="313"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></writeString>
		<writeFullBytes public="1" set="method" line="89"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></writeFullBytes>
		<close public="1" set="method" line="68"><f a=""><x path="Void"/></f></close>
		<writeBytes public="1" set="method" line="42"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<writeByte public="1" set="method" line="38"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<haxe_doc>An Output is an abstract write. A specific output implementation will only
	have to override the [writeChar] and maybe the [write], [flush] and [close]
	methods. See [File.write] and [String.write] for two ways of creating an
	Output.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="sys.io._Process.Stdin" params="" file="/usr/lib/haxe/std/cpp/_std/sys/io/Process.hx" private="1" module="sys.io.Process">
		<extends path="haxe.io.Output"/>
		<_stdin_write line="53" static="1"><f a=":::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></_stdin_write>
		<_stdin_close line="54" static="1"><f a="">
	<d/>
	<unknown/>
</f></_stdin_close>
		<writeBytes public="1" set="method" line="44" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<writeByte public="1" set="method" line="39" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<close public="1" set="method" line="34" override="1"><f a=""><x path="Void"/></f></close>
		<buf><c path="haxe.io.Bytes"/></buf>
		<p><d/></p>
		<new public="1" set="method" line="29"><f a="p">
	<unknown/>
	<x path="Void"/>
</f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.Bytes" params="" file="/usr/lib/haxe/std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="250" static="1"><f a="length">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" set="method" line="275" static="1"><f a="s">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></ofString>
		<ofData public="1" set="method" line="324" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<c path="haxe.io.Bytes"/>
</f></ofData>
		<toHex public="1" set="method" line="232"><f a=""><c path="String"/></f></toHex>
		<toString public="1" set="method" line="211"><f a=""><c path="String"/></f></toString>
		<readString public="1" set="method" line="163"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></readString>
		<sub public="1" set="method" line="99"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<blit public="1" set="method" line="68"><f a="pos:src:srcpos:len">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blit>
		<b><t path="haxe.io.BytesData"/></b>
		<length public="1" set="null"><x path="Int"/></length>
		<new set="method" line="29"><f a="length:b">
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.Input" params="" file="/usr/lib/haxe/std/haxe/io/Input.hx">
		<readString public="1" set="method" line="318"><f a="len">
	<x path="Int"/>
	<c path="String"/>
</f></readString>
		<readInt32 public="1" set="method" line="310"><f a=""><x path="Int"/></f></readInt32>
		<readLine public="1" set="method" line="127"><f a=""><c path="String"/></f></readLine>
		<read public="1" set="method" line="107"><f a="nbytes">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></read>
		<readFullBytes public="1" set="method" line="99"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></readFullBytes>
		<set_bigEndian set="method" line="70"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_bigEndian>
		<close public="1" set="method" line="67"><f a=""><x path="Void"/></f></close>
		<readBytes public="1" set="method" line="46"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<readByte public="1" set="method" line="37"><f a=""><x path="Int"/></f></readByte>
		<bigEndian public="1" set="accessor"><x path="Bool"/></bigEndian>
		<haxe_doc>An Input is an abstract reader. See other classes in the [haxe.io] package
	for several possible implementations.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="sys.io._Process.Stdout" params="" file="/usr/lib/haxe/std/cpp/_std/sys/io/Process.hx" private="1" module="sys.io.Process">
		<extends path="haxe.io.Input"/>
		<_stdout_read line="87" static="1"><f a=":::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></_stdout_read>
		<_stderr_read line="88" static="1"><f a=":::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></_stderr_read>
		<readBytes public="1" set="method" line="76" override="1"><f a="str:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<readByte public="1" set="method" line="70" override="1"><f a=""><x path="Int"/></f></readByte>
		<buf><c path="haxe.io.Bytes"/></buf>
		<out><x path="Bool"/></out>
		<p><d/></p>
		<new public="1" set="method" line="64"><f a="p:out">
	<unknown/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.Timer" params="" file="/Users/Sven/dev/lab/lime/haxe/Timer.hx">
		<sRunningTimers line="7" static="1"><c path="Array"><c path="haxe.Timer"/></c></sRunningTimers>
		<measure public="1" params="T" set="method" line="22" static="1"><f a="f:?pos">
	<f a=""><c path="measure.T"/></f>
	<t path="haxe.PosInfos"/>
	<c path="measure.T"/>
</f></measure>
		<__nextWake public="1" set="method" line="45" static="1">
			<f a="limit">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</__nextWake>
		<__checkTimers public="1" set="method" line="70" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</__checkTimers>
		<GetMS set="method" line="86" static="1"><f a=""><x path="Float"/></f></GetMS>
		<delay public="1" set="method" line="92" static="1"><f a="_f:_time">
	<f a=""><x path="Void"/></f>
	<x path="Int"/>
	<c path="haxe.Timer"/>
</f></delay>
		<stamp public="1" set="method" line="105" static="1"><f a=""><x path="Float"/></f></stamp>
		<nme_time_stamp line="109" static="1"><f a=""><x path="Float"/></f></nme_time_stamp>
		<stop public="1" set="method" line="32"><f a=""><x path="Void"/></f></stop>
		<run public="1" set="dynamic" line="30"><f a=""><x path="Void"/></f></run>
		<running public="1">
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</running>
		<fire_at public="1">
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</fire_at>
		<time public="1">
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</time>
		<new public="1" set="method" line="13"><f a="_time">
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="haxe.TypeResolver" params="" file="/usr/lib/haxe/std/haxe/Unserializer.hx" module="haxe.Unserializer"><a>
	<resolveEnum set="method"><f a="name">
	<c path="String"/>
	<x path="Enum"><d/></x>
</f></resolveEnum>
	<resolveClass set="method"><f a="name">
	<c path="String"/>
	<x path="Class"><d/></x>
</f></resolveClass>
</a></typedef>
	<class path="haxe.crypto.Crc32" params="" file="/usr/lib/haxe/std/haxe/crypto/Crc32.hx">
		<get public="1" set="method" line="57"><f a=""><x path="Int"/></f></get>
		<update public="1" set="method" line="43"><f a="b:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></update>
		<byte public="1" set="method" line="32"><f a="b">
	<x path="Int"/>
	<x path="Void"/>
</f></byte>
		<crc><x path="Int"/></crc>
		<new public="1" set="method" line="28"><f a=""><x path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.ds.BalancedTree" params="K:V" file="/usr/lib/haxe/std/haxe/ds/BalancedTree.hx">
		<compare set="method" line="147"><f a="k1:k2">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.K"/>
	<x path="Int"/>
</f></compare>
		<balance set="method" line="133"><f a="l:k:v:r">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></balance>
		<setLoop set="method" line="78"><f a="k:v:node">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></setLoop>
		<exists public="1" set="method" line="55"><f a="k">
	<c path="haxe.ds.BalancedTree.K"/>
	<x path="Bool"/>
</f></exists>
		<set public="1" set="method" line="30"><f a="k:v">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<x path="Void"/>
</f></set>
		<root><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
</c></root>
		<new public="1" set="method" line="28"><f a=""><x path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.ds.TreeNode" params="K:V" file="/usr/lib/haxe/std/haxe/ds/BalancedTree.hx" module="haxe.ds.BalancedTree">
		<_height><x path="Int"/></_height>
		<value public="1"><c path="haxe.ds.TreeNode.V"/></value>
		<key public="1"><c path="haxe.ds.TreeNode.K"/></key>
		<right public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></right>
		<left public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></left>
		<new public="1" set="method" line="166"><f a="l:k:v:r:?h">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.TreeNode.K"/>
		<c path="haxe.ds.TreeNode.V"/>
	</c>
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.TreeNode.K"/>
		<c path="haxe.ds.TreeNode.V"/>
	</c>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.ds.EnumValueMap" params="K:V" file="/usr/lib/haxe/std/haxe/ds/EnumValueMap.hx">
		<extends path="haxe.ds.BalancedTree">
			<c path="haxe.ds.EnumValueMap.K"/>
			<c path="haxe.ds.EnumValueMap.V"/>
		</extends>
		<implements path="IMap">
			<c path="haxe.ds.EnumValueMap.K"/>
			<c path="haxe.ds.EnumValueMap.V"/>
		</implements>
		<compareArgs set="method" line="36"><f a="a1:a2">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<x path="Int"/>
</f></compareArgs>
		<compare set="method" line="27" override="1"><f a="k1:k2">
	<x path="EnumValue"/>
	<x path="EnumValue"/>
	<x path="Int"/>
</f></compare>
		<new public="1" set="method" line="25"><f a=""><x path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<abstract path="haxe.ds.HashMap" params="K:V" file="/usr/lib/haxe/std/haxe/ds/HashMap.hx"/>
	<class path="haxe.ds.IntMap" params="T" file="/usr/lib/haxe/std/cpp/_std/haxe/ds/IntMap.hx">
		<implements path="IMap">
			<x path="Int"/>
			<c path="haxe.ds.IntMap.T"/>
		</implements>
		<iterator public="1" set="method" line="53">
			<f a=""><t path="Iterator"><c path="haxe.ds.IntMap.T"/></t></f>
			<haxe_doc>Returns an iterator of all values in the hashtable.</haxe_doc>
		</iterator>
		<remove public="1" set="method" line="44">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes a hashtable entry. Returns [true] if
		there was such entry.</haxe_doc>
		</remove>
		<exists public="1" set="method" line="40">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.</haxe_doc>
		</exists>
		<get public="1" set="method" line="36">
			<f a="key">
				<x path="Int"/>
				<t path="Null"><c path="haxe.ds.IntMap.T"/></t>
			</f>
			<haxe_doc>Get a value for the given key.</haxe_doc>
		</get>
		<set public="1" set="method" line="32">
			<f a="key:value">
				<x path="Int"/>
				<c path="haxe.ds.IntMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set a value for the given key.</haxe_doc>
		</set>
		<h><d/></h>
		<new public="1" set="method" line="28">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty hashtable.</haxe_doc>
		</new>
		<haxe_doc>Hashtable over a set of elements, using [Int] as keys.
	On Flash and Javascript, the underlying structure is an Object.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.ds.ObjectMap" params="K:V" file="/usr/lib/haxe/std/cpp/_std/haxe/ds/ObjectMap.hx">
		<implements path="IMap">
			<c path="haxe.ds.ObjectMap.K"/>
			<c path="haxe.ds.ObjectMap.V"/>
		</implements>
		<iterator public="1" set="method" line="57"><f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.V"/></t></f></iterator>
		<get public="1" set="method" line="37"><f a="key">
	<c path="haxe.ds.ObjectMap.K"/>
	<t path="Null"><c path="haxe.ds.ObjectMap.V"/></t>
</f></get>
		<__Internal><c path="haxe.ds.IntMap"><c path="haxe.ds.ObjectMap.V"/></c></__Internal>
		<new public="1" set="method" line="29"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.ds.StringMap" params="T" file="/usr/lib/haxe/std/cpp/_std/haxe/ds/StringMap.hx">
		<implements path="IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<iterator public="1" set="method" line="59">
			<f a=""><t path="Iterator"><c path="haxe.ds.StringMap.T"/></t></f>
			<haxe_doc>Returns an iterator of all values in the hashtable.</haxe_doc>
		</iterator>
		<keys public="1" set="method" line="50">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>Returns an iterator of all keys in the hashtable.</haxe_doc>
		</keys>
		<remove public="1" set="method" line="43">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes a hashtable entry. Returns [true] if
		there was such entry.</haxe_doc>
		</remove>
		<exists public="1" set="method" line="39">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.</haxe_doc>
		</exists>
		<get public="1" set="method" line="35">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="haxe.ds.StringMap.T"/></t>
			</f>
			<haxe_doc>Get a value for the given key.</haxe_doc>
		</get>
		<set public="1" set="method" line="31">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set a value for the given key.</haxe_doc>
		</set>
		<__Internal><d/></__Internal>
		<new public="1" set="method" line="27">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty hashtable.</haxe_doc>
		</new>
		<haxe_doc>Hashtable over a set of elements, using [String] as keys.
	Other kind of keys are not possible on all platforms since they
	can't always be implemented efficiently.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.io.BytesBuffer" params="" file="/usr/lib/haxe/std/haxe/io/BytesBuffer.hx">
		<getBytes public="1" set="method" line="123">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>Returns either a copy or a reference of the current bytes.
		Once called, the buffer can no longer be used.</haxe_doc>
		</getBytes>
		<b><t path="haxe.io.BytesData"/></b>
		<new public="1" set="method" line="42"><f a=""><x path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.Unsigned_char__" params="" file="/usr/lib/haxe/std/haxe/io/BytesData.hx" module="haxe.io.BytesData" extern="1"/>
	<typedef path="haxe.io.BytesData" params="" file="/usr/lib/haxe/std/haxe/io/BytesData.hx"><c path="Array"><c path="haxe.io.Unsigned_char__"/></c></typedef>
	<class path="haxe.io.BytesInput" params="" file="/usr/lib/haxe/std/haxe/io/BytesInput.hx">
		<extends path="haxe.io.Input"/>
		<readBytes public="1" set="method" line="91" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<readByte public="1" set="method" line="70" override="1"><f a=""><x path="Int"/></f></readByte>
		<len><x path="Int"/></len>
		<pos><x path="Int"/></pos>
		<b><t path="haxe.io.BytesData"/></b>
		<new public="1" set="method" line="33"><f a="b:?pos:?len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.Eof" params="" file="/usr/lib/haxe/std/haxe/io/Eof.hx">
		<toString set="method" line="30">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<new public="1" set="method" line="28"><f a=""><x path="Void"/></f></new>
		<haxe_doc>This exception is raised when reading while data is no longer available in the [Input].</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<enum path="haxe.io.Error" params="" file="/usr/lib/haxe/std/haxe/io/Error.hx">
		<Overflow><haxe_doc>An integer value is outside its allowed range</haxe_doc></Overflow>
		<OutsideBounds><haxe_doc>An operation on Bytes is outside of its valid range</haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc>Other errors</haxe_doc>
		</Custom>
		<Blocked><haxe_doc>The IO is set into nonblocking mode and some data cannot be read or written</haxe_doc></Blocked>
		<haxe_doc>The possible IO errors that can occur</haxe_doc>
	</enum>
	<class path="haxe.io.Path" params="" file="/usr/lib/haxe/std/haxe/io/Path.hx">
		<directory public="1" set="method" line="140" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the directory of [path].
		
		If the directory is null, the empty String "" is returned.
		
		If [path] is null, the result is unspecified.</haxe_doc>
		</directory>
		<backslash public="1">
			<x path="Bool"/>
			<haxe_doc>True if the last directory separator is a backslash, false otherwise.</haxe_doc>
		</backslash>
		<ext public="1">
			<c path="String"/>
			<haxe_doc>The file extension.
		
		It is separated from the file name by a dot. This dot is not part of
		the extension.
		
		If the path has no extension, the value is null.</haxe_doc>
		</ext>
		<file public="1">
			<c path="String"/>
			<haxe_doc>The file name.
		
		This is the part of the part between the directory and the extension.
		
		If there is no file name, e.g. for ".htaccess" or "/dir/", the value
		is the empty String "".</haxe_doc>
		</file>
		<dir public="1">
			<c path="String"/>
			<haxe_doc>The directory.
		
		This is the leading part of the path that is not part of the file name
		and the extension.
		
		Does not end with a / or \ separator.
		
		If the path has no directory, the value is null.</haxe_doc>
		</dir>
		<new public="1" set="method" line="75">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Path instance by parsing [path].
		
		Path information can be retrieved by accessing the dir, file and ext
		properties.</haxe_doc>
		</new>
		<haxe_doc>This class provides a convenient way of working with paths. It supports the
	common path formats:
		directory1/directory2/filename.extension
		directory1\directory2\filename.excention</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="hxcollision.Collision" params="" file="/Users/Sven/dev/hxcollision/hxcollision/Collision.hx">
		<testShapeList public="1" set="method" line="18" static="1"><f a="shape1:shapes">
	<c path="hxcollision.shapes.BaseShape"/>
	<c path="Array"><c path="hxcollision.shapes.BaseShape"/></c>
	<c path="Array"><c path="hxcollision.CollisionData"/></c>
</f></testShapeList>
		<testShapes public="1" set="method" line="33" static="1"><f a="shape1:shape2">
	<c path="hxcollision.shapes.BaseShape"/>
	<c path="hxcollision.shapes.BaseShape"/>
	<c path="hxcollision.CollisionData"/>
</f></testShapes>
		<rayCollision public="1" set="method" line="55" static="1"><f a="lineStart:lineEnd:shapes">
	<c path="hxcollision.math.Vector2D"/>
	<c path="hxcollision.math.Vector2D"/>
	<c path="Array"><c path="hxcollision.shapes.BaseShape"/></c>
	<x path="Bool"/>
</f></rayCollision>
		<testCircleLine public="1" set="method" line="85" static="1"><f a="circle:lineStart:lineEnd">
	<c path="hxcollision.shapes.Circle"/>
	<c path="hxcollision.math.Vector2D"/>
	<c path="hxcollision.math.Vector2D"/>
	<x path="Bool"/>
</f></testCircleLine>
		<swap set="method" line="119" static="1"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<c path="hxcollision.math.Vector2D"/>
</f></swap>
		<bresenhamLine public="1" set="method" line="125" static="1"><f a="start:end">
	<c path="hxcollision.math.Vector2D"/>
	<c path="hxcollision.math.Vector2D"/>
	<c path="Array"><c path="hxcollision.math.Vector2D"/></c>
</f></bresenhamLine>
		<pointInPoly public="1" set="method" line="193" static="1"><f a="point:poly">
	<c path="hxcollision.math.Vector2D"/>
	<c path="hxcollision.shapes.Polygon"/>
	<x path="Bool"/>
</f></pointInPoly>
		<checkCircleVsPolygon set="method" line="222" static="1"><f a="circle:polygon">
	<c path="hxcollision.shapes.Circle"/>
	<c path="hxcollision.shapes.Polygon"/>
	<c path="hxcollision.CollisionData"/>
</f></checkCircleVsPolygon>
		<checkCircles set="method" line="355" static="1"><f a="circle1:circle2">
	<c path="hxcollision.shapes.Circle"/>
	<c path="hxcollision.shapes.Circle"/>
	<c path="hxcollision.CollisionData"/>
</f></checkCircles>
		<checkPolygons set="method" line="372" static="1"><f a="polygon1:polygon2">
	<c path="hxcollision.shapes.Polygon"/>
	<c path="hxcollision.shapes.Polygon"/>
	<c path="hxcollision.CollisionData"/>
</f></checkPolygons>
		<findNormalAxis set="method" line="455" static="1"><f a="vertices:index">
	<c path="Array"><c path="hxcollision.math.Vector2D"/></c>
	<x path="Int"/>
	<c path="hxcollision.math.Vector2D"/>
</f></findNormalAxis>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="hxcollision.CollisionData" params="" file="/Users/Sven/dev/hxcollision/hxcollision/CollisionData.hx">
		<unitVector public="1"><c path="hxcollision.math.Vector2D"/></unitVector>
		<shape2 public="1"><c path="hxcollision.shapes.BaseShape"/></shape2>
		<shape1 public="1"><c path="hxcollision.shapes.BaseShape"/></shape1>
		<separation public="1"><c path="hxcollision.math.Vector2D"/></separation>
		<overlap public="1"><x path="Float"/></overlap>
		<new public="1" set="method" line="22"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="hxcollision.math.Matrix" params="" file="/Users/Sven/dev/hxcollision/hxcollision/math/Matrix.hx">
		<implements path="cpp.rtti.FieldNumericIntegerLookup"/>
		<toString public="1" set="method" line="66"><f a=""><c path="String"/></f></toString>
		<scale public="1" set="method" line="53"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scale>
		<rotate public="1" set="method" line="34"><f a="angle">
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
		<translate public="1" set="method" line="27"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translate>
		<ty public="1"><x path="Float"/></ty>
		<tx public="1"><x path="Float"/></tx>
		<d public="1"><x path="Float"/></d>
		<c public="1"><x path="Float"/></c>
		<b public="1"><x path="Float"/></b>
		<a public="1"><x path="Float"/></a>
		<new public="1" set="method" line="16"><f a="?a:?b:?c:?d:?tx:?ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="hxcollision.math.Vector2D" params="" file="/Users/Sven/dev/hxcollision/hxcollision/math/Vector2D.hx">
		<angleBetween public="1" set="method" line="193" static="1">
			<f a="vector1:vector2">
				<c path="hxcollision.math.Vector2D"/>
				<c path="hxcollision.math.Vector2D"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Calculate angle between any two vectors.
         * @param vector1 First vector2d.
         * @param vector2 Second vector2d.
         * @return Float Angle between vectors.</haxe_doc>
		</angleBetween>
		<toString public="1" set="method" line="322">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Turn this vector into a string.
         * @return String This vector in string form.</haxe_doc>
		</toString>
		<fromString public="1" set="method" line="307">
			<f a="string">
				<c path="String"/>
				<c path="hxcollision.math.Vector2D"/>
			</f>
			<haxe_doc>* Create a vector2D from a string
         * @param string The string to turn into a vector. Must be in the toString format.
         * @return Vector2D The vector from the string.</haxe_doc>
		</fromString>
		<get_x set="method" line="298"><f a=""><x path="Float"/></f></get_x>
		<set_x set="method" line="294">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Set and get x component.</haxe_doc>
		</set_x>
		<get_y set="method" line="287"><f a=""><x path="Float"/></f></get_y>
		<set_y set="method" line="283">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Set and get y component.</haxe_doc>
		</set_y>
		<divide public="1" set="method" line="274">
			<f a="scalar">
				<x path="Float"/>
				<c path="hxcollision.math.Vector2D"/>
			</f>
			<haxe_doc>* Divide this vector by a scalar.
         * @param scalar The scalar to divide by.
         * @return Vector2D This vector.</haxe_doc>
		</divide>
		<multiply public="1" set="method" line="263">
			<f a="scalar">
				<x path="Float"/>
				<c path="hxcollision.math.Vector2D"/>
			</f>
			<haxe_doc>* Mutiplies this vector by another one.
         * @param scalar The scalar to multiply by.
         * @return Vector2D This vector, multiplied.</haxe_doc>
		</multiply>
		<subtract public="1" set="method" line="252">
			<f a="vector2">
				<c path="hxcollision.math.Vector2D"/>
				<c path="hxcollision.math.Vector2D"/>
			</f>
			<haxe_doc>* Subtract a vector from this one.
         * @param vector2 The vector to subtract.
         * @return Vector2D This vector.</haxe_doc>
		</subtract>
		<add public="1" set="method" line="241">
			<f a="vector2">
				<c path="hxcollision.math.Vector2D"/>
				<c path="hxcollision.math.Vector2D"/>
			</f>
			<haxe_doc>* Add a vector to this vector.
         * @param vector2 The vector to add to this one.
         * @return Vector2D This vector.</haxe_doc>
		</add>
		<distSQ public="1" set="method" line="230">
			<f a="vector2">
				<c path="hxcollision.math.Vector2D"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Calculate squared distance between vectors. Faster than distance.
         * @param vector2 The other vector.
         * @return Float The squared distance between the vectors.</haxe_doc>
		</distSQ>
		<distance public="1" set="method" line="221">
			<f a="vector2">
				<c path="hxcollision.math.Vector2D"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Calculate between two vectors.
         * @param vector2 The vector to find distance.
         * @return Float The distance.</haxe_doc>
		</distance>
		<get_perpendicular set="method" line="212">
			<f a=""><c path="hxcollision.math.Vector2D"/></f>
			<haxe_doc>* Get the vector that is perpendicular.
         * @return Vector2D The perpendicular vector.</haxe_doc>
		</get_perpendicular>
		<sign public="1" set="method" line="204">
			<f a="vector2">
				<c path="hxcollision.math.Vector2D"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Is the vector to the right or left of this one?
         * @param vector2 The vector to test.
         * @return Bool If left, returns true, if right, false.</haxe_doc>
		</sign>
		<crossProd public="1" set="method" line="183">
			<f a="vector2">
				<c path="hxcollision.math.Vector2D"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Calculate the cross product of this and another vector.
         * @param vector2 Another Vector2D.
         * @return Float The cross product.</haxe_doc>
		</crossProd>
		<dotProduct public="1" set="method" line="174">
			<f a="vector2">
				<c path="hxcollision.math.Vector2D"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Calculate the dot product of this vector and another.
         * @param vector2 Another vector2D.
         * @return Float The dot product.</haxe_doc>
		</dotProduct>
		<reverse public="1" set="method" line="163">
			<f a=""><c path="hxcollision.math.Vector2D"/></f>
			<haxe_doc>* Makes the vector face the opposite way.
         * @return Vector2D This vector.</haxe_doc>
		</reverse>
		<truncate public="1" set="method" line="154">
			<f a="max">
				<x path="Float"/>
				<c path="hxcollision.math.Vector2D"/>
			</f>
			<haxe_doc>* Sets the length under the given value. Nothing is done if the vector is already shorter.
         * @param max The max length this vector can be.
         * @return Vector2D This vector.</haxe_doc>
		</truncate>
		<normalcate public="1" set="method" line="144">
			<f a="len">
				<x path="Float"/>
				<c path="hxcollision.math.Vector2D"/>
			</f>
			<haxe_doc>* Sets the vector's length to len.
         * @param len The length to set it to.
         * @return Vector2D This vector.</haxe_doc>
		</normalcate>
		<normalize public="1" set="method" line="128">
			<f a=""><c path="hxcollision.math.Vector2D"/></f>
			<haxe_doc>* Sets the vector's length to 1.
         * @return Vector2D This vector.</haxe_doc>
		</normalize>
		<get_angle set="method" line="120">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Get the angle of this vector.</haxe_doc>
		</get_angle>
		<set_angle set="method" line="111">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Changes the angle of the vector. X and Y will change, length stays the same.</haxe_doc>
		</set_angle>
		<get_lengthSquared set="method" line="104">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the length of this vector, before square root. Allows for a faster check.</haxe_doc>
		</get_lengthSquared>
		<get_length set="method" line="97">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the length of the vector.</haxe_doc>
		</get_length>
		<set_length public="1" set="method" line="86">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Sets the length which will change x and y, but not the angle.</haxe_doc>
		</set_length>
		<equals public="1" set="method" line="79">
			<f a="vector2">
				<c path="hxcollision.math.Vector2D"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Does this vector have the same location as another?
         * @param vector2 The vector to test.
         * @return Bool True if equal, false if not.</haxe_doc>
		</equals>
		<isNormalized public="1" set="method" line="70">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Is the vector's length = 1?
         * @return Bool If length is 1, true, else false.</haxe_doc>
		</isNormalized>
		<isZero public="1" set="method" line="62">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Is this vector zeroed?
         * @return Bool Returns true if zeroed, else returns false.</haxe_doc>
		</isZero>
		<zeroVector public="1" set="method" line="52">
			<f a=""><c path="hxcollision.math.Vector2D"/></f>
			<haxe_doc>* Makes x and y zero.
         * @return Vector2D This vector.</haxe_doc>
		</zeroVector>
		<transform public="1" set="method" line="41">
			<f a="matrix">
				<c path="hxcollision.math.Matrix"/>
				<c path="hxcollision.math.Vector2D"/>
			</f>
			<haxe_doc>*  Transforms Vector2D based on the given Matrix
         * @param matrix The matrix to use to transform this vector.
         * @return Vector2D returns a new, transformed Vector2D.</haxe_doc>
		</transform>
		<cloneVector public="1" set="method" line="32">
			<f a=""><c path="hxcollision.math.Vector2D"/></f>
			<haxe_doc>* Creates an exact copy of this Vector2D
         * @return Vector2D A copy of this Vector2D</haxe_doc>
		</cloneVector>
		<perpendicular public="1" get="accessor" set="null"><c path="hxcollision.math.Vector2D"/></perpendicular>
		<lengthSquared public="1" get="accessor" set="null"><x path="Float"/></lengthSquared>
		<length public="1" get="accessor" set="accessor"><x path="Float"/></length>
		<angle public="1" get="accessor" set="accessor"><x path="Float"/></angle>
		<y public="1" get="accessor" set="accessor"><x path="Float"/></y>
		<x public="1" get="accessor" set="accessor"><x path="Float"/></x>
		<_y><x path="Float"/></_y>
		<_x><x path="Float"/></_x>
		<new public="1" set="method" line="16">
			<f a="?x:?y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor</haxe_doc>
		</new>
		<haxe_doc>* 2D vector class</haxe_doc>
	</class>
	<class path="hxcollision.shapes.BaseShape" params="" file="/Users/Sven/dev/hxcollision/hxcollision/shapes/BaseShape.hx">
		<destroy public="1" set="method" line="160"><f a=""><x path="Void"/></f></destroy>
		<get_vertices set="method" line="154"><f a=""><c path="Array"><c path="hxcollision.math.Vector2D"/></c></f></get_vertices>
		<get_transformedVertices set="method" line="136"><f a=""><c path="Array"><c path="hxcollision.math.Vector2D"/></c></f></get_transformedVertices>
		<set_scaleY set="method" line="127"><f a="scale">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleY>
		<get_scaleY set="method" line="123"><f a=""><x path="Float"/></f></get_scaleY>
		<set_scaleX set="method" line="114"><f a="scale">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleX>
		<get_scaleX set="method" line="110"><f a=""><x path="Float"/></f></get_scaleX>
		<set_rotation set="method" line="101"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rotation>
		<get_rotation set="method" line="97"><f a=""><x path="Float"/></f></get_rotation>
		<set_y set="method" line="88"><f a="y">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<get_y set="method" line="84"><f a=""><x path="Float"/></f></get_y>
		<set_x set="method" line="75"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<get_x set="method" line="71"><f a=""><x path="Float"/></f></get_x>
		<set_position set="method" line="61"><f a="v">
	<c path="hxcollision.math.Vector2D"/>
	<c path="hxcollision.math.Vector2D"/>
</f></set_position>
		<get_position set="method" line="57"><f a=""><c path="hxcollision.math.Vector2D"/></f></get_position>
		<vertices public="1" get="accessor" set="null"><c path="Array"><c path="hxcollision.math.Vector2D"/></c></vertices>
		<transformedVertices public="1" get="accessor" set="null"><c path="Array"><c path="hxcollision.math.Vector2D"/></c></transformedVertices>
		<scaleY public="1" get="accessor" set="accessor"><x path="Float"/></scaleY>
		<scaleX public="1" get="accessor" set="accessor"><x path="Float"/></scaleX>
		<rotation public="1" get="accessor" set="accessor"><x path="Float"/></rotation>
		<y public="1" get="accessor" set="accessor"><x path="Float"/></y>
		<x public="1" get="accessor" set="accessor"><x path="Float"/></x>
		<position public="1" get="accessor" set="accessor"><c path="hxcollision.math.Vector2D"/></position>
		<data public="1"><d/></data>
		<name public="1"><c path="String"/></name>
		<_vertices><c path="Array"><c path="hxcollision.math.Vector2D"/></c></_vertices>
		<_transformedVertices><c path="Array"><c path="hxcollision.math.Vector2D"/></c></_transformedVertices>
		<_transformMatrix><c path="hxcollision.math.Matrix"/></_transformMatrix>
		<_transformed><x path="Bool"/></_transformed>
		<_scaleY><x path="Float"/></_scaleY>
		<_scaleX><x path="Float"/></_scaleX>
		<_rotation><x path="Float"/></_rotation>
		<_position><c path="hxcollision.math.Vector2D"/></_position>
		<new public="1" set="method" line="25"><f a="_pos">
	<c path="hxcollision.math.Vector2D"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="hxcollision.shapes.Circle" params="" file="/Users/Sven/dev/hxcollision/hxcollision/shapes/Circle.hx">
		<extends path="hxcollision.shapes.BaseShape"/>
		<get_transformedRadius set="method" line="17"><f a=""><x path="Float"/></f></get_transformedRadius>
		<get_radius set="method" line="13"><f a=""><x path="Float"/></f></get_radius>
		<transformedRadius public="1" get="accessor" set="null"><x path="Float"/></transformedRadius>
		<radius public="1" get="accessor" set="null"><x path="Float"/></radius>
		<_radius><x path="Float"/></_radius>
		<new public="1" set="method" line="21"><f a="radius:position">
	<x path="Float"/>
	<c path="hxcollision.math.Vector2D"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="hxcollision.shapes.Polygon" params="" file="/Users/Sven/dev/hxcollision/hxcollision/shapes/Polygon.hx">
		<extends path="hxcollision.shapes.BaseShape"/>
		<create public="1" set="method" line="30" static="1"><f a="sides:?radius:?position">
	<x path="Int"/>
	<x path="Float"/>
	<c path="hxcollision.math.Vector2D"/>
	<c path="hxcollision.shapes.Polygon"/>
</f></create>
		<rectangle public="1" set="method" line="54" static="1"><f a="width:height:position:?centered">
	<x path="Float"/>
	<x path="Float"/>
	<c path="hxcollision.math.Vector2D"/>
	<x path="Bool"/>
	<c path="hxcollision.shapes.Polygon"/>
</f></rectangle>
		<square public="1" set="method" line="77" static="1"><f a="width:position">
	<x path="Float"/>
	<c path="hxcollision.math.Vector2D"/>
	<c path="hxcollision.shapes.Polygon"/>
</f></square>
		<destroy public="1" set="method" line="17" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="8"><f a="vertices:position">
	<c path="Array"><c path="hxcollision.math.Vector2D"/></c>
	<c path="hxcollision.math.Vector2D"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.AssetData" params="" file="bin/mac64/cpp/haxe/lime/AssetData.hx">
		<initialized line="8" static="1"><x path="Bool"/></initialized>
		<library public="1" line="10" static="1"><x path="Map">
	<c path="String"/>
	<e path="lime.utils.LibraryType"/>
</x></library>
		<path public="1" line="11" static="1"><x path="Map">
	<c path="String"/>
	<c path="String"/>
</x></path>
		<type public="1" line="12" static="1"><x path="Map">
	<c path="String"/>
	<e path="lime.utils.AssetType"/>
</x></type>
		<initialize public="1" set="method" line="14" static="1"><f a=""><x path="Void"/></f></initialize>
	</class>
	<class path="lime.SoundTransform" params="" file="/Users/Sven/dev/lab/lime/lime/AudioHandler.hx" module="lime.AudioHandler">
		<clone public="1" set="method" line="15"><f a=""><c path="lime.SoundTransform"/></f></clone>
		<volume public="1"><x path="Float"/></volume>
		<pan public="1"><x path="Float"/></pan>
		<new public="1" set="method" line="10"><f a="?vol:?panning">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.Sound" params="" file="/Users/Sven/dev/lab/lime/lime/AudioHandler.hx" module="lime.AudioHandler">
		<nme_sound_channel_create line="75" static="1"><f a=":::">
	<d/>
	<t path="Null"><x path="Float"/></t>
	<t path="Null"><x path="Int"/></t>
	<c path="lime.SoundTransform"/>
	<unknown/>
</f></nme_sound_channel_create>
		<nme_sound_channel_stop line="76" static="1"><f a="">
	<d/>
	<unknown/>
</f></nme_sound_channel_stop>
		<nme_sound_channel_set_transform line="77" static="1"><f a=":">
	<d/>
	<c path="lime.SoundTransform"/>
	<unknown/>
</f></nme_sound_channel_set_transform>
		<set_pan public="1" set="method" line="64"><f a="_p">
	<x path="Float"/>
	<x path="Float"/>
</f></set_pan>
		<set_volume public="1" set="method" line="55"><f a="_v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_volume>
		<stop public="1" set="method" line="44"><f a=""><x path="Void"/></f></stop>
		<play public="1" set="method" line="36"><f a="?_loops:?_start">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></play>
		<_transform><c path="lime.SoundTransform"/></_transform>
		<pan public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</pan>
		<volume public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</volume>
		<sound public="1"><d/></sound>
		<handle public="1"><d/></handle>
		<new public="1" set="method" line="29"><f a="_handle:?_sound">
	<d/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.AudioHandler" params="" file="/Users/Sven/dev/lab/lime/lime/AudioHandler.hx">
		<nme_sound_from_file line="108" static="1"><f a=":">
	<t path="Null"><c path="String"/></t>
	<t path="Null"><x path="Bool"/></t>
	<unknown/>
</f></nme_sound_from_file>
		<nme_sound_from_data line="109" static="1"><unknown/></nme_sound_from_data>
		<create_sound public="1" set="method" line="94"><f a="_name:_file:?_music">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></create_sound>
		<startup public="1" set="method" line="88"><f a=""><x path="Void"/></f></startup>
		<sounds public="1"><x path="Map">
	<c path="String"/>
	<c path="lime.Sound"/>
</x></sounds>
		<lib public="1"><c path="lime.LiME"/></lib>
		<new public="1" set="method" line="85"><f a="_lib">
	<c path="lime.LiME"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.Window" params="" file="/Users/Sven/dev/lab/lime/lime/Constants.hx" module="lime.Constants">
		<FULLSCREEN public="1" line="6" static="1"><x path="Int"/></FULLSCREEN>
		<BORDERLESS public="1" line="7" static="1"><x path="Int"/></BORDERLESS>
		<RESIZABLE public="1" line="8" static="1"><x path="Int"/></RESIZABLE>
		<HARDWARE public="1" line="9" static="1"><x path="Int"/></HARDWARE>
		<VSYNC public="1" line="10" static="1"><x path="Int"/></VSYNC>
		<HW_AA public="1" line="11" static="1"><x path="Int"/></HW_AA>
		<HW_AA_HIRES public="1" line="12" static="1"><x path="Int"/></HW_AA_HIRES>
		<ALLOW_SHADERS public="1" line="13" static="1"><x path="Int"/></ALLOW_SHADERS>
		<REQUIRE_SHADERS public="1" line="14" static="1"><x path="Int"/></REQUIRE_SHADERS>
		<DEPTH_BUFFER public="1" line="15" static="1"><x path="Int"/></DEPTH_BUFFER>
		<STENCIL_BUFFER public="1" line="16" static="1"><x path="Int"/></STENCIL_BUFFER>
	</class>
	<class path="lime.SystemEvents" params="" file="/Users/Sven/dev/lab/lime/lime/Constants.hx" module="lime.Constants">
		<char public="1" line="22" static="1"><x path="Int"/></char>
		<keydown public="1" line="23" static="1"><x path="Int"/></keydown>
		<keyup public="1" line="24" static="1"><x path="Int"/></keyup>
		<mousemove public="1" line="25" static="1"><x path="Int"/></mousemove>
		<mousedown public="1" line="26" static="1"><x path="Int"/></mousedown>
		<mouseclick public="1" line="27" static="1"><x path="Int"/></mouseclick>
		<mouseup public="1" line="28" static="1"><x path="Int"/></mouseup>
		<resize public="1" line="29" static="1"><x path="Int"/></resize>
		<poll public="1" line="30" static="1"><x path="Int"/></poll>
		<quit public="1" line="31" static="1"><x path="Int"/></quit>
		<focus public="1" line="32" static="1"><x path="Int"/></focus>
		<shouldrotate public="1" line="33" static="1"><x path="Int"/></shouldrotate>
		<redraw public="1" line="35" static="1"><x path="Int"/></redraw>
		<touchbegin public="1" line="36" static="1"><x path="Int"/></touchbegin>
		<touchmove public="1" line="37" static="1"><x path="Int"/></touchmove>
		<touchend public="1" line="38" static="1"><x path="Int"/></touchend>
		<touchtap public="1" line="39" static="1"><x path="Int"/></touchtap>
		<change public="1" line="40" static="1"><x path="Int"/></change>
		<activate public="1" line="41" static="1"><x path="Int"/></activate>
		<deactivate public="1" line="42" static="1"><x path="Int"/></deactivate>
		<gotinputfocus public="1" line="43" static="1"><x path="Int"/></gotinputfocus>
		<lostinputfocus public="1" line="44" static="1"><x path="Int"/></lostinputfocus>
		<joyaxismove public="1" line="45" static="1"><x path="Int"/></joyaxismove>
		<joyballmove public="1" line="46" static="1"><x path="Int"/></joyballmove>
		<joyhatmove public="1" line="47" static="1"><x path="Int"/></joyhatmove>
		<joybuttondown public="1" line="48" static="1"><x path="Int"/></joybuttondown>
		<joybuttonup public="1" line="49" static="1"><x path="Int"/></joybuttonup>
		<syswm public="1" line="50" static="1"><x path="Int"/></syswm>
	</class>
	<class path="lime.InputHandler" params="" file="/Users/Sven/dev/lab/lime/lime/InputHandler.hx">
		<efLeftDown line="389" static="1"><x path="Int"/></efLeftDown>
		<efShiftDown line="390" static="1"><x path="Int"/></efShiftDown>
		<efCtrlDown line="391" static="1"><x path="Int"/></efCtrlDown>
		<efAltDown line="392" static="1"><x path="Int"/></efAltDown>
		<efCommandDown line="393" static="1"><x path="Int"/></efCommandDown>
		<lime_apply_input_listeners set="method" line="395"><f a=""><x path="Void"/></f></lime_apply_input_listeners>
		<lime_joybuttonup public="1" set="method" line="381"><f a="_event">
	<d/>
	<x path="Void"/>
</f></lime_joybuttonup>
		<lime_joybuttondown public="1" set="method" line="374"><f a="_event">
	<d/>
	<x path="Void"/>
</f></lime_joybuttondown>
		<lime_joyhatmove public="1" set="method" line="367"><f a="_event">
	<d/>
	<x path="Void"/>
</f></lime_joyhatmove>
		<lime_joyballmove public="1" set="method" line="360"><f a="_event">
	<d/>
	<x path="Void"/>
</f></lime_joyballmove>
		<lime_joyaxismove public="1" set="method" line="353"><f a="_event">
	<d/>
	<x path="Void"/>
</f></lime_joyaxismove>
		<lime_touchtap public="1" set="method" line="344"><f a="_event">
	<d/>
	<x path="Void"/>
</f></lime_touchtap>
		<lime_touchend public="1" set="method" line="320"><f a="_event">
	<d/>
	<x path="Void"/>
</f></lime_touchend>
		<lime_touchmove public="1" set="method" line="303"><f a="_event">
	<d/>
	<x path="Void"/>
</f></lime_touchmove>
		<lime_touchbegin public="1" set="method" line="278"><f a="_event">
	<d/>
	<x path="Void"/>
</f></lime_touchbegin>
		<lime_mouseup public="1" set="method" line="247"><f a="_event:?_pass_through">
	<d/>
	<x path="Bool"/>
	<x path="Void"/>
</f></lime_mouseup>
		<lime_mouseclick public="1" set="method" line="218"><f a="_event:?_pass_through">
	<d/>
	<x path="Bool"/>
	<x path="Void"/>
</f></lime_mouseclick>
		<lime_mousedown public="1" set="method" line="189"><f a="_event:?_pass_through">
	<d/>
	<x path="Bool"/>
	<x path="Void"/>
</f></lime_mousedown>
		<lime_mousemove public="1" set="method" line="149"><f a="_event:?_pass_through">
	<d/>
	<x path="Bool"/>
	<x path="Void"/>
</f></lime_mousemove>
		<mouse_button_from_id set="method" line="138"><f a="id">
	<x path="Int"/>
	<d/>
</f></mouse_button_from_id>
		<lime_lostinputfocus public="1" set="method" line="118"><f a="_event">
	<d/>
	<x path="Void"/>
</f></lime_lostinputfocus>
		<lime_gotinputfocus public="1" set="method" line="99"><f a="_event">
	<d/>
	<x path="Void"/>
</f></lime_gotinputfocus>
		<lime_onkeyup public="1" set="method" line="80"><f a="_event">
	<d/>
	<x path="Void"/>
</f></lime_onkeyup>
		<lime_onkeydown public="1" set="method" line="60"><f a="_event">
	<d/>
	<x path="Void"/>
</f></lime_onkeydown>
		<lime_onchar public="1" set="method" line="40"><f a="_event">
	<d/>
	<x path="Void"/>
</f></lime_onchar>
		<process public="1" set="method" line="34"><f a=""><x path="Void"/></f></process>
		<shutdown public="1" set="method" line="30"><f a=""><x path="Void"/></f></shutdown>
		<startup public="1" set="method" line="18"><f a=""><x path="Void"/></f></startup>
		<last_mouse_y public="1"><x path="Int"/></last_mouse_y>
		<last_mouse_x public="1"><x path="Int"/></last_mouse_x>
		<down_keys public="1"><x path="Map">
	<x path="Int"/>
	<x path="Bool"/>
</x></down_keys>
		<touch_map public="1"><x path="Map">
	<x path="Int"/>
	<d/>
</x></touch_map>
		<lib public="1"><c path="lime.LiME"/></lib>
		<new public="1" set="method" line="10"><f a="_lib">
	<c path="lime.LiME"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="lime.TouchState" params="" file="/Users/Sven/dev/lab/lime/lime/InputHandler.hx" module="lime.InputHandler">
		<move/>
		<end/>
		<begin/>
	</enum>
	<enum path="lime.MouseState" params="" file="/Users/Sven/dev/lab/lime/lime/InputHandler.hx" module="lime.InputHandler">
		<up/>
		<move/>
		<down/>
	</enum>
	<enum path="lime.MouseButton" params="" file="/Users/Sven/dev/lab/lime/lime/InputHandler.hx" module="lime.InputHandler">
		<wheel_up/>
		<wheel_down/>
		<right/>
		<move/>
		<middle/>
		<left/>
	</enum>
	<typedef path="lime.KeyEvent" params="" file="/Users/Sven/dev/lab/lime/lime/InputHandler.hx" module="lime.InputHandler"><a>
	<value><x path="Int"/></value>
	<shift_down><x path="Bool"/></shift_down>
	<raw><d/></raw>
	<meta_down><x path="Bool"/></meta_down>
	<key><e path="lime.utils.KeyValue"/></key>
	<flags><x path="Int"/></flags>
	<ctrl_down><x path="Bool"/></ctrl_down>
	<code><x path="Int"/></code>
	<char><x path="Int"/></char>
	<alt_down><x path="Bool"/></alt_down>
</a></typedef>
	<typedef path="lime.TouchEvent" params="" file="/Users/Sven/dev/lab/lime/lime/InputHandler.hx" module="lime.InputHandler"><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
	<state><e path="lime.TouchState"/></state>
	<raw><d/></raw>
	<flags><x path="Int"/></flags>
	<ID><x path="Int"/></ID>
</a></typedef>
	<typedef path="lime.MouseEvent" params="" file="/Users/Sven/dev/lab/lime/lime/InputHandler.hx" module="lime.InputHandler"><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
	<state><e path="lime.MouseState"/></state>
	<shift_down><x path="Bool"/></shift_down>
	<raw><d/></raw>
	<meta_down><x path="Bool"/></meta_down>
	<flags><x path="Int"/></flags>
	<deltaY><x path="Float"/></deltaY>
	<deltaX><x path="Float"/></deltaX>
	<ctrl_down><x path="Bool"/></ctrl_down>
	<button><e path="lime.MouseButton"/></button>
	<alt_down><x path="Bool"/></alt_down>
</a></typedef>
	<typedef path="lime.GamepadEvent" params="" file="/Users/Sven/dev/lab/lime/lime/InputHandler.hx" module="lime.InputHandler"><a><raw><d/></raw></a></typedef>
	<class path="lime.LiME" params="" file="/Users/Sven/dev/lab/lime/lime/LiME.hx">
		<early_wakeup public="1" line="40" static="1">
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</early_wakeup>
		<nme_stage_request_render line="437" static="1"><unknown/></nme_stage_request_render>
		<nme_stage_set_next_wake line="438" static="1"><f a=":">
	<d/>
	<x path="Float"/>
	<unknown/>
</f></nme_stage_set_next_wake>
		<_debug public="1" set="method" line="421"><f a="value:?_verbose:?_more_verbose">
	<d/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></_debug>
		<more_verbose public="1"><x path="Bool"/></more_verbose>
		<verbose public="1"><x path="Bool"/></verbose>
		<log public="1"><x path="Bool"/></log>
		<__nextFrameDue set="method" line="391">
			<f a="_otherTimers">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__nextFrameDue>
		<__updateNextWake public="1" set="method" line="373">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__updateNextWake>
		<__checkRender set="method" line="344">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__checkRender>
		<perform_render public="1" set="method" line="334"><f a=""><x path="Void"/></f></perform_render>
		<on_update public="1" set="method" line="301"><f a="_event">
	<unknown/>
	<x path="Bool"/>
</f></on_update>
		<on_change public="1" set="method" line="295"><f a="ev">
	<d/>
	<x path="Void"/>
</f></on_change>
		<on_syswm public="1" set="method" line="291"><f a="ev">
	<d/>
	<x path="Void"/>
</f></on_syswm>
		<on_lime_event public="1" set="method" line="163"><f a="_event">
	<d/>
	<d/>
</f></on_lime_event>
		<cleanup public="1" set="method" line="157"><f a=""><x path="Void"/></f></cleanup>
		<shutdown public="1" set="method" line="133"><f a=""><x path="Void"/></f></shutdown>
		<on_window_ready public="1" set="method" line="94"><f a="handle">
	<d/>
	<x path="Void"/>
</f></on_window_ready>
		<init public="1" set="method" line="62"><f a="_main_:_config">
	<c path="luxe.Core"/>
	<d/>
	<x path="Void"/>
</f></init>
		<has_shutdown public="1"><x path="Bool"/></has_shutdown>
		<shutting_down public="1"><x path="Bool"/></shutting_down>
		<set_frame_rate set="method" line="41"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_frame_rate>
		<last_render_time><x path="Float"/></last_render_time>
		<frame_period><x path="Float"/></frame_period>
		<render_request_function public="1"><f a=""><x path="Void"/></f></render_request_function>
		<frame_rate public="1" set="accessor"><x path="Float"/></frame_rate>
		<view_handle public="1"><d/></view_handle>
		<window_handle public="1"><d/></window_handle>
		<window public="1"><c path="lime.WindowHandler"/></window>
		<render public="1"><c path="lime.RenderHandler"/></render>
		<input public="1"><c path="lime.InputHandler"/></input>
		<audio public="1"><c path="lime.AudioHandler"/></audio>
		<config public="1"><d/></config>
		<host public="1"><d/></host>
		<new public="1" set="method" line="59"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="lime.RenderHandler" params="" file="/Users/Sven/dev/lab/lime/lime/RenderHandler.hx">
		<nme_stage_request_render line="252" static="1"><f a=""><unknown/></f></nme_stage_request_render>
		<nme_render_stage line="253" static="1"><f a="">
	<d/>
	<unknown/>
</f></nme_render_stage>
		<nme_doc_add_child line="254" static="1"><f a=":">
	<d/>
	<d/>
	<unknown/>
</f></nme_doc_add_child>
		<nme_direct_renderer_create line="255" static="1"><f a=""><unknown/></f></nme_direct_renderer_create>
		<nme_direct_renderer_set line="256" static="1"><f a=":">
	<d/>
	<f a=""><x path="Void"/></f>
	<unknown/>
</f></nme_direct_renderer_set>
		<nme_stage_set_next_wake line="257" static="1"><unknown/></nme_stage_set_next_wake>
		<on_render public="1" set="method" line="241"><f a=""><x path="Void"/></f></on_render>
		<render public="1" set="method" line="213"><f a=""><x path="Bool"/></f></render>
		<request_render public="1" set="method" line="206"><f a=""><x path="Void"/></f></request_render>
		<on_resize public="1" set="method" line="115"><f a="_event">
	<d/>
	<x path="Void"/>
</f></on_resize>
		<shutdown public="1" set="method" line="111"><f a=""><x path="Void"/></f></shutdown>
		<startup public="1" set="method" line="50"><f a=""><x path="Void"/></f></startup>
		<direct_renderer_handle public="1"><d/></direct_renderer_handle>
		<lib public="1"><c path="lime.LiME"/></lib>
		<new public="1" set="method" line="39"><f a="_lib">
	<c path="lime.LiME"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.WindowHandler" params="" file="/Users/Sven/dev/lab/lime/lime/WindowHandler.hx">
		<nme_stage_get_stage_width line="313" static="1"><f a="">
	<d/>
	<unknown/>
</f></nme_stage_get_stage_width>
		<nme_stage_get_stage_height line="314" static="1"><f a="">
	<d/>
	<unknown/>
</f></nme_stage_get_stage_height>
		<nme_set_stage_handler line="315" static="1"><f a=":::">
	<d/>
	<f a="_event">
		<d/>
		<d/>
	</f>
	<d/>
	<d/>
	<unknown/>
</f></nme_set_stage_handler>
		<nme_get_frame_stage line="316" static="1"><f a="">
	<d/>
	<unknown/>
</f></nme_get_frame_stage>
		<nme_create_main_frame line="317" static="1"><f a=":::::">
	<f a="handle">
		<d/>
		<x path="Void"/>
	</f>
	<d/>
	<d/>
	<x path="Int"/>
	<d/>
	<unknown/>
	<unknown/>
</f></nme_create_main_frame>
		<nme_pause_animation line="318" static="1"><f a=""><unknown/></f></nme_pause_animation>
		<nme_resume_animation line="319" static="1"><f a=""><unknown/></f></nme_resume_animation>
		<nme_terminate line="320" static="1"><f a=""><unknown/></f></nme_terminate>
		<nme_close line="321" static="1"><f a=""><unknown/></f></nme_close>
		<nme_get_url line="322" static="1"><f a="">
	<c path="String"/>
	<unknown/>
</f></nme_get_url>
		<nme_file_dialog_save line="325" static="1"><f a="::">
	<c path="String"/>
	<c path="String"/>
	<c path="Array"><unknown/></c>
	<c path="String"/>
</f></nme_file_dialog_save>
		<nme_file_dialog_open line="326" static="1"><f a="::">
	<c path="String"/>
	<c path="String"/>
	<c path="Array"><unknown/></c>
	<c path="String"/>
</f></nme_file_dialog_open>
		<nme_file_dialog_folder line="327" static="1"><f a=":">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></nme_file_dialog_folder>
		<nme_stage_set_window_position line="330" static="1"><f a="::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_stage_set_window_position>
		<nme_stage_show_cursor line="332" static="1"><f a=":">
	<d/>
	<x path="Bool"/>
	<unknown/>
</f></nme_stage_show_cursor>
		<nme_stage_constrain_cursor_to_window_frame line="333" static="1"><f a=":">
	<d/>
	<x path="Bool"/>
	<unknown/>
</f></nme_stage_constrain_cursor_to_window_frame>
		<nme_stage_set_cursor_position_in_window line="334" static="1"><f a="::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_stage_set_cursor_position_in_window>
		<nme_stage_get_multitouch_supported line="337" static="1"><f a="">
	<d/>
	<unknown/>
</f></nme_stage_get_multitouch_supported>
		<nme_stage_set_multitouch_active line="338" static="1"><f a=":">
	<d/>
	<x path="Bool"/>
	<unknown/>
</f></nme_stage_set_multitouch_active>
		<fileDialogFolder public="1" set="method" line="302"><f a="_title:_text">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></fileDialogFolder>
		<fileDialogSave public="1" set="method" line="295"><f a="_title:_text">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></fileDialogSave>
		<fileDialogOpen public="1" set="method" line="288"><f a="_title:_text">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></fileDialogOpen>
		<openURL public="1" set="method" line="271"><f a="_url">
	<c path="String"/>
	<x path="Void"/>
</f></openURL>
		<on_force_close public="1" set="method" line="265"><f a=""><x path="Void"/></f></on_force_close>
		<on_resume public="1" set="method" line="258"><f a=""><x path="Void"/></f></on_resume>
		<on_pause public="1" set="method" line="251"><f a=""><x path="Void"/></f></on_pause>
		<on_focus public="1" set="method" line="247"><f a="_event">
	<d/>
	<x path="Void"/>
</f></on_focus>
		<on_should_rotate public="1" set="method" line="242"><f a="_event">
	<d/>
	<x path="Void"/>
</f></on_should_rotate>
		<on_resize public="1" set="method" line="230"><f a="_event">
	<d/>
	<x path="Void"/>
</f></on_resize>
		<on_redraw public="1" set="method" line="226"><f a="_event">
	<d/>
	<x path="Void"/>
</f></on_redraw>
		<set_cursor_position_in_window public="1" set="method" line="216"><f a="?_x:?_y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set_cursor_position_in_window>
		<set_window_position public="1" set="method" line="173"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set_window_position>
		<constrain_cursor_to_window_frame public="1" set="method" line="158"><f a="?val">
	<x path="Bool"/>
	<x path="Void"/>
</f></constrain_cursor_to_window_frame>
		<set_cursor_visible public="1" set="method" line="147"><f a="?val">
	<x path="Bool"/>
	<x path="Void"/>
</f></set_cursor_visible>
		<set_active public="1" set="method" line="130"><f a="_active">
	<x path="Bool"/>
	<x path="Void"/>
</f></set_active>
		<invalidate public="1" set="method" line="126"><f a=""><x path="Void"/></f></invalidate>
		<post_ready public="1" set="method" line="109"><f a=""><x path="Void"/></f></post_ready>
		<ready public="1" set="method" line="82"><f a=""><x path="Void"/></f></ready>
		<shutdown public="1" set="method" line="73"><f a=""><x path="Void"/></f></shutdown>
		<startup public="1" set="method" line="22"><f a=""><x path="Void"/></f></startup>
		<cursor_visible public="1"><x path="Bool"/></cursor_visible>
		<cursor_locked public="1"><x path="Bool"/></cursor_locked>
		<invalidated public="1"><x path="Bool"/></invalidated>
		<active public="1"><x path="Bool"/></active>
		<lib public="1"><c path="lime.LiME"/></lib>
		<new public="1" set="method" line="11"><f a="_lib">
	<c path="lime.LiME"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.geometry.Matrix3D" params="" file="/Users/Sven/dev/lab/lime/lime/geometry/Matrix3D.hx">
		<create2D public="1" set="method" line="88" static="1"><f a="x:y:?scale:?rotation">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="lime.geometry.Matrix3D"/>
</f></create2D>
		<createABCD public="1" set="method" line="102" static="1"><f a="a:b:c:d:tx:ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="lime.geometry.Matrix3D"/>
</f></createABCD>
		<createOrtho public="1" set="method" line="112" static="1"><f a="x0:x1:y0:y1:zNear:zFar">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="lime.geometry.Matrix3D"/>
</f></createOrtho>
		<getAxisRotation public="1" get="inline" set="null" line="191" static="1"><f a="x:y:z:degrees">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="lime.geometry.Matrix3D"/>
</f></getAxisRotation>
		<interpolate public="1" get="inline" set="null" line="241" static="1"><f a="thisMat:toMat:percent">
	<c path="lime.geometry.Matrix3D"/>
	<c path="lime.geometry.Matrix3D"/>
	<x path="Float"/>
	<c path="lime.geometry.Matrix3D"/>
</f></interpolate>
		<set_position public="1" get="inline" set="null" line="483">
			<f a="val">
				<c path="lime.geometry.Vector3D"/>
				<c path="lime.geometry.Vector3D"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</set_position>
		<get_position public="1" get="inline" set="null" line="479">
			<f a=""><c path="lime.geometry.Vector3D"/></f>
			<haxe_doc>@private</haxe_doc>
		</get_position>
		<get_determinant public="1" get="inline" set="null" line="470">
			<f a=""><x path="Float"/></f>
			<haxe_doc>@private</haxe_doc>
		</get_determinant>
		<transpose public="1" get="inline" set="null" line="452"><f a=""><x path="Void"/></f></transpose>
		<transformVectors public="1" set="method" line="439"><f a="vin:vout">
	<x path="lime.utils.Vector"><x path="Float"/></x>
	<x path="lime.utils.Vector"><x path="Float"/></x>
	<x path="Void"/>
</f></transformVectors>
		<transformVector public="1" get="inline" set="null" line="429"><f a="v">
	<c path="lime.geometry.Vector3D"/>
	<c path="lime.geometry.Vector3D"/>
</f></transformVector>
		<recompose public="1" set="method" line="408"><f a="components">
	<x path="lime.utils.Vector"><c path="lime.geometry.Vector3D"/></x>
	<x path="Bool"/>
</f></recompose>
		<prependTranslation public="1" get="inline" set="null" line="401"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependTranslation>
		<prependScale public="1" get="inline" set="null" line="396"><f a="xScale:yScale:zScale">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependScale>
		<prependRotation public="1" get="inline" set="null" line="383"><f a="degrees:axis:?pivotPoint">
	<x path="Float"/>
	<c path="lime.geometry.Vector3D"/>
	<c path="lime.geometry.Vector3D"/>
	<x path="Void"/>
</f></prependRotation>
		<prepend public="1" get="inline" set="null" line="351"><f a="rhs">
	<c path="lime.geometry.Matrix3D"/>
	<x path="Void"/>
</f></prepend>
		<invert public="1" get="inline" set="null" line="261"><f a=""><x path="Bool"/></f></invert>
		<interpolateTo public="1" get="inline" set="null" line="253"><f a="toMat:percent">
	<c path="lime.geometry.Matrix3D"/>
	<x path="Float"/>
	<x path="Void"/>
</f></interpolateTo>
		<identity public="1" get="inline" set="null" line="221"><f a=""><x path="Void"/></f></identity>
		<deltaTransformVector public="1" get="inline" set="null" line="181"><f a="v">
	<c path="lime.geometry.Vector3D"/>
	<c path="lime.geometry.Vector3D"/>
</f></deltaTransformVector>
		<decompose public="1" set="method" line="126"><f a=""><x path="lime.utils.Vector"><c path="lime.geometry.Vector3D"/></x></f></decompose>
		<clone public="1" get="inline" set="null" line="83"><f a=""><c path="lime.geometry.Matrix3D"/></f></clone>
		<appendTranslation public="1" get="inline" set="null" line="76"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></appendTranslation>
		<appendScale public="1" get="inline" set="null" line="71"><f a="xScale:yScale:zScale">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></appendScale>
		<appendRotation public="1" set="method" line="58"><f a="degrees:axis:?pivotPoint">
	<x path="Float"/>
	<c path="lime.geometry.Vector3D"/>
	<c path="lime.geometry.Vector3D"/>
	<x path="Void"/>
</f></appendRotation>
		<append public="1" set="method" line="26"><f a="lhs">
	<c path="lime.geometry.Matrix3D"/>
	<x path="Void"/>
</f></append>
		<rawData public="1"><x path="lime.utils.Vector"><x path="Float"/></x></rawData>
		<position public="1" get="accessor" set="accessor"><c path="lime.geometry.Vector3D"/></position>
		<determinant public="1" get="accessor" set="null"><x path="Float"/></determinant>
		<new public="1" set="method" line="14"><f a="?v">
	<x path="lime.utils.Vector"><x path="Float"/></x>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.geometry.Vector3D" params="" file="/Users/Sven/dev/lab/lime/lime/geometry/Vector3D.hx">
		<X_AXIS public="1" get="accessor" set="null" static="1"><c path="lime.geometry.Vector3D"/></X_AXIS>
		<Y_AXIS public="1" get="accessor" set="null" static="1"><c path="lime.geometry.Vector3D"/></Y_AXIS>
		<Z_AXIS public="1" get="accessor" set="null" static="1"><c path="lime.geometry.Vector3D"/></Z_AXIS>
		<angleBetween public="1" get="inline" set="null" line="31" static="1"><f a="a:b">
	<c path="lime.geometry.Vector3D"/>
	<c path="lime.geometry.Vector3D"/>
	<x path="Float"/>
</f></angleBetween>
		<distance public="1" get="inline" set="null" line="63" static="1"><f a="pt1:pt2">
	<c path="lime.geometry.Vector3D"/>
	<c path="lime.geometry.Vector3D"/>
	<x path="Float"/>
</f></distance>
		<get_X_AXIS get="inline" set="null" line="148" static="1"><f a=""><c path="lime.geometry.Vector3D"/></f></get_X_AXIS>
		<get_Y_AXIS get="inline" set="null" line="149" static="1"><f a=""><c path="lime.geometry.Vector3D"/></f></get_Y_AXIS>
		<get_Z_AXIS get="inline" set="null" line="150" static="1"><f a=""><c path="lime.geometry.Vector3D"/></f></get_Z_AXIS>
		<get_lengthSquared get="inline" set="null" line="147"><f a=""><x path="Float"/></f></get_lengthSquared>
		<get_length get="inline" set="null" line="146"><f a=""><x path="Float"/></f></get_length>
		<toString public="1" get="inline" set="null" line="140"><f a=""><c path="String"/></f></toString>
		<subtract public="1" get="inline" set="null" line="135"><f a="a">
	<c path="lime.geometry.Vector3D"/>
	<c path="lime.geometry.Vector3D"/>
</f></subtract>
		<scaleBy public="1" get="inline" set="null" line="128"><f a="s">
	<x path="Float"/>
	<x path="Void"/>
</f></scaleBy>
		<setTo public="1" get="inline" set="null" line="122"><f a="xa:ya:za">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setTo>
		<project public="1" get="inline" set="null" line="115"><f a=""><x path="Void"/></f></project>
		<normalize public="1" get="inline" set="null" line="101"><f a=""><x path="Float"/></f></normalize>
		<negate public="1" get="inline" set="null" line="94"><f a=""><x path="Void"/></f></negate>
		<nearEquals public="1" get="inline" set="null" line="89"><f a="toCompare:tolerance:?allFour">
	<c path="lime.geometry.Vector3D"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></nearEquals>
		<incrementBy public="1" get="inline" set="null" line="82"><f a="a">
	<c path="lime.geometry.Vector3D"/>
	<x path="Void"/>
</f></incrementBy>
		<equals public="1" get="inline" set="null" line="77"><f a="toCompare:?allFour">
	<c path="lime.geometry.Vector3D"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></equals>
		<dotProduct public="1" get="inline" set="null" line="72"><f a="a">
	<c path="lime.geometry.Vector3D"/>
	<x path="Float"/>
</f></dotProduct>
		<decrementBy public="1" get="inline" set="null" line="56"><f a="a">
	<c path="lime.geometry.Vector3D"/>
	<x path="Void"/>
</f></decrementBy>
		<crossProduct public="1" get="inline" set="null" line="51"><f a="a">
	<c path="lime.geometry.Vector3D"/>
	<c path="lime.geometry.Vector3D"/>
</f></crossProduct>
		<copyFrom public="1" get="inline" set="null" line="45"><f a="sourceVector3D">
	<c path="lime.geometry.Vector3D"/>
	<x path="Void"/>
</f></copyFrom>
		<clone public="1" get="inline" set="null" line="40"><f a=""><c path="lime.geometry.Vector3D"/></f></clone>
		<add public="1" get="inline" set="null" line="26"><f a="a">
	<c path="lime.geometry.Vector3D"/>
	<c path="lime.geometry.Vector3D"/>
</f></add>
		<z public="1"><x path="Float"/></z>
		<y public="1"><x path="Float"/></y>
		<x public="1"><x path="Float"/></x>
		<w public="1"><x path="Float"/></w>
		<lengthSquared public="1" get="accessor" set="null"><x path="Float"/></lengthSquared>
		<length public="1" get="accessor" set="null"><x path="Float"/></length>
		<new public="1" set="method" line="18"><f a="?x:?y:?z:?w">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="lime.gl.GL" params="" file="/Users/Sven/dev/lab/lime/lime/gl/GL.hx"><c path="lime.gl.native.GL"/></typedef>
	<typedef path="lime.gl.Ext" params="" file="/Users/Sven/dev/lab/lime/lime/gl/GL.hx" module="lime.gl.GL"><c path="lime.gl.native.Ext"/></typedef>
	<typedef path="lime.gl.GLActiveInfo" params="" file="/Users/Sven/dev/lab/lime/lime/gl/GLActiveInfo.hx"><a>
	<type><x path="Int"/></type>
	<size><x path="Int"/></size>
	<name><c path="String"/></name>
</a></typedef>
	<class path="lime.gl.GLObject" params="" file="/Users/Sven/dev/lab/lime/lime/gl/GLObject.hx">
		<get_valid set="method" line="51"><f a=""><x path="Bool"/></f></get_valid>
		<get_invalidated set="method" line="47"><f a=""><x path="Bool"/></f></get_invalidated>
		<toString public="1" set="method" line="41"><f a=""><c path="String"/></f></toString>
		<isInvalid public="1" set="method" line="37"><f a=""><x path="Bool"/></f></isInvalid>
		<isValid public="1" set="method" line="33"><f a=""><x path="Bool"/></f></isValid>
		<invalidate public="1" set="method" line="29"><f a=""><x path="Void"/></f></invalidate>
		<getType set="method" line="25"><f a=""><c path="String"/></f></getType>
		<version><x path="Int"/></version>
		<valid public="1" get="accessor" set="null"><x path="Bool"/></valid>
		<invalidated public="1" get="accessor" set="null"><x path="Bool"/></invalidated>
		<id public="1" set="null"><d/></id>
		<new set="method" line="18"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.gl.GLBuffer" params="" file="/Users/Sven/dev/lab/lime/lime/gl/GLBuffer.hx">
		<extends path="lime.gl.GLObject"/>
		<getType set="method" line="13" override="1"><f a=""><c path="String"/></f></getType>
		<new public="1" set="method" line="10"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="lime.gl.GLContextAttributes" params="" file="/Users/Sven/dev/lab/lime/lime/gl/GLContextAttributes.hx"><a>
	<stencil><x path="Bool"/></stencil>
	<preserveDrawingBuffer><x path="Bool"/></preserveDrawingBuffer>
	<premultipliedAlpha><x path="Bool"/></premultipliedAlpha>
	<depth><x path="Bool"/></depth>
	<antialias><x path="Bool"/></antialias>
	<alpha><x path="Bool"/></alpha>
</a></typedef>
	<class path="lime.gl.GLFramebuffer" params="" file="/Users/Sven/dev/lab/lime/lime/gl/GLFramebuffer.hx">
		<extends path="lime.gl.GLObject"/>
		<getType set="method" line="16" override="1"><f a=""><c path="String"/></f></getType>
		<new public="1" set="method" line="12"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.gl.GLProgram" params="" file="/Users/Sven/dev/lab/lime/lime/gl/GLProgram.hx">
		<extends path="lime.gl.GLObject"/>
		<getType set="method" line="28" override="1"><f a=""><c path="String"/></f></getType>
		<getShaders public="1" set="method" line="24"><f a=""><c path="Array"><c path="lime.gl.GLShader"/></c></f></getShaders>
		<attach public="1" set="method" line="20"><f a="shader">
	<c path="lime.gl.GLShader"/>
	<x path="Void"/>
</f></attach>
		<shaders public="1"><c path="Array"><c path="lime.gl.GLShader"/></c></shaders>
		<new public="1" set="method" line="15"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.gl.GLRenderbuffer" params="" file="/Users/Sven/dev/lab/lime/lime/gl/GLRenderbuffer.hx">
		<extends path="lime.gl.GLObject"/>
		<getType set="method" line="15" override="1"><f a=""><c path="String"/></f></getType>
		<new public="1" set="method" line="11"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.gl.GLShader" params="" file="/Users/Sven/dev/lab/lime/lime/gl/GLShader.hx">
		<extends path="lime.gl.GLObject"/>
		<getType set="method" line="16" override="1"><f a=""><c path="String"/></f></getType>
		<new public="1" set="method" line="12"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.gl.GLTexture" params="" file="/Users/Sven/dev/lab/lime/lime/gl/GLTexture.hx">
		<extends path="lime.gl.GLObject"/>
		<getType set="method" line="16" override="1"><f a=""><c path="String"/></f></getType>
		<new public="1" set="method" line="12"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="lime.gl.GLUniformLocation" params="" file="/Users/Sven/dev/lab/lime/lime/gl/GLUniformLocation.hx"><d/></typedef>
	<class path="lime.gl.native.Ext" params="" file="/Users/Sven/dev/lab/lime/lime/gl/native/Ext.hx">
		<drawBuffers public="1" set="method" line="7" static="1"><f a="n:buffers">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawBuffers>
		<load set="method" line="13" static="1"><f a="inName:inArgCount">
	<c path="String"/>
	<x path="Int"/>
	<d/>
</f></load>
		<COLOR_ATTACHMENT0 public="1" get="inline" set="null" line="21" static="1"><x path="Int"/></COLOR_ATTACHMENT0>
		<COLOR_ATTACHMENT1 public="1" get="inline" set="null" line="22" static="1"><x path="Int"/></COLOR_ATTACHMENT1>
		<COLOR_ATTACHMENT2 public="1" get="inline" set="null" line="23" static="1"><x path="Int"/></COLOR_ATTACHMENT2>
		<COLOR_ATTACHMENT3 public="1" get="inline" set="null" line="24" static="1"><x path="Int"/></COLOR_ATTACHMENT3>
		<COLOR_ATTACHMENT4 public="1" get="inline" set="null" line="25" static="1"><x path="Int"/></COLOR_ATTACHMENT4>
		<COLOR_ATTACHMENT5 public="1" get="inline" set="null" line="26" static="1"><x path="Int"/></COLOR_ATTACHMENT5>
		<COLOR_ATTACHMENT6 public="1" get="inline" set="null" line="27" static="1"><x path="Int"/></COLOR_ATTACHMENT6>
		<COLOR_ATTACHMENT7 public="1" get="inline" set="null" line="28" static="1"><x path="Int"/></COLOR_ATTACHMENT7>
		<COLOR_ATTACHMENT8 public="1" get="inline" set="null" line="29" static="1"><x path="Int"/></COLOR_ATTACHMENT8>
		<COLOR_ATTACHMENT9 public="1" get="inline" set="null" line="30" static="1"><x path="Int"/></COLOR_ATTACHMENT9>
		<COLOR_ATTACHMENT10 public="1" get="inline" set="null" line="31" static="1"><x path="Int"/></COLOR_ATTACHMENT10>
		<COLOR_ATTACHMENT11 public="1" get="inline" set="null" line="32" static="1"><x path="Int"/></COLOR_ATTACHMENT11>
		<COLOR_ATTACHMENT12 public="1" get="inline" set="null" line="33" static="1"><x path="Int"/></COLOR_ATTACHMENT12>
		<COLOR_ATTACHMENT13 public="1" get="inline" set="null" line="34" static="1"><x path="Int"/></COLOR_ATTACHMENT13>
		<COLOR_ATTACHMENT14 public="1" get="inline" set="null" line="35" static="1"><x path="Int"/></COLOR_ATTACHMENT14>
		<COLOR_ATTACHMENT15 public="1" get="inline" set="null" line="36" static="1"><x path="Int"/></COLOR_ATTACHMENT15>
		<DRAW_BUFFER0 public="1" get="inline" set="null" line="38" static="1"><x path="Int"/></DRAW_BUFFER0>
		<DRAW_BUFFER1 public="1" get="inline" set="null" line="39" static="1"><x path="Int"/></DRAW_BUFFER1>
		<DRAW_BUFFER2 public="1" get="inline" set="null" line="40" static="1"><x path="Int"/></DRAW_BUFFER2>
		<DRAW_BUFFER3 public="1" get="inline" set="null" line="41" static="1"><x path="Int"/></DRAW_BUFFER3>
		<DRAW_BUFFER4 public="1" get="inline" set="null" line="42" static="1"><x path="Int"/></DRAW_BUFFER4>
		<DRAW_BUFFER5 public="1" get="inline" set="null" line="43" static="1"><x path="Int"/></DRAW_BUFFER5>
		<DRAW_BUFFER6 public="1" get="inline" set="null" line="44" static="1"><x path="Int"/></DRAW_BUFFER6>
		<DRAW_BUFFER7 public="1" get="inline" set="null" line="45" static="1"><x path="Int"/></DRAW_BUFFER7>
		<DRAW_BUFFER8 public="1" get="inline" set="null" line="46" static="1"><x path="Int"/></DRAW_BUFFER8>
		<DRAW_BUFFER9 public="1" get="inline" set="null" line="47" static="1"><x path="Int"/></DRAW_BUFFER9>
		<DRAW_BUFFER10 public="1" get="inline" set="null" line="48" static="1"><x path="Int"/></DRAW_BUFFER10>
		<DRAW_BUFFER11 public="1" get="inline" set="null" line="49" static="1"><x path="Int"/></DRAW_BUFFER11>
		<DRAW_BUFFER12 public="1" get="inline" set="null" line="50" static="1"><x path="Int"/></DRAW_BUFFER12>
		<DRAW_BUFFER13 public="1" get="inline" set="null" line="51" static="1"><x path="Int"/></DRAW_BUFFER13>
		<DRAW_BUFFER14 public="1" get="inline" set="null" line="52" static="1"><x path="Int"/></DRAW_BUFFER14>
		<DRAW_BUFFER15 public="1" get="inline" set="null" line="53" static="1"><x path="Int"/></DRAW_BUFFER15>
		<MAX_COLOR_ATTACHMENTS public="1" get="inline" set="null" line="55" static="1"><x path="Int"/></MAX_COLOR_ATTACHMENTS>
		<MAX_DRAW_BUFFERS public="1" get="inline" set="null" line="56" static="1"><x path="Int"/></MAX_DRAW_BUFFERS>
	</class>
	<class path="lime.gl.native.GL" params="" file="/Users/Sven/dev/lab/lime/lime/gl/native/GL.hx">
		<DEPTH_BUFFER_BIT public="1" get="inline" set="null" line="17" static="1"><x path="Int"/></DEPTH_BUFFER_BIT>
		<STENCIL_BUFFER_BIT public="1" get="inline" set="null" line="18" static="1"><x path="Int"/></STENCIL_BUFFER_BIT>
		<COLOR_BUFFER_BIT public="1" get="inline" set="null" line="19" static="1"><x path="Int"/></COLOR_BUFFER_BIT>
		<POINTS public="1" get="inline" set="null" line="22" static="1"><x path="Int"/></POINTS>
		<LINES public="1" get="inline" set="null" line="23" static="1"><x path="Int"/></LINES>
		<LINE_LOOP public="1" get="inline" set="null" line="24" static="1"><x path="Int"/></LINE_LOOP>
		<LINE_STRIP public="1" get="inline" set="null" line="25" static="1"><x path="Int"/></LINE_STRIP>
		<TRIANGLES public="1" get="inline" set="null" line="26" static="1"><x path="Int"/></TRIANGLES>
		<TRIANGLE_STRIP public="1" get="inline" set="null" line="27" static="1"><x path="Int"/></TRIANGLE_STRIP>
		<TRIANGLE_FAN public="1" get="inline" set="null" line="28" static="1"><x path="Int"/></TRIANGLE_FAN>
		<ZERO public="1" get="inline" set="null" line="40" static="1"><x path="Int"/></ZERO>
		<ONE public="1" get="inline" set="null" line="41" static="1"><x path="Int"/></ONE>
		<SRC_COLOR public="1" get="inline" set="null" line="42" static="1"><x path="Int"/></SRC_COLOR>
		<ONE_MINUS_SRC_COLOR public="1" get="inline" set="null" line="43" static="1"><x path="Int"/></ONE_MINUS_SRC_COLOR>
		<SRC_ALPHA public="1" get="inline" set="null" line="44" static="1"><x path="Int"/></SRC_ALPHA>
		<ONE_MINUS_SRC_ALPHA public="1" get="inline" set="null" line="45" static="1"><x path="Int"/></ONE_MINUS_SRC_ALPHA>
		<DST_ALPHA public="1" get="inline" set="null" line="46" static="1"><x path="Int"/></DST_ALPHA>
		<ONE_MINUS_DST_ALPHA public="1" get="inline" set="null" line="47" static="1"><x path="Int"/></ONE_MINUS_DST_ALPHA>
		<DST_COLOR public="1" get="inline" set="null" line="52" static="1"><x path="Int"/></DST_COLOR>
		<ONE_MINUS_DST_COLOR public="1" get="inline" set="null" line="53" static="1"><x path="Int"/></ONE_MINUS_DST_COLOR>
		<SRC_ALPHA_SATURATE public="1" get="inline" set="null" line="54" static="1"><x path="Int"/></SRC_ALPHA_SATURATE>
		<FUNC_ADD public="1" get="inline" set="null" line="60" static="1"><x path="Int"/></FUNC_ADD>
		<BLEND_EQUATION public="1" get="inline" set="null" line="61" static="1"><x path="Int"/></BLEND_EQUATION>
		<BLEND_EQUATION_RGB public="1" get="inline" set="null" line="62" static="1"><x path="Int"/></BLEND_EQUATION_RGB>
		<BLEND_EQUATION_ALPHA public="1" get="inline" set="null" line="63" static="1"><x path="Int"/></BLEND_EQUATION_ALPHA>
		<FUNC_SUBTRACT public="1" get="inline" set="null" line="66" static="1"><x path="Int"/></FUNC_SUBTRACT>
		<FUNC_REVERSE_SUBTRACT public="1" get="inline" set="null" line="67" static="1"><x path="Int"/></FUNC_REVERSE_SUBTRACT>
		<BLEND_DST_RGB public="1" get="inline" set="null" line="70" static="1"><x path="Int"/></BLEND_DST_RGB>
		<BLEND_SRC_RGB public="1" get="inline" set="null" line="71" static="1"><x path="Int"/></BLEND_SRC_RGB>
		<BLEND_DST_ALPHA public="1" get="inline" set="null" line="72" static="1"><x path="Int"/></BLEND_DST_ALPHA>
		<BLEND_SRC_ALPHA public="1" get="inline" set="null" line="73" static="1"><x path="Int"/></BLEND_SRC_ALPHA>
		<CONSTANT_COLOR public="1" get="inline" set="null" line="74" static="1"><x path="Int"/></CONSTANT_COLOR>
		<ONE_MINUS_CONSTANT_COLOR public="1" get="inline" set="null" line="75" static="1"><x path="Int"/></ONE_MINUS_CONSTANT_COLOR>
		<CONSTANT_ALPHA public="1" get="inline" set="null" line="76" static="1"><x path="Int"/></CONSTANT_ALPHA>
		<ONE_MINUS_CONSTANT_ALPHA public="1" get="inline" set="null" line="77" static="1"><x path="Int"/></ONE_MINUS_CONSTANT_ALPHA>
		<BLEND_COLOR public="1" get="inline" set="null" line="78" static="1"><x path="Int"/></BLEND_COLOR>
		<ARRAY_BUFFER public="1" get="inline" set="null" line="81" static="1"><x path="Int"/></ARRAY_BUFFER>
		<ELEMENT_ARRAY_BUFFER public="1" get="inline" set="null" line="82" static="1"><x path="Int"/></ELEMENT_ARRAY_BUFFER>
		<ARRAY_BUFFER_BINDING public="1" get="inline" set="null" line="83" static="1"><x path="Int"/></ARRAY_BUFFER_BINDING>
		<ELEMENT_ARRAY_BUFFER_BINDING public="1" get="inline" set="null" line="84" static="1"><x path="Int"/></ELEMENT_ARRAY_BUFFER_BINDING>
		<STREAM_DRAW public="1" get="inline" set="null" line="86" static="1"><x path="Int"/></STREAM_DRAW>
		<STATIC_DRAW public="1" get="inline" set="null" line="87" static="1"><x path="Int"/></STATIC_DRAW>
		<DYNAMIC_DRAW public="1" get="inline" set="null" line="88" static="1"><x path="Int"/></DYNAMIC_DRAW>
		<BUFFER_SIZE public="1" get="inline" set="null" line="90" static="1"><x path="Int"/></BUFFER_SIZE>
		<BUFFER_USAGE public="1" get="inline" set="null" line="91" static="1"><x path="Int"/></BUFFER_USAGE>
		<CURRENT_VERTEX_ATTRIB public="1" get="inline" set="null" line="93" static="1"><x path="Int"/></CURRENT_VERTEX_ATTRIB>
		<FRONT public="1" get="inline" set="null" line="96" static="1"><x path="Int"/></FRONT>
		<BACK public="1" get="inline" set="null" line="97" static="1"><x path="Int"/></BACK>
		<FRONT_AND_BACK public="1" get="inline" set="null" line="98" static="1"><x path="Int"/></FRONT_AND_BACK>
		<CULL_FACE public="1" get="inline" set="null" line="111" static="1"><x path="Int"/></CULL_FACE>
		<BLEND public="1" get="inline" set="null" line="112" static="1"><x path="Int"/></BLEND>
		<DITHER public="1" get="inline" set="null" line="113" static="1"><x path="Int"/></DITHER>
		<STENCIL_TEST public="1" get="inline" set="null" line="114" static="1"><x path="Int"/></STENCIL_TEST>
		<DEPTH_TEST public="1" get="inline" set="null" line="115" static="1"><x path="Int"/></DEPTH_TEST>
		<SCISSOR_TEST public="1" get="inline" set="null" line="116" static="1"><x path="Int"/></SCISSOR_TEST>
		<POLYGON_OFFSET_FILL public="1" get="inline" set="null" line="117" static="1"><x path="Int"/></POLYGON_OFFSET_FILL>
		<SAMPLE_ALPHA_TO_COVERAGE public="1" get="inline" set="null" line="118" static="1"><x path="Int"/></SAMPLE_ALPHA_TO_COVERAGE>
		<SAMPLE_COVERAGE public="1" get="inline" set="null" line="119" static="1"><x path="Int"/></SAMPLE_COVERAGE>
		<NO_ERROR public="1" get="inline" set="null" line="122" static="1"><x path="Int"/></NO_ERROR>
		<INVALID_ENUM public="1" get="inline" set="null" line="123" static="1"><x path="Int"/></INVALID_ENUM>
		<INVALID_VALUE public="1" get="inline" set="null" line="124" static="1"><x path="Int"/></INVALID_VALUE>
		<INVALID_OPERATION public="1" get="inline" set="null" line="125" static="1"><x path="Int"/></INVALID_OPERATION>
		<OUT_OF_MEMORY public="1" get="inline" set="null" line="126" static="1"><x path="Int"/></OUT_OF_MEMORY>
		<CW public="1" get="inline" set="null" line="129" static="1"><x path="Int"/></CW>
		<CCW public="1" get="inline" set="null" line="130" static="1"><x path="Int"/></CCW>
		<LINE_WIDTH public="1" get="inline" set="null" line="133" static="1"><x path="Int"/></LINE_WIDTH>
		<ALIASED_POINT_SIZE_RANGE public="1" get="inline" set="null" line="134" static="1"><x path="Int"/></ALIASED_POINT_SIZE_RANGE>
		<ALIASED_LINE_WIDTH_RANGE public="1" get="inline" set="null" line="135" static="1"><x path="Int"/></ALIASED_LINE_WIDTH_RANGE>
		<CULL_FACE_MODE public="1" get="inline" set="null" line="136" static="1"><x path="Int"/></CULL_FACE_MODE>
		<FRONT_FACE public="1" get="inline" set="null" line="137" static="1"><x path="Int"/></FRONT_FACE>
		<DEPTH_RANGE public="1" get="inline" set="null" line="138" static="1"><x path="Int"/></DEPTH_RANGE>
		<DEPTH_WRITEMASK public="1" get="inline" set="null" line="139" static="1"><x path="Int"/></DEPTH_WRITEMASK>
		<DEPTH_CLEAR_VALUE public="1" get="inline" set="null" line="140" static="1"><x path="Int"/></DEPTH_CLEAR_VALUE>
		<DEPTH_FUNC public="1" get="inline" set="null" line="141" static="1"><x path="Int"/></DEPTH_FUNC>
		<STENCIL_CLEAR_VALUE public="1" get="inline" set="null" line="142" static="1"><x path="Int"/></STENCIL_CLEAR_VALUE>
		<STENCIL_FUNC public="1" get="inline" set="null" line="143" static="1"><x path="Int"/></STENCIL_FUNC>
		<STENCIL_FAIL public="1" get="inline" set="null" line="144" static="1"><x path="Int"/></STENCIL_FAIL>
		<STENCIL_PASS_DEPTH_FAIL public="1" get="inline" set="null" line="145" static="1"><x path="Int"/></STENCIL_PASS_DEPTH_FAIL>
		<STENCIL_PASS_DEPTH_PASS public="1" get="inline" set="null" line="146" static="1"><x path="Int"/></STENCIL_PASS_DEPTH_PASS>
		<STENCIL_REF public="1" get="inline" set="null" line="147" static="1"><x path="Int"/></STENCIL_REF>
		<STENCIL_VALUE_MASK public="1" get="inline" set="null" line="148" static="1"><x path="Int"/></STENCIL_VALUE_MASK>
		<STENCIL_WRITEMASK public="1" get="inline" set="null" line="149" static="1"><x path="Int"/></STENCIL_WRITEMASK>
		<STENCIL_BACK_FUNC public="1" get="inline" set="null" line="150" static="1"><x path="Int"/></STENCIL_BACK_FUNC>
		<STENCIL_BACK_FAIL public="1" get="inline" set="null" line="151" static="1"><x path="Int"/></STENCIL_BACK_FAIL>
		<STENCIL_BACK_PASS_DEPTH_FAIL public="1" get="inline" set="null" line="152" static="1"><x path="Int"/></STENCIL_BACK_PASS_DEPTH_FAIL>
		<STENCIL_BACK_PASS_DEPTH_PASS public="1" get="inline" set="null" line="153" static="1"><x path="Int"/></STENCIL_BACK_PASS_DEPTH_PASS>
		<STENCIL_BACK_REF public="1" get="inline" set="null" line="154" static="1"><x path="Int"/></STENCIL_BACK_REF>
		<STENCIL_BACK_VALUE_MASK public="1" get="inline" set="null" line="155" static="1"><x path="Int"/></STENCIL_BACK_VALUE_MASK>
		<STENCIL_BACK_WRITEMASK public="1" get="inline" set="null" line="156" static="1"><x path="Int"/></STENCIL_BACK_WRITEMASK>
		<VIEWPORT public="1" get="inline" set="null" line="157" static="1"><x path="Int"/></VIEWPORT>
		<SCISSOR_BOX public="1" get="inline" set="null" line="158" static="1"><x path="Int"/></SCISSOR_BOX>
		<COLOR_CLEAR_VALUE public="1" get="inline" set="null" line="160" static="1"><x path="Int"/></COLOR_CLEAR_VALUE>
		<COLOR_WRITEMASK public="1" get="inline" set="null" line="161" static="1"><x path="Int"/></COLOR_WRITEMASK>
		<UNPACK_ALIGNMENT public="1" get="inline" set="null" line="162" static="1"><x path="Int"/></UNPACK_ALIGNMENT>
		<PACK_ALIGNMENT public="1" get="inline" set="null" line="163" static="1"><x path="Int"/></PACK_ALIGNMENT>
		<MAX_TEXTURE_SIZE public="1" get="inline" set="null" line="164" static="1"><x path="Int"/></MAX_TEXTURE_SIZE>
		<MAX_VIEWPORT_DIMS public="1" get="inline" set="null" line="165" static="1"><x path="Int"/></MAX_VIEWPORT_DIMS>
		<SUBPIXEL_BITS public="1" get="inline" set="null" line="166" static="1"><x path="Int"/></SUBPIXEL_BITS>
		<RED_BITS public="1" get="inline" set="null" line="167" static="1"><x path="Int"/></RED_BITS>
		<GREEN_BITS public="1" get="inline" set="null" line="168" static="1"><x path="Int"/></GREEN_BITS>
		<BLUE_BITS public="1" get="inline" set="null" line="169" static="1"><x path="Int"/></BLUE_BITS>
		<ALPHA_BITS public="1" get="inline" set="null" line="170" static="1"><x path="Int"/></ALPHA_BITS>
		<DEPTH_BITS public="1" get="inline" set="null" line="171" static="1"><x path="Int"/></DEPTH_BITS>
		<STENCIL_BITS public="1" get="inline" set="null" line="172" static="1"><x path="Int"/></STENCIL_BITS>
		<POLYGON_OFFSET_UNITS public="1" get="inline" set="null" line="173" static="1"><x path="Int"/></POLYGON_OFFSET_UNITS>
		<POLYGON_OFFSET_FACTOR public="1" get="inline" set="null" line="175" static="1"><x path="Int"/></POLYGON_OFFSET_FACTOR>
		<TEXTURE_BINDING_2D public="1" get="inline" set="null" line="176" static="1"><x path="Int"/></TEXTURE_BINDING_2D>
		<SAMPLE_BUFFERS public="1" get="inline" set="null" line="177" static="1"><x path="Int"/></SAMPLE_BUFFERS>
		<SAMPLES public="1" get="inline" set="null" line="178" static="1"><x path="Int"/></SAMPLES>
		<SAMPLE_COVERAGE_VALUE public="1" get="inline" set="null" line="179" static="1"><x path="Int"/></SAMPLE_COVERAGE_VALUE>
		<SAMPLE_COVERAGE_INVERT public="1" get="inline" set="null" line="180" static="1"><x path="Int"/></SAMPLE_COVERAGE_INVERT>
		<COMPRESSED_TEXTURE_FORMATS public="1" get="inline" set="null" line="187" static="1"><x path="Int"/></COMPRESSED_TEXTURE_FORMATS>
		<DONT_CARE public="1" get="inline" set="null" line="190" static="1"><x path="Int"/></DONT_CARE>
		<FASTEST public="1" get="inline" set="null" line="191" static="1"><x path="Int"/></FASTEST>
		<NICEST public="1" get="inline" set="null" line="192" static="1"><x path="Int"/></NICEST>
		<GENERATE_MIPMAP_HINT public="1" get="inline" set="null" line="195" static="1"><x path="Int"/></GENERATE_MIPMAP_HINT>
		<BYTE public="1" get="inline" set="null" line="198" static="1"><x path="Int"/></BYTE>
		<UNSIGNED_BYTE public="1" get="inline" set="null" line="199" static="1"><x path="Int"/></UNSIGNED_BYTE>
		<SHORT public="1" get="inline" set="null" line="200" static="1"><x path="Int"/></SHORT>
		<UNSIGNED_SHORT public="1" get="inline" set="null" line="201" static="1"><x path="Int"/></UNSIGNED_SHORT>
		<INT public="1" get="inline" set="null" line="202" static="1"><x path="Int"/></INT>
		<UNSIGNED_INT public="1" get="inline" set="null" line="203" static="1"><x path="Int"/></UNSIGNED_INT>
		<FLOAT public="1" get="inline" set="null" line="204" static="1"><x path="Int"/></FLOAT>
		<DEPTH_COMPONENT public="1" get="inline" set="null" line="207" static="1"><x path="Int"/></DEPTH_COMPONENT>
		<ALPHA public="1" get="inline" set="null" line="208" static="1"><x path="Int"/></ALPHA>
		<RGB public="1" get="inline" set="null" line="209" static="1"><x path="Int"/></RGB>
		<RGBA public="1" get="inline" set="null" line="210" static="1"><x path="Int"/></RGBA>
		<LUMINANCE public="1" get="inline" set="null" line="211" static="1"><x path="Int"/></LUMINANCE>
		<LUMINANCE_ALPHA public="1" get="inline" set="null" line="212" static="1"><x path="Int"/></LUMINANCE_ALPHA>
		<UNSIGNED_SHORT_4_4_4_4 public="1" get="inline" set="null" line="216" static="1"><x path="Int"/></UNSIGNED_SHORT_4_4_4_4>
		<UNSIGNED_SHORT_5_5_5_1 public="1" get="inline" set="null" line="217" static="1"><x path="Int"/></UNSIGNED_SHORT_5_5_5_1>
		<UNSIGNED_SHORT_5_6_5 public="1" get="inline" set="null" line="218" static="1"><x path="Int"/></UNSIGNED_SHORT_5_6_5>
		<FRAGMENT_SHADER public="1" get="inline" set="null" line="221" static="1"><x path="Int"/></FRAGMENT_SHADER>
		<VERTEX_SHADER public="1" get="inline" set="null" line="222" static="1"><x path="Int"/></VERTEX_SHADER>
		<MAX_VERTEX_ATTRIBS public="1" get="inline" set="null" line="223" static="1"><x path="Int"/></MAX_VERTEX_ATTRIBS>
		<MAX_VERTEX_UNIFORM_VECTORS public="1" get="inline" set="null" line="224" static="1"><x path="Int"/></MAX_VERTEX_UNIFORM_VECTORS>
		<MAX_VARYING_VECTORS public="1" get="inline" set="null" line="225" static="1"><x path="Int"/></MAX_VARYING_VECTORS>
		<MAX_COMBINED_TEXTURE_IMAGE_UNITS public="1" get="inline" set="null" line="226" static="1"><x path="Int"/></MAX_COMBINED_TEXTURE_IMAGE_UNITS>
		<MAX_VERTEX_TEXTURE_IMAGE_UNITS public="1" get="inline" set="null" line="227" static="1"><x path="Int"/></MAX_VERTEX_TEXTURE_IMAGE_UNITS>
		<MAX_TEXTURE_IMAGE_UNITS public="1" get="inline" set="null" line="228" static="1"><x path="Int"/></MAX_TEXTURE_IMAGE_UNITS>
		<MAX_FRAGMENT_UNIFORM_VECTORS public="1" get="inline" set="null" line="229" static="1"><x path="Int"/></MAX_FRAGMENT_UNIFORM_VECTORS>
		<SHADER_TYPE public="1" get="inline" set="null" line="230" static="1"><x path="Int"/></SHADER_TYPE>
		<DELETE_STATUS public="1" get="inline" set="null" line="231" static="1"><x path="Int"/></DELETE_STATUS>
		<LINK_STATUS public="1" get="inline" set="null" line="232" static="1"><x path="Int"/></LINK_STATUS>
		<VALIDATE_STATUS public="1" get="inline" set="null" line="233" static="1"><x path="Int"/></VALIDATE_STATUS>
		<ATTACHED_SHADERS public="1" get="inline" set="null" line="234" static="1"><x path="Int"/></ATTACHED_SHADERS>
		<ACTIVE_UNIFORMS public="1" get="inline" set="null" line="235" static="1"><x path="Int"/></ACTIVE_UNIFORMS>
		<ACTIVE_ATTRIBUTES public="1" get="inline" set="null" line="236" static="1"><x path="Int"/></ACTIVE_ATTRIBUTES>
		<SHADING_LANGUAGE_VERSION public="1" get="inline" set="null" line="237" static="1"><x path="Int"/></SHADING_LANGUAGE_VERSION>
		<CURRENT_PROGRAM public="1" get="inline" set="null" line="238" static="1"><x path="Int"/></CURRENT_PROGRAM>
		<NEVER public="1" get="inline" set="null" line="241" static="1"><x path="Int"/></NEVER>
		<LESS public="1" get="inline" set="null" line="242" static="1"><x path="Int"/></LESS>
		<EQUAL public="1" get="inline" set="null" line="243" static="1"><x path="Int"/></EQUAL>
		<LEQUAL public="1" get="inline" set="null" line="244" static="1"><x path="Int"/></LEQUAL>
		<GREATER public="1" get="inline" set="null" line="245" static="1"><x path="Int"/></GREATER>
		<NOTEQUAL public="1" get="inline" set="null" line="246" static="1"><x path="Int"/></NOTEQUAL>
		<GEQUAL public="1" get="inline" set="null" line="247" static="1"><x path="Int"/></GEQUAL>
		<ALWAYS public="1" get="inline" set="null" line="248" static="1"><x path="Int"/></ALWAYS>
		<KEEP public="1" get="inline" set="null" line="252" static="1"><x path="Int"/></KEEP>
		<REPLACE public="1" get="inline" set="null" line="253" static="1"><x path="Int"/></REPLACE>
		<INCR public="1" get="inline" set="null" line="254" static="1"><x path="Int"/></INCR>
		<DECR public="1" get="inline" set="null" line="255" static="1"><x path="Int"/></DECR>
		<INVERT public="1" get="inline" set="null" line="256" static="1"><x path="Int"/></INVERT>
		<INCR_WRAP public="1" get="inline" set="null" line="257" static="1"><x path="Int"/></INCR_WRAP>
		<DECR_WRAP public="1" get="inline" set="null" line="258" static="1"><x path="Int"/></DECR_WRAP>
		<VENDOR public="1" get="inline" set="null" line="261" static="1"><x path="Int"/></VENDOR>
		<RENDERER public="1" get="inline" set="null" line="262" static="1"><x path="Int"/></RENDERER>
		<VERSION public="1" get="inline" set="null" line="263" static="1"><x path="Int"/></VERSION>
		<NEAREST public="1" get="inline" set="null" line="266" static="1"><x path="Int"/></NEAREST>
		<LINEAR public="1" get="inline" set="null" line="267" static="1"><x path="Int"/></LINEAR>
		<NEAREST_MIPMAP_NEAREST public="1" get="inline" set="null" line="272" static="1"><x path="Int"/></NEAREST_MIPMAP_NEAREST>
		<LINEAR_MIPMAP_NEAREST public="1" get="inline" set="null" line="273" static="1"><x path="Int"/></LINEAR_MIPMAP_NEAREST>
		<NEAREST_MIPMAP_LINEAR public="1" get="inline" set="null" line="274" static="1"><x path="Int"/></NEAREST_MIPMAP_LINEAR>
		<LINEAR_MIPMAP_LINEAR public="1" get="inline" set="null" line="275" static="1"><x path="Int"/></LINEAR_MIPMAP_LINEAR>
		<TEXTURE_MAG_FILTER public="1" get="inline" set="null" line="278" static="1"><x path="Int"/></TEXTURE_MAG_FILTER>
		<TEXTURE_MIN_FILTER public="1" get="inline" set="null" line="279" static="1"><x path="Int"/></TEXTURE_MIN_FILTER>
		<TEXTURE_WRAP_S public="1" get="inline" set="null" line="280" static="1"><x path="Int"/></TEXTURE_WRAP_S>
		<TEXTURE_WRAP_T public="1" get="inline" set="null" line="281" static="1"><x path="Int"/></TEXTURE_WRAP_T>
		<TEXTURE_2D public="1" get="inline" set="null" line="284" static="1"><x path="Int"/></TEXTURE_2D>
		<TEXTURE public="1" get="inline" set="null" line="285" static="1"><x path="Int"/></TEXTURE>
		<TEXTURE_CUBE_MAP public="1" get="inline" set="null" line="287" static="1"><x path="Int"/></TEXTURE_CUBE_MAP>
		<TEXTURE_BINDING_CUBE_MAP public="1" get="inline" set="null" line="288" static="1"><x path="Int"/></TEXTURE_BINDING_CUBE_MAP>
		<TEXTURE_CUBE_MAP_POSITIVE_X public="1" get="inline" set="null" line="289" static="1"><x path="Int"/></TEXTURE_CUBE_MAP_POSITIVE_X>
		<TEXTURE_CUBE_MAP_NEGATIVE_X public="1" get="inline" set="null" line="290" static="1"><x path="Int"/></TEXTURE_CUBE_MAP_NEGATIVE_X>
		<TEXTURE_CUBE_MAP_POSITIVE_Y public="1" get="inline" set="null" line="291" static="1"><x path="Int"/></TEXTURE_CUBE_MAP_POSITIVE_Y>
		<TEXTURE_CUBE_MAP_NEGATIVE_Y public="1" get="inline" set="null" line="292" static="1"><x path="Int"/></TEXTURE_CUBE_MAP_NEGATIVE_Y>
		<TEXTURE_CUBE_MAP_POSITIVE_Z public="1" get="inline" set="null" line="293" static="1"><x path="Int"/></TEXTURE_CUBE_MAP_POSITIVE_Z>
		<TEXTURE_CUBE_MAP_NEGATIVE_Z public="1" get="inline" set="null" line="294" static="1"><x path="Int"/></TEXTURE_CUBE_MAP_NEGATIVE_Z>
		<MAX_CUBE_MAP_TEXTURE_SIZE public="1" get="inline" set="null" line="295" static="1"><x path="Int"/></MAX_CUBE_MAP_TEXTURE_SIZE>
		<TEXTURE0 public="1" get="inline" set="null" line="298" static="1"><x path="Int"/></TEXTURE0>
		<TEXTURE1 public="1" get="inline" set="null" line="299" static="1"><x path="Int"/></TEXTURE1>
		<TEXTURE2 public="1" get="inline" set="null" line="300" static="1"><x path="Int"/></TEXTURE2>
		<TEXTURE3 public="1" get="inline" set="null" line="301" static="1"><x path="Int"/></TEXTURE3>
		<TEXTURE4 public="1" get="inline" set="null" line="302" static="1"><x path="Int"/></TEXTURE4>
		<TEXTURE5 public="1" get="inline" set="null" line="303" static="1"><x path="Int"/></TEXTURE5>
		<TEXTURE6 public="1" get="inline" set="null" line="304" static="1"><x path="Int"/></TEXTURE6>
		<TEXTURE7 public="1" get="inline" set="null" line="305" static="1"><x path="Int"/></TEXTURE7>
		<TEXTURE8 public="1" get="inline" set="null" line="306" static="1"><x path="Int"/></TEXTURE8>
		<TEXTURE9 public="1" get="inline" set="null" line="307" static="1"><x path="Int"/></TEXTURE9>
		<TEXTURE10 public="1" get="inline" set="null" line="308" static="1"><x path="Int"/></TEXTURE10>
		<TEXTURE11 public="1" get="inline" set="null" line="309" static="1"><x path="Int"/></TEXTURE11>
		<TEXTURE12 public="1" get="inline" set="null" line="310" static="1"><x path="Int"/></TEXTURE12>
		<TEXTURE13 public="1" get="inline" set="null" line="311" static="1"><x path="Int"/></TEXTURE13>
		<TEXTURE14 public="1" get="inline" set="null" line="312" static="1"><x path="Int"/></TEXTURE14>
		<TEXTURE15 public="1" get="inline" set="null" line="313" static="1"><x path="Int"/></TEXTURE15>
		<TEXTURE16 public="1" get="inline" set="null" line="314" static="1"><x path="Int"/></TEXTURE16>
		<TEXTURE17 public="1" get="inline" set="null" line="315" static="1"><x path="Int"/></TEXTURE17>
		<TEXTURE18 public="1" get="inline" set="null" line="316" static="1"><x path="Int"/></TEXTURE18>
		<TEXTURE19 public="1" get="inline" set="null" line="317" static="1"><x path="Int"/></TEXTURE19>
		<TEXTURE20 public="1" get="inline" set="null" line="318" static="1"><x path="Int"/></TEXTURE20>
		<TEXTURE21 public="1" get="inline" set="null" line="319" static="1"><x path="Int"/></TEXTURE21>
		<TEXTURE22 public="1" get="inline" set="null" line="320" static="1"><x path="Int"/></TEXTURE22>
		<TEXTURE23 public="1" get="inline" set="null" line="321" static="1"><x path="Int"/></TEXTURE23>
		<TEXTURE24 public="1" get="inline" set="null" line="322" static="1"><x path="Int"/></TEXTURE24>
		<TEXTURE25 public="1" get="inline" set="null" line="323" static="1"><x path="Int"/></TEXTURE25>
		<TEXTURE26 public="1" get="inline" set="null" line="324" static="1"><x path="Int"/></TEXTURE26>
		<TEXTURE27 public="1" get="inline" set="null" line="325" static="1"><x path="Int"/></TEXTURE27>
		<TEXTURE28 public="1" get="inline" set="null" line="326" static="1"><x path="Int"/></TEXTURE28>
		<TEXTURE29 public="1" get="inline" set="null" line="327" static="1"><x path="Int"/></TEXTURE29>
		<TEXTURE30 public="1" get="inline" set="null" line="328" static="1"><x path="Int"/></TEXTURE30>
		<TEXTURE31 public="1" get="inline" set="null" line="329" static="1"><x path="Int"/></TEXTURE31>
		<ACTIVE_TEXTURE public="1" get="inline" set="null" line="330" static="1"><x path="Int"/></ACTIVE_TEXTURE>
		<REPEAT public="1" get="inline" set="null" line="333" static="1"><x path="Int"/></REPEAT>
		<CLAMP_TO_EDGE public="1" get="inline" set="null" line="334" static="1"><x path="Int"/></CLAMP_TO_EDGE>
		<MIRRORED_REPEAT public="1" get="inline" set="null" line="335" static="1"><x path="Int"/></MIRRORED_REPEAT>
		<FLOAT_VEC2 public="1" get="inline" set="null" line="338" static="1"><x path="Int"/></FLOAT_VEC2>
		<FLOAT_VEC3 public="1" get="inline" set="null" line="339" static="1"><x path="Int"/></FLOAT_VEC3>
		<FLOAT_VEC4 public="1" get="inline" set="null" line="340" static="1"><x path="Int"/></FLOAT_VEC4>
		<INT_VEC2 public="1" get="inline" set="null" line="341" static="1"><x path="Int"/></INT_VEC2>
		<INT_VEC3 public="1" get="inline" set="null" line="342" static="1"><x path="Int"/></INT_VEC3>
		<INT_VEC4 public="1" get="inline" set="null" line="343" static="1"><x path="Int"/></INT_VEC4>
		<BOOL public="1" get="inline" set="null" line="344" static="1"><x path="Int"/></BOOL>
		<BOOL_VEC2 public="1" get="inline" set="null" line="345" static="1"><x path="Int"/></BOOL_VEC2>
		<BOOL_VEC3 public="1" get="inline" set="null" line="346" static="1"><x path="Int"/></BOOL_VEC3>
		<BOOL_VEC4 public="1" get="inline" set="null" line="347" static="1"><x path="Int"/></BOOL_VEC4>
		<FLOAT_MAT2 public="1" get="inline" set="null" line="348" static="1"><x path="Int"/></FLOAT_MAT2>
		<FLOAT_MAT3 public="1" get="inline" set="null" line="349" static="1"><x path="Int"/></FLOAT_MAT3>
		<FLOAT_MAT4 public="1" get="inline" set="null" line="350" static="1"><x path="Int"/></FLOAT_MAT4>
		<SAMPLER_2D public="1" get="inline" set="null" line="351" static="1"><x path="Int"/></SAMPLER_2D>
		<SAMPLER_CUBE public="1" get="inline" set="null" line="352" static="1"><x path="Int"/></SAMPLER_CUBE>
		<VERTEX_ATTRIB_ARRAY_ENABLED public="1" get="inline" set="null" line="355" static="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_ENABLED>
		<VERTEX_ATTRIB_ARRAY_SIZE public="1" get="inline" set="null" line="356" static="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_SIZE>
		<VERTEX_ATTRIB_ARRAY_STRIDE public="1" get="inline" set="null" line="357" static="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_STRIDE>
		<VERTEX_ATTRIB_ARRAY_TYPE public="1" get="inline" set="null" line="358" static="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_TYPE>
		<VERTEX_ATTRIB_ARRAY_NORMALIZED public="1" get="inline" set="null" line="359" static="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_NORMALIZED>
		<VERTEX_ATTRIB_ARRAY_POINTER public="1" get="inline" set="null" line="360" static="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_POINTER>
		<VERTEX_ATTRIB_ARRAY_BUFFER_BINDING public="1" get="inline" set="null" line="361" static="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_BUFFER_BINDING>
		<VERTEX_PROGRAM_POINT_SIZE public="1" get="inline" set="null" line="364" static="1"><x path="Int"/></VERTEX_PROGRAM_POINT_SIZE>
		<POINT_SPRITE public="1" get="inline" set="null" line="365" static="1"><x path="Int"/></POINT_SPRITE>
		<COMPILE_STATUS public="1" get="inline" set="null" line="368" static="1"><x path="Int"/></COMPILE_STATUS>
		<LOW_FLOAT public="1" get="inline" set="null" line="371" static="1"><x path="Int"/></LOW_FLOAT>
		<MEDIUM_FLOAT public="1" get="inline" set="null" line="372" static="1"><x path="Int"/></MEDIUM_FLOAT>
		<HIGH_FLOAT public="1" get="inline" set="null" line="373" static="1"><x path="Int"/></HIGH_FLOAT>
		<LOW_INT public="1" get="inline" set="null" line="374" static="1"><x path="Int"/></LOW_INT>
		<MEDIUM_INT public="1" get="inline" set="null" line="375" static="1"><x path="Int"/></MEDIUM_INT>
		<HIGH_INT public="1" get="inline" set="null" line="376" static="1"><x path="Int"/></HIGH_INT>
		<FRAMEBUFFER public="1" get="inline" set="null" line="379" static="1"><x path="Int"/></FRAMEBUFFER>
		<RENDERBUFFER public="1" get="inline" set="null" line="380" static="1"><x path="Int"/></RENDERBUFFER>
		<RGBA4 public="1" get="inline" set="null" line="382" static="1"><x path="Int"/></RGBA4>
		<RGB5_A1 public="1" get="inline" set="null" line="383" static="1"><x path="Int"/></RGB5_A1>
		<RGB565 public="1" get="inline" set="null" line="384" static="1"><x path="Int"/></RGB565>
		<DEPTH_COMPONENT16 public="1" get="inline" set="null" line="385" static="1"><x path="Int"/></DEPTH_COMPONENT16>
		<STENCIL_INDEX public="1" get="inline" set="null" line="386" static="1"><x path="Int"/></STENCIL_INDEX>
		<STENCIL_INDEX8 public="1" get="inline" set="null" line="387" static="1"><x path="Int"/></STENCIL_INDEX8>
		<DEPTH_STENCIL public="1" get="inline" set="null" line="388" static="1"><x path="Int"/></DEPTH_STENCIL>
		<RENDERBUFFER_WIDTH public="1" get="inline" set="null" line="390" static="1"><x path="Int"/></RENDERBUFFER_WIDTH>
		<RENDERBUFFER_HEIGHT public="1" get="inline" set="null" line="391" static="1"><x path="Int"/></RENDERBUFFER_HEIGHT>
		<RENDERBUFFER_INTERNAL_FORMAT public="1" get="inline" set="null" line="392" static="1"><x path="Int"/></RENDERBUFFER_INTERNAL_FORMAT>
		<RENDERBUFFER_RED_SIZE public="1" get="inline" set="null" line="393" static="1"><x path="Int"/></RENDERBUFFER_RED_SIZE>
		<RENDERBUFFER_GREEN_SIZE public="1" get="inline" set="null" line="394" static="1"><x path="Int"/></RENDERBUFFER_GREEN_SIZE>
		<RENDERBUFFER_BLUE_SIZE public="1" get="inline" set="null" line="395" static="1"><x path="Int"/></RENDERBUFFER_BLUE_SIZE>
		<RENDERBUFFER_ALPHA_SIZE public="1" get="inline" set="null" line="396" static="1"><x path="Int"/></RENDERBUFFER_ALPHA_SIZE>
		<RENDERBUFFER_DEPTH_SIZE public="1" get="inline" set="null" line="397" static="1"><x path="Int"/></RENDERBUFFER_DEPTH_SIZE>
		<RENDERBUFFER_STENCIL_SIZE public="1" get="inline" set="null" line="398" static="1"><x path="Int"/></RENDERBUFFER_STENCIL_SIZE>
		<FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE public="1" get="inline" set="null" line="400" static="1"><x path="Int"/></FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE>
		<FRAMEBUFFER_ATTACHMENT_OBJECT_NAME public="1" get="inline" set="null" line="401" static="1"><x path="Int"/></FRAMEBUFFER_ATTACHMENT_OBJECT_NAME>
		<FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL public="1" get="inline" set="null" line="402" static="1"><x path="Int"/></FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL>
		<FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE public="1" get="inline" set="null" line="403" static="1"><x path="Int"/></FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE>
		<COLOR_ATTACHMENT0 public="1" get="inline" set="null" line="405" static="1"><x path="Int"/></COLOR_ATTACHMENT0>
		<DEPTH_ATTACHMENT public="1" get="inline" set="null" line="406" static="1"><x path="Int"/></DEPTH_ATTACHMENT>
		<STENCIL_ATTACHMENT public="1" get="inline" set="null" line="407" static="1"><x path="Int"/></STENCIL_ATTACHMENT>
		<DEPTH_STENCIL_ATTACHMENT public="1" get="inline" set="null" line="408" static="1"><x path="Int"/></DEPTH_STENCIL_ATTACHMENT>
		<NONE public="1" get="inline" set="null" line="410" static="1"><x path="Int"/></NONE>
		<FRAMEBUFFER_COMPLETE public="1" get="inline" set="null" line="412" static="1"><x path="Int"/></FRAMEBUFFER_COMPLETE>
		<FRAMEBUFFER_INCOMPLETE_ATTACHMENT public="1" get="inline" set="null" line="413" static="1"><x path="Int"/></FRAMEBUFFER_INCOMPLETE_ATTACHMENT>
		<FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT public="1" get="inline" set="null" line="414" static="1"><x path="Int"/></FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT>
		<FRAMEBUFFER_INCOMPLETE_DIMENSIONS public="1" get="inline" set="null" line="415" static="1"><x path="Int"/></FRAMEBUFFER_INCOMPLETE_DIMENSIONS>
		<FRAMEBUFFER_UNSUPPORTED public="1" get="inline" set="null" line="416" static="1"><x path="Int"/></FRAMEBUFFER_UNSUPPORTED>
		<FRAMEBUFFER_BINDING public="1" get="inline" set="null" line="418" static="1"><x path="Int"/></FRAMEBUFFER_BINDING>
		<RENDERBUFFER_BINDING public="1" get="inline" set="null" line="419" static="1"><x path="Int"/></RENDERBUFFER_BINDING>
		<MAX_RENDERBUFFER_SIZE public="1" get="inline" set="null" line="420" static="1"><x path="Int"/></MAX_RENDERBUFFER_SIZE>
		<INVALID_FRAMEBUFFER_OPERATION public="1" get="inline" set="null" line="422" static="1"><x path="Int"/></INVALID_FRAMEBUFFER_OPERATION>
		<UNPACK_FLIP_Y_WEBGL public="1" get="inline" set="null" line="425" static="1"><x path="Int"/></UNPACK_FLIP_Y_WEBGL>
		<UNPACK_PREMULTIPLY_ALPHA_WEBGL public="1" get="inline" set="null" line="426" static="1"><x path="Int"/></UNPACK_PREMULTIPLY_ALPHA_WEBGL>
		<CONTEXT_LOST_WEBGL public="1" get="inline" set="null" line="427" static="1"><x path="Int"/></CONTEXT_LOST_WEBGL>
		<UNPACK_COLORSPACE_CONVERSION_WEBGL public="1" get="inline" set="null" line="428" static="1"><x path="Int"/></UNPACK_COLORSPACE_CONVERSION_WEBGL>
		<BROWSER_DEFAULT_WEBGL public="1" get="inline" set="null" line="429" static="1"><x path="Int"/></BROWSER_DEFAULT_WEBGL>
		<drawingBufferHeight public="1" get="accessor" set="null" static="1"><x path="Int"/></drawingBufferHeight>
		<drawingBufferWidth public="1" get="accessor" set="null" static="1"><x path="Int"/></drawingBufferWidth>
		<version public="1" get="accessor" set="null" static="1"><x path="Int"/></version>
		<activeTexture public="1" set="method" line="435" static="1"><f a="texture">
	<x path="Int"/>
	<x path="Void"/>
</f></activeTexture>
		<attachShader public="1" set="method" line="437" static="1"><f a="program:shader">
	<c path="lime.gl.GLProgram"/>
	<c path="lime.gl.GLShader"/>
	<x path="Void"/>
</f></attachShader>
		<bindAttribLocation public="1" set="method" line="443" static="1"><f a="program:index:name">
	<c path="lime.gl.GLProgram"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></bindAttribLocation>
		<bindBuffer public="1" set="method" line="454" static="1"><f a="target:buffer">
	<x path="Int"/>
	<c path="lime.gl.GLBuffer"/>
	<x path="Void"/>
</f></bindBuffer>
		<bindFramebuffer public="1" set="method" line="459" static="1"><f a="target:framebuffer">
	<x path="Int"/>
	<c path="lime.gl.GLFramebuffer"/>
	<x path="Void"/>
</f></bindFramebuffer>
		<bindRenderbuffer public="1" set="method" line="464" static="1"><f a="target:renderbuffer">
	<x path="Int"/>
	<c path="lime.gl.GLRenderbuffer"/>
	<x path="Void"/>
</f></bindRenderbuffer>
		<bindTexture public="1" set="method" line="469" static="1"><f a="target:texture">
	<x path="Int"/>
	<c path="lime.gl.GLTexture"/>
	<x path="Void"/>
</f></bindTexture>
		<blendColor public="1" set="method" line="474" static="1"><f a="red:green:blue:alpha">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></blendColor>
		<blendEquation public="1" set="method" line="479" static="1"><f a="mode">
	<x path="Int"/>
	<x path="Void"/>
</f></blendEquation>
		<blendEquationSeparate public="1" set="method" line="484" static="1"><f a="modeRGB:modeAlpha">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blendEquationSeparate>
		<blendFunc public="1" set="method" line="489" static="1"><f a="sfactor:dfactor">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blendFunc>
		<blendFuncSeparate public="1" set="method" line="494" static="1"><f a="srcRGB:dstRGB:srcAlpha:dstAlpha">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blendFuncSeparate>
		<bufferData public="1" set="method" line="499" static="1"><f a="target:data:usage">
	<x path="Int"/>
	<c path="lime.utils.IMemoryRange"/>
	<x path="Int"/>
	<x path="Void"/>
</f></bufferData>
		<bufferSubData public="1" set="method" line="504" static="1"><f a="target:offset:data">
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.IMemoryRange"/>
	<x path="Void"/>
</f></bufferSubData>
		<checkFramebufferStatus public="1" set="method" line="509" static="1"><f a="target">
	<x path="Int"/>
	<x path="Int"/>
</f></checkFramebufferStatus>
		<clear public="1" set="method" line="514" static="1"><f a="mask">
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
		<clearColor public="1" set="method" line="519" static="1"><f a="red:green:blue:alpha">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></clearColor>
		<clearDepth public="1" set="method" line="524" static="1"><f a="depth">
	<x path="Float"/>
	<x path="Void"/>
</f></clearDepth>
		<clearStencil public="1" set="method" line="529" static="1"><f a="s">
	<x path="Int"/>
	<x path="Void"/>
</f></clearStencil>
		<colorMask public="1" set="method" line="534" static="1"><f a="red:green:blue:alpha">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></colorMask>
		<compileShader public="1" set="method" line="539" static="1"><f a="shader">
	<c path="lime.gl.GLShader"/>
	<x path="Void"/>
</f></compileShader>
		<compressedTexImage2D public="1" set="method" line="544" static="1"><f a="target:level:internalformat:width:height:border:data">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.IMemoryRange"/>
	<x path="Void"/>
</f></compressedTexImage2D>
		<compressedTexSubImage2D public="1" set="method" line="549" static="1"><f a="target:level:xoffset:yoffset:width:height:format:data">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.IMemoryRange"/>
	<x path="Void"/>
</f></compressedTexSubImage2D>
		<copyTexImage2D public="1" set="method" line="554" static="1"><f a="target:level:internalformat:x:y:width:height:border">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></copyTexImage2D>
		<copyTexSubImage2D public="1" set="method" line="559" static="1"><f a="target:level:xoffset:yoffset:x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></copyTexSubImage2D>
		<createBuffer public="1" set="method" line="564" static="1"><f a=""><c path="lime.gl.GLBuffer"/></f></createBuffer>
		<createFramebuffer public="1" set="method" line="569" static="1"><f a=""><c path="lime.gl.GLFramebuffer"/></f></createFramebuffer>
		<createProgram public="1" set="method" line="574" static="1"><f a=""><c path="lime.gl.GLProgram"/></f></createProgram>
		<createRenderbuffer public="1" set="method" line="579" static="1"><f a=""><c path="lime.gl.GLRenderbuffer"/></f></createRenderbuffer>
		<createShader public="1" set="method" line="584" static="1"><f a="type">
	<x path="Int"/>
	<c path="lime.gl.GLShader"/>
</f></createShader>
		<createTexture public="1" set="method" line="589" static="1"><f a=""><c path="lime.gl.GLTexture"/></f></createTexture>
		<cullFace public="1" set="method" line="594" static="1"><f a="mode">
	<x path="Int"/>
	<x path="Void"/>
</f></cullFace>
		<deleteBuffer public="1" set="method" line="598" static="1"><f a="buffer">
	<c path="lime.gl.GLBuffer"/>
	<x path="Void"/>
</f></deleteBuffer>
		<deleteFramebuffer public="1" set="method" line="604" static="1"><f a="framebuffer">
	<c path="lime.gl.GLFramebuffer"/>
	<x path="Void"/>
</f></deleteFramebuffer>
		<deleteProgram public="1" set="method" line="608" static="1"><f a="program">
	<c path="lime.gl.GLProgram"/>
	<x path="Void"/>
</f></deleteProgram>
		<deleteRenderbuffer public="1" set="method" line="614" static="1"><f a="renderbuffer">
	<c path="lime.gl.GLRenderbuffer"/>
	<x path="Void"/>
</f></deleteRenderbuffer>
		<deleteShader public="1" set="method" line="618" static="1"><f a="shader">
	<c path="lime.gl.GLShader"/>
	<x path="Void"/>
</f></deleteShader>
		<deleteTexture public="1" set="method" line="624" static="1"><f a="texture">
	<c path="lime.gl.GLTexture"/>
	<x path="Void"/>
</f></deleteTexture>
		<depthFunc public="1" set="method" line="630" static="1"><f a="func">
	<x path="Int"/>
	<x path="Void"/>
</f></depthFunc>
		<depthMask public="1" set="method" line="635" static="1"><f a="flag">
	<x path="Bool"/>
	<x path="Void"/>
</f></depthMask>
		<depthRange public="1" set="method" line="640" static="1"><f a="zNear:zFar">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></depthRange>
		<detachShader public="1" set="method" line="645" static="1"><f a="program:shader">
	<c path="lime.gl.GLProgram"/>
	<c path="lime.gl.GLShader"/>
	<x path="Void"/>
</f></detachShader>
		<disable public="1" set="method" line="650" static="1"><f a="cap">
	<x path="Int"/>
	<x path="Void"/>
</f></disable>
		<disableVertexAttribArray public="1" set="method" line="655" static="1"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></disableVertexAttribArray>
		<drawArrays public="1" set="method" line="660" static="1"><f a="mode:first:count">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawArrays>
		<drawElements public="1" set="method" line="665" static="1"><f a="mode:count:type:offset">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawElements>
		<enable public="1" set="method" line="670" static="1"><f a="cap">
	<x path="Int"/>
	<x path="Void"/>
</f></enable>
		<enableVertexAttribArray public="1" set="method" line="675" static="1"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></enableVertexAttribArray>
		<finish public="1" set="method" line="680" static="1"><f a=""><x path="Void"/></f></finish>
		<flush public="1" set="method" line="685" static="1"><f a=""><x path="Void"/></f></flush>
		<framebufferRenderbuffer public="1" set="method" line="690" static="1"><f a="target:attachment:renderbuffertarget:renderbuffer">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.gl.GLRenderbuffer"/>
	<x path="Void"/>
</f></framebufferRenderbuffer>
		<framebufferTexture2D public="1" set="method" line="695" static="1"><f a="target:attachment:textarget:texture:level">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.gl.GLTexture"/>
	<x path="Int"/>
	<x path="Void"/>
</f></framebufferTexture2D>
		<frontFace public="1" set="method" line="700" static="1"><f a="mode">
	<x path="Int"/>
	<x path="Void"/>
</f></frontFace>
		<generateMipmap public="1" set="method" line="705" static="1"><f a="target">
	<x path="Int"/>
	<x path="Void"/>
</f></generateMipmap>
		<getActiveAttrib public="1" set="method" line="710" static="1"><f a="program:index">
	<c path="lime.gl.GLProgram"/>
	<x path="Int"/>
	<t path="lime.gl.GLActiveInfo"/>
</f></getActiveAttrib>
		<getActiveUniform public="1" set="method" line="715" static="1"><f a="program:index">
	<c path="lime.gl.GLProgram"/>
	<x path="Int"/>
	<t path="lime.gl.GLActiveInfo"/>
</f></getActiveUniform>
		<getAttachedShaders public="1" set="method" line="720" static="1"><f a="program">
	<c path="lime.gl.GLProgram"/>
	<c path="Array"><c path="lime.gl.GLShader"/></c>
</f></getAttachedShaders>
		<getAttribLocation public="1" set="method" line="725" static="1"><f a="program:name">
	<c path="lime.gl.GLProgram"/>
	<c path="String"/>
	<x path="Int"/>
</f></getAttribLocation>
		<getBufferParameter public="1" set="method" line="730" static="1"><f a="target:pname">
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></getBufferParameter>
		<getContextAttributes public="1" set="method" line="735" static="1"><f a=""><t path="lime.gl.GLContextAttributes"/></f></getContextAttributes>
		<getError public="1" set="method" line="743" static="1"><f a=""><x path="Int"/></f></getError>
		<getExtension public="1" set="method" line="748" static="1"><f a="name">
	<c path="String"/>
	<d/>
</f></getExtension>
		<getFramebufferAttachmentParameter public="1" set="method" line="755" static="1"><f a="target:attachment:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></getFramebufferAttachmentParameter>
		<getParameter public="1" set="method" line="760" static="1"><f a="pname">
	<x path="Int"/>
	<d/>
</f></getParameter>
		<getProgramInfoLog public="1" set="method" line="765" static="1"><f a="program">
	<c path="lime.gl.GLProgram"/>
	<c path="String"/>
</f></getProgramInfoLog>
		<getProgramParameter public="1" set="method" line="770" static="1"><f a="program:pname">
	<c path="lime.gl.GLProgram"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getProgramParameter>
		<getRenderbufferParameter public="1" set="method" line="775" static="1"><f a="target:pname">
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></getRenderbufferParameter>
		<getShaderInfoLog public="1" set="method" line="780" static="1"><f a="shader">
	<c path="lime.gl.GLShader"/>
	<c path="String"/>
</f></getShaderInfoLog>
		<getShaderParameter public="1" set="method" line="785" static="1"><f a="shader:pname">
	<c path="lime.gl.GLShader"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getShaderParameter>
		<getShaderPrecisionFormat public="1" set="method" line="790" static="1"><f a="shadertype:precisiontype">
	<x path="Int"/>
	<x path="Int"/>
	<t path="lime.gl.native.ShaderPrecisionFormat"/>
</f></getShaderPrecisionFormat>
		<getShaderSource public="1" set="method" line="795" static="1"><f a="shader">
	<c path="lime.gl.GLShader"/>
	<c path="String"/>
</f></getShaderSource>
		<getSupportedExtensions public="1" set="method" line="800" static="1"><f a=""><c path="Array"><c path="String"/></c></f></getSupportedExtensions>
		<getTexParameter public="1" set="method" line="807" static="1"><f a="target:pname">
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></getTexParameter>
		<getUniform public="1" set="method" line="812" static="1"><f a="program:location">
	<c path="lime.gl.GLProgram"/>
	<t path="lime.gl.GLUniformLocation"/>
	<d/>
</f></getUniform>
		<getUniformLocation public="1" set="method" line="817" static="1"><f a="program:name">
	<c path="lime.gl.GLProgram"/>
	<c path="String"/>
	<d/>
</f></getUniformLocation>
		<getVertexAttrib public="1" set="method" line="822" static="1"><f a="index:pname">
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></getVertexAttrib>
		<getVertexAttribOffset public="1" set="method" line="827" static="1"><f a="index:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getVertexAttribOffset>
		<hint public="1" set="method" line="832" static="1"><f a="target:mode">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></hint>
		<isBuffer public="1" set="method" line="837" static="1"><f a="buffer">
	<c path="lime.gl.GLBuffer"/>
	<x path="Bool"/>
</f></isBuffer>
		<isEnabled public="1" set="method" line="844" static="1"><f a="cap">
	<x path="Int"/>
	<x path="Bool"/>
</f></isEnabled>
		<isFramebuffer public="1" set="method" line="849" static="1"><f a="framebuffer">
	<c path="lime.gl.GLFramebuffer"/>
	<x path="Bool"/>
</f></isFramebuffer>
		<isProgram public="1" set="method" line="854" static="1"><f a="program">
	<c path="lime.gl.GLProgram"/>
	<x path="Bool"/>
</f></isProgram>
		<isRenderbuffer public="1" set="method" line="859" static="1"><f a="renderbuffer">
	<c path="lime.gl.GLRenderbuffer"/>
	<x path="Bool"/>
</f></isRenderbuffer>
		<isShader public="1" set="method" line="864" static="1"><f a="shader">
	<c path="lime.gl.GLShader"/>
	<x path="Bool"/>
</f></isShader>
		<isTexture public="1" set="method" line="869" static="1"><f a="texture">
	<c path="lime.gl.GLTexture"/>
	<x path="Bool"/>
</f></isTexture>
		<lineWidth public="1" set="method" line="874" static="1"><f a="width">
	<x path="Float"/>
	<x path="Void"/>
</f></lineWidth>
		<linkProgram public="1" set="method" line="879" static="1"><f a="program">
	<c path="lime.gl.GLProgram"/>
	<x path="Void"/>
</f></linkProgram>
		<load set="method" line="884" static="1"><f a="inName:inArgCount">
	<c path="String"/>
	<x path="Int"/>
	<d/>
</f></load>
		<pixelStorei public="1" set="method" line="897" static="1"><f a="pname:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></pixelStorei>
		<polygonOffset public="1" set="method" line="902" static="1"><f a="factor:units">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></polygonOffset>
		<renderbufferStorage public="1" set="method" line="912" static="1"><f a="target:internalformat:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></renderbufferStorage>
		<sampleCoverage public="1" set="method" line="917" static="1"><f a="value:invert">
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></sampleCoverage>
		<scissor public="1" set="method" line="922" static="1"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></scissor>
		<shaderSource public="1" set="method" line="927" static="1"><f a="shader:source">
	<c path="lime.gl.GLShader"/>
	<c path="String"/>
	<x path="Void"/>
</f></shaderSource>
		<stencilFunc public="1" set="method" line="932" static="1"><f a="func:ref:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilFunc>
		<stencilFuncSeparate public="1" set="method" line="937" static="1"><f a="face:func:ref:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilFuncSeparate>
		<stencilMask public="1" set="method" line="942" static="1"><f a="mask">
	<x path="Int"/>
	<x path="Void"/>
</f></stencilMask>
		<stencilMaskSeparate public="1" set="method" line="947" static="1"><f a="face:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilMaskSeparate>
		<stencilOp public="1" set="method" line="952" static="1"><f a="fail:zfail:zpass">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilOp>
		<stencilOpSeparate public="1" set="method" line="957" static="1"><f a="face:fail:zfail:zpass">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilOpSeparate>
		<texImage2D public="1" set="method" line="962" static="1"><f a="target:level:internalformat:width:height:border:format:type:pixels">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Void"/>
</f></texImage2D>
		<texParameterf public="1" set="method" line="967" static="1"><f a="target:pname:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></texParameterf>
		<texParameteri public="1" set="method" line="972" static="1"><f a="target:pname:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></texParameteri>
		<texSubImage2D public="1" set="method" line="977" static="1"><f a="target:level:xoffset:yoffset:width:height:format:type:pixels">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Void"/>
</f></texSubImage2D>
		<uniform1f public="1" set="method" line="982" static="1"><f a="location:x">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform1f>
		<uniform1fv public="1" set="method" line="987" static="1"><f a="location:x">
	<t path="lime.gl.GLUniformLocation"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></uniform1fv>
		<uniform1i public="1" set="method" line="992" static="1"><f a="location:x">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform1i>
		<uniform1iv public="1" set="method" line="997" static="1"><f a="location:v">
	<t path="lime.gl.GLUniformLocation"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></uniform1iv>
		<uniform2f public="1" set="method" line="1002" static="1"><f a="location:x:y">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform2f>
		<uniform2fv public="1" set="method" line="1007" static="1"><f a="location:v">
	<t path="lime.gl.GLUniformLocation"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></uniform2fv>
		<uniform2i public="1" set="method" line="1012" static="1"><f a="location:x:y">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform2i>
		<uniform2iv public="1" set="method" line="1017" static="1"><f a="location:v">
	<t path="lime.gl.GLUniformLocation"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></uniform2iv>
		<uniform3f public="1" set="method" line="1022" static="1"><f a="location:x:y:z">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform3f>
		<uniform3fv public="1" set="method" line="1027" static="1"><f a="location:v">
	<t path="lime.gl.GLUniformLocation"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></uniform3fv>
		<uniform3i public="1" set="method" line="1032" static="1"><f a="location:x:y:z">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform3i>
		<uniform3iv public="1" set="method" line="1037" static="1"><f a="location:v">
	<t path="lime.gl.GLUniformLocation"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></uniform3iv>
		<uniform4f public="1" set="method" line="1042" static="1"><f a="location:x:y:z:w">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform4f>
		<uniform4fv public="1" set="method" line="1047" static="1"><f a="location:v">
	<t path="lime.gl.GLUniformLocation"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></uniform4fv>
		<uniform4i public="1" set="method" line="1052" static="1"><f a="location:x:y:z:w">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform4i>
		<uniform4iv public="1" set="method" line="1057" static="1"><f a="location:v">
	<t path="lime.gl.GLUniformLocation"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></uniform4iv>
		<uniformMatrix2fv public="1" set="method" line="1062" static="1"><f a="location:transpose:v">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Bool"/>
	<c path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniformMatrix2fv>
		<uniformMatrix3fv public="1" set="method" line="1067" static="1"><f a="location:transpose:v">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Bool"/>
	<c path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniformMatrix3fv>
		<uniformMatrix4fv public="1" set="method" line="1072" static="1"><f a="location:transpose:v">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Bool"/>
	<c path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniformMatrix4fv>
		<uniformMatrix3D public="1" set="method" line="1077" static="1"><f a="location:transpose:matrix">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Bool"/>
	<c path="lime.geometry.Matrix3D"/>
	<x path="Void"/>
</f></uniformMatrix3D>
		<useProgram public="1" set="method" line="1082" static="1"><f a="program">
	<c path="lime.gl.GLProgram"/>
	<x path="Void"/>
</f></useProgram>
		<validateProgram public="1" set="method" line="1087" static="1"><f a="program">
	<c path="lime.gl.GLProgram"/>
	<x path="Void"/>
</f></validateProgram>
		<vertexAttrib1f public="1" set="method" line="1092" static="1"><f a="indx:x">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib1f>
		<vertexAttrib1fv public="1" set="method" line="1097" static="1"><f a="indx:values">
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></vertexAttrib1fv>
		<vertexAttrib2f public="1" set="method" line="1102" static="1"><f a="indx:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib2f>
		<vertexAttrib2fv public="1" set="method" line="1107" static="1"><f a="indx:values">
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></vertexAttrib2fv>
		<vertexAttrib3f public="1" set="method" line="1112" static="1"><f a="indx:x:y:z">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib3f>
		<vertexAttrib3fv public="1" set="method" line="1117" static="1"><f a="indx:values">
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></vertexAttrib3fv>
		<vertexAttrib4f public="1" set="method" line="1122" static="1"><f a="indx:x:y:z:w">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib4f>
		<vertexAttrib4fv public="1" set="method" line="1127" static="1"><f a="indx:values">
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></vertexAttrib4fv>
		<vertexAttribPointer public="1" set="method" line="1132" static="1"><f a="indx:size:type:normalized:stride:offset">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></vertexAttribPointer>
		<viewport public="1" set="method" line="1137" static="1"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></viewport>
		<get_drawingBufferHeight set="method" line="1150" static="1"><f a=""><x path="Int"/></f></get_drawingBufferHeight>
		<get_drawingBufferWidth set="method" line="1151" static="1"><f a=""><x path="Int"/></f></get_drawingBufferWidth>
		<get_version set="method" line="1152" static="1"><f a=""><x path="Int"/></f></get_version>
		<nme_gl_active_texture line="1162" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></nme_gl_active_texture>
		<nme_gl_attach_shader line="1163" static="1"><f a=":">
	<d/>
	<d/>
	<unknown/>
</f></nme_gl_attach_shader>
		<nme_gl_bind_attrib_location line="1164" static="1"><f a="::">
	<d/>
	<x path="Int"/>
	<c path="String"/>
	<unknown/>
</f></nme_gl_bind_attrib_location>
		<nme_gl_bind_bitmap_data_texture line="1165" static="1"><unknown/></nme_gl_bind_bitmap_data_texture>
		<nme_gl_bind_buffer line="1166" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_bind_buffer>
		<nme_gl_bind_framebuffer line="1167" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_bind_framebuffer>
		<nme_gl_bind_renderbuffer line="1168" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_bind_renderbuffer>
		<nme_gl_bind_texture line="1169" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_bind_texture>
		<nme_gl_blend_color line="1170" static="1"><f a=":::">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></nme_gl_blend_color>
		<nme_gl_blend_equation line="1171" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></nme_gl_blend_equation>
		<nme_gl_blend_equation_separate line="1172" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_blend_equation_separate>
		<nme_gl_blend_func line="1173" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_blend_func>
		<nme_gl_blend_func_separate line="1174" static="1"><f a=":::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_blend_func_separate>
		<nme_gl_buffer_data line="1175" static="1"><f a="::::">
	<x path="Int"/>
	<t path="lime.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_buffer_data>
		<nme_gl_buffer_sub_data line="1176" static="1"><f a="::::">
	<x path="Int"/>
	<x path="Int"/>
	<t path="lime.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_buffer_sub_data>
		<nme_gl_check_framebuffer_status line="1177" static="1"><f a="">
	<x path="Int"/>
	<x path="Int"/>
</f></nme_gl_check_framebuffer_status>
		<nme_gl_clear line="1178" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></nme_gl_clear>
		<nme_gl_clear_color line="1179" static="1"><f a=":::">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></nme_gl_clear_color>
		<nme_gl_clear_depth line="1180" static="1"><f a="">
	<x path="Float"/>
	<unknown/>
</f></nme_gl_clear_depth>
		<nme_gl_clear_stencil line="1181" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></nme_gl_clear_stencil>
		<nme_gl_color_mask line="1182" static="1"><f a=":::">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<unknown/>
</f></nme_gl_color_mask>
		<nme_gl_compile_shader line="1183" static="1"><f a="">
	<d/>
	<unknown/>
</f></nme_gl_compile_shader>
		<nme_gl_compressed_tex_image_2d line="1184" static="1"><f a=":::::::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<t path="Null"><c path="lime.utils.native.ByteArray"/></t>
	<t path="Null"><x path="Int"/></t>
	<unknown/>
</f></nme_gl_compressed_tex_image_2d>
		<nme_gl_compressed_tex_sub_image_2d line="1185" static="1"><f a="::::::::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<t path="Null"><c path="lime.utils.native.ByteArray"/></t>
	<t path="Null"><x path="Int"/></t>
	<unknown/>
</f></nme_gl_compressed_tex_sub_image_2d>
		<nme_gl_copy_tex_image_2d line="1186" static="1"><f a=":::::::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_copy_tex_image_2d>
		<nme_gl_copy_tex_sub_image_2d line="1187" static="1"><f a=":::::::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_copy_tex_sub_image_2d>
		<nme_gl_create_buffer line="1188" static="1"><f a=""><unknown/></f></nme_gl_create_buffer>
		<nme_gl_create_framebuffer line="1189" static="1"><f a=""><unknown/></f></nme_gl_create_framebuffer>
		<nme_gl_create_program line="1190" static="1"><f a=""><unknown/></f></nme_gl_create_program>
		<nme_gl_create_render_buffer line="1191" static="1"><f a=""><unknown/></f></nme_gl_create_render_buffer>
		<nme_gl_create_shader line="1192" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></nme_gl_create_shader>
		<nme_gl_create_texture line="1193" static="1"><f a=""><unknown/></f></nme_gl_create_texture>
		<nme_gl_delete_buffer line="1194" static="1"><f a="">
	<d/>
	<unknown/>
</f></nme_gl_delete_buffer>
		<nme_gl_delete_program line="1195" static="1"><f a="">
	<d/>
	<unknown/>
</f></nme_gl_delete_program>
		<nme_gl_delete_shader line="1196" static="1"><f a="">
	<d/>
	<unknown/>
</f></nme_gl_delete_shader>
		<nme_gl_delete_texture line="1197" static="1"><f a="">
	<d/>
	<unknown/>
</f></nme_gl_delete_texture>
		<nme_gl_depth_func line="1198" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></nme_gl_depth_func>
		<nme_gl_depth_mask line="1199" static="1"><f a="">
	<x path="Bool"/>
	<unknown/>
</f></nme_gl_depth_mask>
		<nme_gl_depth_range line="1200" static="1"><f a=":">
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></nme_gl_depth_range>
		<nme_gl_detach_shader line="1201" static="1"><f a=":">
	<d/>
	<d/>
	<unknown/>
</f></nme_gl_detach_shader>
		<nme_gl_disable line="1202" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></nme_gl_disable>
		<nme_gl_disable_vertex_attrib_array line="1203" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></nme_gl_disable_vertex_attrib_array>
		<nme_gl_draw_arrays line="1204" static="1"><f a="::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_draw_arrays>
		<nme_gl_draw_elements line="1205" static="1"><f a=":::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_draw_elements>
		<nme_gl_enable line="1206" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></nme_gl_enable>
		<nme_gl_enable_vertex_attrib_array line="1207" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></nme_gl_enable_vertex_attrib_array>
		<nme_gl_finish line="1208" static="1"><f a=""><unknown/></f></nme_gl_finish>
		<nme_gl_flush line="1209" static="1"><f a=""><unknown/></f></nme_gl_flush>
		<nme_gl_framebuffer_renderbuffer line="1210" static="1"><f a=":::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<d/>
	<unknown/>
</f></nme_gl_framebuffer_renderbuffer>
		<nme_gl_framebuffer_texture2D line="1211" static="1"><f a="::::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<d/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_framebuffer_texture2D>
		<nme_gl_front_face line="1212" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></nme_gl_front_face>
		<nme_gl_generate_mipmap line="1213" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></nme_gl_generate_mipmap>
		<nme_gl_get_active_attrib line="1214" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<t path="lime.gl.GLActiveInfo"/>
</f></nme_gl_get_active_attrib>
		<nme_gl_get_active_uniform line="1215" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<t path="lime.gl.GLActiveInfo"/>
</f></nme_gl_get_active_uniform>
		<nme_gl_get_attrib_location line="1216" static="1"><f a=":">
	<d/>
	<c path="String"/>
	<x path="Int"/>
</f></nme_gl_get_attrib_location>
		<nme_gl_get_buffer_paramerter line="1217" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_get_buffer_paramerter>
		<nme_gl_get_context_attributes line="1218" static="1"><f a=""><a>
	<stencil><x path="Bool"/></stencil>
	<preserveDrawingBuffer><x path="Bool"/></preserveDrawingBuffer>
	<premultipliedAlpha><x path="Bool"/></premultipliedAlpha>
	<depth><x path="Bool"/></depth>
	<antialias><x path="Bool"/></antialias>
	<alpha><x path="Bool"/></alpha>
</a></f></nme_gl_get_context_attributes>
		<nme_gl_get_error line="1219" static="1"><f a=""><x path="Int"/></f></nme_gl_get_error>
		<nme_gl_get_framebuffer_attachment_parameter line="1220" static="1"><f a="::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_get_framebuffer_attachment_parameter>
		<nme_gl_get_parameter line="1221" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></nme_gl_get_parameter>
		<nme_gl_get_program_info_log line="1223" static="1"><f a="">
	<d/>
	<c path="String"/>
</f></nme_gl_get_program_info_log>
		<nme_gl_get_program_parameter line="1224" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
</f></nme_gl_get_program_parameter>
		<nme_gl_get_render_buffer_parameter line="1225" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_get_render_buffer_parameter>
		<nme_gl_get_shader_info_log line="1226" static="1"><f a="">
	<d/>
	<c path="String"/>
</f></nme_gl_get_shader_info_log>
		<nme_gl_get_shader_parameter line="1227" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
</f></nme_gl_get_shader_parameter>
		<nme_gl_get_shader_precision_format line="1228" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<t path="lime.gl.native.ShaderPrecisionFormat"/>
</f></nme_gl_get_shader_precision_format>
		<nme_gl_get_shader_source line="1229" static="1"><f a="">
	<d/>
	<c path="String"/>
</f></nme_gl_get_shader_source>
		<nme_gl_get_supported_extensions line="1230" static="1"><f a="">
	<c path="Array"><c path="String"/></c>
	<unknown/>
</f></nme_gl_get_supported_extensions>
		<nme_gl_get_tex_parameter line="1231" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_get_tex_parameter>
		<nme_gl_get_uniform line="1232" static="1"><f a=":">
	<d/>
	<t path="lime.gl.GLUniformLocation"/>
	<unknown/>
</f></nme_gl_get_uniform>
		<nme_gl_get_uniform_location line="1233" static="1"><f a=":">
	<d/>
	<c path="String"/>
	<unknown/>
</f></nme_gl_get_uniform_location>
		<nme_gl_get_vertex_attrib line="1234" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_get_vertex_attrib>
		<nme_gl_get_vertex_attrib_offset line="1235" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></nme_gl_get_vertex_attrib_offset>
		<nme_gl_hint line="1236" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_hint>
		<nme_gl_is_buffer line="1237" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></nme_gl_is_buffer>
		<nme_gl_is_enabled line="1238" static="1"><f a="">
	<x path="Int"/>
	<x path="Bool"/>
</f></nme_gl_is_enabled>
		<nme_gl_is_framebuffer line="1239" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></nme_gl_is_framebuffer>
		<nme_gl_is_program line="1240" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></nme_gl_is_program>
		<nme_gl_is_renderbuffer line="1241" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></nme_gl_is_renderbuffer>
		<nme_gl_is_shader line="1242" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></nme_gl_is_shader>
		<nme_gl_is_texture line="1243" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></nme_gl_is_texture>
		<nme_gl_line_width line="1244" static="1"><f a="">
	<x path="Float"/>
	<unknown/>
</f></nme_gl_line_width>
		<nme_gl_link_program line="1245" static="1"><f a="">
	<d/>
	<unknown/>
</f></nme_gl_link_program>
		<nme_gl_pixel_storei line="1246" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_pixel_storei>
		<nme_gl_polygon_offset line="1247" static="1"><f a=":">
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></nme_gl_polygon_offset>
		<nme_gl_renderbuffer_storage line="1248" static="1"><f a=":::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_renderbuffer_storage>
		<nme_gl_sample_coverage line="1249" static="1"><f a=":">
	<x path="Float"/>
	<x path="Bool"/>
	<unknown/>
</f></nme_gl_sample_coverage>
		<nme_gl_scissor line="1250" static="1"><f a=":::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_scissor>
		<nme_gl_shader_source line="1251" static="1"><f a=":">
	<d/>
	<c path="String"/>
	<unknown/>
</f></nme_gl_shader_source>
		<nme_gl_stencil_func line="1252" static="1"><f a="::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_stencil_func>
		<nme_gl_stencil_func_separate line="1253" static="1"><f a=":::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_stencil_func_separate>
		<nme_gl_stencil_mask line="1254" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></nme_gl_stencil_mask>
		<nme_gl_stencil_mask_separate line="1255" static="1"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_stencil_mask_separate>
		<nme_gl_stencil_op line="1256" static="1"><f a="::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_stencil_op>
		<nme_gl_stencil_op_separate line="1257" static="1"><f a=":::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_stencil_op_separate>
		<nme_gl_tex_image_2d line="1258" static="1"><f a=":::::::::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<t path="Null"><c path="lime.utils.native.ByteArray"/></t>
	<t path="Null"><x path="Int"/></t>
	<unknown/>
</f></nme_gl_tex_image_2d>
		<nme_gl_tex_parameterf line="1259" static="1"><f a="::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<unknown/>
</f></nme_gl_tex_parameterf>
		<nme_gl_tex_parameteri line="1260" static="1"><f a="::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_tex_parameteri>
		<nme_gl_tex_sub_image_2d line="1261" static="1"><f a=":::::::::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<t path="Null"><c path="lime.utils.native.ByteArray"/></t>
	<t path="Null"><x path="Int"/></t>
	<unknown/>
</f></nme_gl_tex_sub_image_2d>
		<nme_gl_uniform1f line="1262" static="1"><f a=":">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Float"/>
	<unknown/>
</f></nme_gl_uniform1f>
		<nme_gl_uniform1fv line="1263" static="1"><f a=":">
	<t path="lime.gl.GLUniformLocation"/>
	<c path="Array"><x path="Float"/></c>
	<unknown/>
</f></nme_gl_uniform1fv>
		<nme_gl_uniform1i line="1264" static="1"><f a=":">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_uniform1i>
		<nme_gl_uniform1iv line="1265" static="1"><f a=":">
	<t path="lime.gl.GLUniformLocation"/>
	<c path="Array"><x path="Int"/></c>
	<unknown/>
</f></nme_gl_uniform1iv>
		<nme_gl_uniform2f line="1266" static="1"><f a="::">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></nme_gl_uniform2f>
		<nme_gl_uniform2fv line="1267" static="1"><f a=":">
	<t path="lime.gl.GLUniformLocation"/>
	<c path="Array"><x path="Float"/></c>
	<unknown/>
</f></nme_gl_uniform2fv>
		<nme_gl_uniform2i line="1268" static="1"><f a="::">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_uniform2i>
		<nme_gl_uniform2iv line="1269" static="1"><f a=":">
	<t path="lime.gl.GLUniformLocation"/>
	<c path="Array"><x path="Int"/></c>
	<unknown/>
</f></nme_gl_uniform2iv>
		<nme_gl_uniform3f line="1270" static="1"><f a=":::">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></nme_gl_uniform3f>
		<nme_gl_uniform3fv line="1271" static="1"><f a=":">
	<t path="lime.gl.GLUniformLocation"/>
	<c path="Array"><x path="Float"/></c>
	<unknown/>
</f></nme_gl_uniform3fv>
		<nme_gl_uniform3i line="1272" static="1"><f a=":::">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_uniform3i>
		<nme_gl_uniform3iv line="1273" static="1"><f a=":">
	<t path="lime.gl.GLUniformLocation"/>
	<c path="Array"><x path="Int"/></c>
	<unknown/>
</f></nme_gl_uniform3iv>
		<nme_gl_uniform4f line="1274" static="1"><f a="::::">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></nme_gl_uniform4f>
		<nme_gl_uniform4fv line="1275" static="1"><f a=":">
	<t path="lime.gl.GLUniformLocation"/>
	<c path="Array"><x path="Float"/></c>
	<unknown/>
</f></nme_gl_uniform4fv>
		<nme_gl_uniform4i line="1276" static="1"><f a="::::">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_uniform4i>
		<nme_gl_uniform4iv line="1277" static="1"><f a=":">
	<t path="lime.gl.GLUniformLocation"/>
	<c path="Array"><x path="Int"/></c>
	<unknown/>
</f></nme_gl_uniform4iv>
		<nme_gl_uniform_matrix line="1278" static="1"><f a=":::">
	<t path="lime.gl.GLUniformLocation"/>
	<x path="Bool"/>
	<t path="lime.utils.ByteArray"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_uniform_matrix>
		<nme_gl_use_program line="1279" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></nme_gl_use_program>
		<nme_gl_validate_program line="1280" static="1"><f a="">
	<d/>
	<unknown/>
</f></nme_gl_validate_program>
		<nme_gl_version line="1281" static="1"><f a=""><x path="Int"/></f></nme_gl_version>
		<nme_gl_vertex_attrib1f line="1282" static="1"><f a=":">
	<x path="Int"/>
	<x path="Float"/>
	<unknown/>
</f></nme_gl_vertex_attrib1f>
		<nme_gl_vertex_attrib1fv line="1283" static="1"><f a=":">
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
	<unknown/>
</f></nme_gl_vertex_attrib1fv>
		<nme_gl_vertex_attrib2f line="1284" static="1"><f a="::">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></nme_gl_vertex_attrib2f>
		<nme_gl_vertex_attrib2fv line="1285" static="1"><f a=":">
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
	<unknown/>
</f></nme_gl_vertex_attrib2fv>
		<nme_gl_vertex_attrib3f line="1286" static="1"><f a=":::">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></nme_gl_vertex_attrib3f>
		<nme_gl_vertex_attrib3fv line="1287" static="1"><f a=":">
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
	<unknown/>
</f></nme_gl_vertex_attrib3fv>
		<nme_gl_vertex_attrib4f line="1288" static="1"><f a="::::">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<unknown/>
</f></nme_gl_vertex_attrib4f>
		<nme_gl_vertex_attrib4fv line="1289" static="1"><f a=":">
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
	<unknown/>
</f></nme_gl_vertex_attrib4fv>
		<nme_gl_vertex_attrib_pointer line="1290" static="1"><f a=":::::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_vertex_attrib_pointer>
		<nme_gl_viewport line="1291" static="1"><f a=":::">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></nme_gl_viewport>
	</class>
	<typedef path="lime.gl.native.ShaderPrecisionFormat" params="" file="/Users/Sven/dev/lab/lime/lime/gl/native/GL.hx" module="lime.gl.native.GL"><a>
	<rangeMin><x path="Int"/></rangeMin>
	<rangeMax><x path="Int"/></rangeMax>
	<precision><x path="Int"/></precision>
</a></typedef>
	<typedef path="lime.utils.ArrayBuffer" params="" file="/Users/Sven/dev/lab/lime/lime/utils/ArrayBuffer.hx"><t path="lime.utils.ByteArray"/></typedef>
	<class path="lime.utils.IMemoryRange" params="" file="/Users/Sven/dev/lab/lime/lime/utils/IMemoryRange.hx" interface="1">
		<getLength public="1" set="method"><f a=""><x path="Int"/></f></getLength>
		<getStart public="1" set="method"><f a=""><x path="Int"/></f></getStart>
		<getByteBuffer public="1" set="method"><f a=""><t path="lime.utils.ByteArray"/></f></getByteBuffer>
	</class>
	<class path="lime.utils.ArrayBufferView" params="" file="/Users/Sven/dev/lab/lime/lime/utils/ArrayBufferView.hx">
		<implements path="lime.utils.IMemoryRange"/>
		<invalidDataIndex line="22" static="1"><c path="String"/></invalidDataIndex>
		<setUInt8 public="1" get="inline" set="null" line="186"><f a="position:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setUInt8>
		<setInt32 public="1" get="inline" set="null" line="174"><f a="position:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setInt32>
		<setInt16 public="1" get="inline" set="null" line="162"><f a="position:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setInt16>
		<setFloat32 public="1" get="inline" set="null" line="150"><f a="position:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat32>
		<getUInt8 public="1" get="inline" set="null" line="138"><f a="position">
	<x path="Int"/>
	<x path="Int"/>
</f></getUInt8>
		<getStart public="1" set="method" line="131"><f a=""><x path="Int"/></f></getStart>
		<getLength public="1" set="method" line="124"><f a=""><x path="Int"/></f></getLength>
		<getInt32 public="1" get="inline" set="null" line="112"><f a="position">
	<x path="Int"/>
	<x path="Int"/>
</f></getInt32>
		<getInt16 public="1" get="inline" set="null" line="100"><f a="position">
	<x path="Int"/>
	<x path="Int"/>
</f></getInt16>
		<getFloat32 public="1" get="inline" set="null" line="88"><f a="position">
	<x path="Int"/>
	<x path="Float"/>
</f></getFloat32>
		<getByteBuffer public="1" set="method" line="81"><f a=""><t path="lime.utils.ByteArray"/></f></getByteBuffer>
		<bytes><t path="haxe.io.BytesData"/></bytes>
		<byteLength public="1" set="null"><x path="Int"/></byteLength>
		<byteOffset public="1" set="null"><x path="Int"/></byteOffset>
		<buffer public="1" set="null"><t path="lime.utils.ByteArray"/></buffer>
		<new set="method" line="28"><f a="lengthOrBuffer:?byteOffset:?length">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.utils.Assets" params="" file="/Users/Sven/dev/lab/lime/lime/utils/Assets.hx">
		<initialized line="39" static="1"><x path="Bool"/></initialized>
		<id public="1" get="accessor" set="null" static="1"><c path="Array"><c path="String"/></c></id>
		<library public="1" get="accessor" set="null" static="1"><x path="Map">
	<c path="String"/>
	<e path="lime.utils.LibraryType"/>
</x></library>
		<path public="1" get="accessor" set="null" static="1"><x path="Map">
	<c path="String"/>
	<c path="String"/>
</x></path>
		<type public="1" get="accessor" set="null" static="1"><x path="Map">
	<c path="String"/>
	<e path="lime.utils.AssetType"/>
</x></type>
		<initialize set="method" line="48" static="1"><f a=""><x path="Void"/></f></initialize>
		<getBytes public="1" set="method" line="68" static="1">
			<f a="id">
				<c path="String"/>
				<t path="lime.utils.ByteArray"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded binary asset
		 * @usage		var bytes = Assets.getBytes("file.zip");
		 * @param	id		The ID or asset path for the file
		 * @return		A new ByteArray object</haxe_doc>
		</getBytes>
		<getText public="1" set="method" line="123" static="1">
			<f a="id">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded text asset
		 * @usage		var text = Assets.getText("text.txt");
		 * @param	id		The ID or asset path for the file
		 * @return		A new String object</haxe_doc>
		</getText>
		<get_id set="method" line="168" static="1"><f a=""><c path="Array"><c path="String"/></c></f></get_id>
		<get_library set="method" line="184" static="1"><f a=""><x path="Map">
	<c path="String"/>
	<e path="lime.utils.LibraryType"/>
</x></f></get_library>
		<get_path set="method" line="197" static="1"><f a=""><x path="Map">
	<c path="String"/>
	<c path="String"/>
</x></f></get_path>
		<get_type set="method" line="210" static="1"><f a=""><x path="Map">
	<c path="String"/>
	<e path="lime.utils.AssetType"/>
</x></f></get_type>
		<haxe_doc><![CDATA[* <p>The Assets class provides a cross-platform interface to access 
	 * embedded images, fonts, sounds and other resource files.</p>
	 * 
	 * <p>The contents are populated automatically when an application
	 * is compiled using the NME command-line tools, based on the
	 * contents of the *.nmml project file.</p>
	 * 
	 * <p>For most platforms, the assets are included in the same directory
	 * or package as the application, and the paths are handled
	 * automatically. For web content, the assets are preloaded before
	 * the start of the rest of the application. You can customize the 
	 * preloader by extending the <code>NMEPreloader</code> class,
	 * and specifying a custom preloader using <window preloader="" />
	 * in the project file.</p>]]></haxe_doc>
	</class>
	<enum path="lime.utils.AssetType" params="" file="/Users/Sven/dev/lab/lime/lime/utils/Assets.hx" module="lime.utils.Assets">
		<TEXT/>
		<BINARY/>
	</enum>
	<enum path="lime.utils.LibraryType" params="" file="/Users/Sven/dev/lab/lime/lime/utils/Assets.hx" module="lime.utils.Assets"><SWF/></enum>
	<typedef path="lime.utils.ByteArray" params="" file="/Users/Sven/dev/lab/lime/lime/utils/ByteArray.hx"><c path="lime.utils.native.ByteArray"/></typedef>
	<enum path="lime.utils.CompressionAlgorithm" params="" file="/Users/Sven/dev/lab/lime/lime/utils/CompressionAlgorithm.hx">
		<ZLIB/>
		<LZMA/>
		<GZIP/>
		<DEFLATE/>
	</enum>
	<class path="lime.utils.Endian" params="" file="/Users/Sven/dev/lab/lime/lime/utils/Endian.hx">
		<BIG_ENDIAN public="1" get="inline" set="null" line="6" static="1"><c path="String"/></BIG_ENDIAN>
		<LITTLE_ENDIAN public="1" get="inline" set="null" line="7" static="1"><c path="String"/></LITTLE_ENDIAN>
	</class>
	<class path="lime.utils.Float32Array" params="" file="/Users/Sven/dev/lab/lime/lime/utils/Float32Array.hx">
		<extends path="lime.utils.ArrayBufferView"/>
		<SBYTES_PER_ELEMENT public="1" get="inline" set="null" line="14" static="1"><x path="Int"/></SBYTES_PER_ELEMENT>
		<fromMatrix public="1" set="method" line="78" static="1"><f a="matrix">
	<c path="lime.geometry.Matrix3D"/>
	<c path="lime.utils.Float32Array"/>
</f></fromMatrix>
		<__set public="1" get="inline" set="null" line="83">
			<f a="index:value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":keep"/>
			</meta>
		</__set>
		<__get public="1" get="inline" set="null" line="82">
			<f a="index">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":keep"/>
			</meta>
		</__get>
		<length public="1" set="null"><x path="Int"/></length>
		<BYTES_PER_ELEMENT public="1" set="null"><x path="Int"/></BYTES_PER_ELEMENT>
		<new public="1" set="method" line="19"><f a="bufferOrArray:?start:?length">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.utils.Gamepad" params="" file="/Users/Sven/dev/lab/lime/lime/utils/Gamepad.hx">
		<apply_360_profile public="1" set="method" line="61"><f a=""><x path="Void"/></f></apply_360_profile>
		<set_profile public="1" set="method" line="45"><f a="buttons:axis:hats">
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></set_profile>
		<hat7 public="1"><x path="Int"/></hat7>
		<hat6 public="1"><x path="Int"/></hat6>
		<hat5 public="1"><x path="Int"/></hat5>
		<hat4 public="1"><x path="Int"/></hat4>
		<hat3 public="1"><x path="Int"/></hat3>
		<hat2 public="1"><x path="Int"/></hat2>
		<hat1 public="1"><x path="Int"/></hat1>
		<hat0 public="1"><x path="Int"/></hat0>
		<axis7 public="1"><x path="Int"/></axis7>
		<axis6 public="1"><x path="Int"/></axis6>
		<axis5 public="1"><x path="Int"/></axis5>
		<axis4 public="1"><x path="Int"/></axis4>
		<axis3 public="1"><x path="Int"/></axis3>
		<axis2 public="1"><x path="Int"/></axis2>
		<axis1 public="1"><x path="Int"/></axis1>
		<axis0 public="1"><x path="Int"/></axis0>
		<button15 public="1"><x path="Int"/></button15>
		<button14 public="1"><x path="Int"/></button14>
		<button13 public="1"><x path="Int"/></button13>
		<button12 public="1"><x path="Int"/></button12>
		<button11 public="1"><x path="Int"/></button11>
		<button10 public="1"><x path="Int"/></button10>
		<button9 public="1"><x path="Int"/></button9>
		<button8 public="1"><x path="Int"/></button8>
		<button7 public="1"><x path="Int"/></button7>
		<button6 public="1"><x path="Int"/></button6>
		<button5 public="1"><x path="Int"/></button5>
		<button4 public="1"><x path="Int"/></button4>
		<button3 public="1"><x path="Int"/></button3>
		<button2 public="1"><x path="Int"/></button2>
		<button1 public="1"><x path="Int"/></button1>
		<button0 public="1"><x path="Int"/></button0>
		<max_hats public="1"><x path="Int"/></max_hats>
		<max_axis public="1"><x path="Int"/></max_axis>
		<max_buttons public="1"><x path="Int"/></max_buttons>
		<new public="1" set="method" line="44"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="lime.utils.IDataInput" params="" file="/Users/Sven/dev/lab/lime/lime/utils/IDataInput.hx" interface="1">
		<set_endian set="method"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></set_endian>
		<get_endian set="method"><f a=""><c path="String"/></f></get_endian>
		<get_bytesAvailable set="method"><f a=""><x path="Int"/></f></get_bytesAvailable>
		<readUTFBytes public="1" set="method"><f a="inLen">
	<x path="Int"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readUnsignedShort public="1" set="method"><f a=""><x path="Int"/></f></readUnsignedShort>
		<readUnsignedInt public="1" set="method"><f a=""><x path="Int"/></f></readUnsignedInt>
		<readUnsignedByte public="1" set="method"><f a=""><x path="Int"/></f></readUnsignedByte>
		<readShort public="1" set="method"><f a=""><x path="Int"/></f></readShort>
		<readInt public="1" set="method"><f a=""><x path="Int"/></f></readInt>
		<readFloat public="1" set="method"><f a=""><x path="Float"/></f></readFloat>
		<readDouble public="1" set="method"><f a=""><x path="Float"/></f></readDouble>
		<readBytes public="1" set="method"><f a="outData:?inOffset:?inLen">
	<t path="lime.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></readBytes>
		<readByte public="1" set="method"><f a=""><x path="Int"/></f></readByte>
		<readBoolean public="1" set="method"><f a=""><x path="Bool"/></f></readBoolean>
		<endian public="1" get="accessor" set="accessor"><c path="String"/></endian>
		<bytesAvailable public="1" get="accessor" set="null"><x path="Int"/></bytesAvailable>
	</class>
	<enum path="lime.utils.KeyValue" params="" file="/Users/Sven/dev/lab/lime/lime/utils/Keys.hx" module="lime.utils.Keys">
		<up/>
		<unknown/>
		<tilde/>
		<tab/>
		<space/>
		<shift/>
		<right/>
		<minus/>
		<meta/>
		<leftctrl/>
		<leftalt/>
		<left/>
		<key_Z/>
		<key_Y/>
		<key_X/>
		<key_W/>
		<key_V/>
		<key_U/>
		<key_T/>
		<key_S/>
		<key_R/>
		<key_Q/>
		<key_P/>
		<key_O/>
		<key_N/>
		<key_M/>
		<key_L/>
		<key_K/>
		<key_J/>
		<key_I/>
		<key_H/>
		<key_G/>
		<key_F/>
		<key_E/>
		<key_D/>
		<key_C/>
		<key_B/>
		<key_A/>
		<key_9/>
		<key_8/>
		<key_7/>
		<key_6/>
		<key_5/>
		<key_4/>
		<key_3/>
		<key_2/>
		<key_1/>
		<key_0/>
		<escape/>
		<equals/>
		<enter/>
		<down/>
		<capslock/>
		<backspace/>
	</enum>
	<class path="lime.utils.Keys" params="" file="/Users/Sven/dev/lab/lime/lime/utils/Keys.hx">
		<_backspace get="inline" set="null" line="66" static="1"><x path="Int"/></_backspace>
		<_tab get="inline" set="null" line="67" static="1"><x path="Int"/></_tab>
		<_enter get="inline" set="null" line="68" static="1"><x path="Int"/></_enter>
		<_meta get="inline" set="null" line="69" static="1"><x path="Int"/></_meta>
		<_shift get="inline" set="null" line="70" static="1"><x path="Int"/></_shift>
		<_leftctrl get="inline" set="null" line="71" static="1"><x path="Int"/></_leftctrl>
		<_leftalt get="inline" set="null" line="72" static="1"><x path="Int"/></_leftalt>
		<_capslock get="inline" set="null" line="73" static="1"><x path="Int"/></_capslock>
		<_escape get="inline" set="null" line="74" static="1"><x path="Int"/></_escape>
		<_space get="inline" set="null" line="75" static="1"><x path="Int"/></_space>
		<_left get="inline" set="null" line="77" static="1"><x path="Int"/></_left>
		<_up get="inline" set="null" line="78" static="1"><x path="Int"/></_up>
		<_right get="inline" set="null" line="79" static="1"><x path="Int"/></_right>
		<_down get="inline" set="null" line="80" static="1"><x path="Int"/></_down>
		<_key_0 get="inline" set="null" line="82" static="1"><x path="Int"/></_key_0>
		<_key_1 get="inline" set="null" line="83" static="1"><x path="Int"/></_key_1>
		<_key_2 get="inline" set="null" line="84" static="1"><x path="Int"/></_key_2>
		<_key_3 get="inline" set="null" line="85" static="1"><x path="Int"/></_key_3>
		<_key_4 get="inline" set="null" line="86" static="1"><x path="Int"/></_key_4>
		<_key_5 get="inline" set="null" line="87" static="1"><x path="Int"/></_key_5>
		<_key_6 get="inline" set="null" line="88" static="1"><x path="Int"/></_key_6>
		<_key_7 get="inline" set="null" line="89" static="1"><x path="Int"/></_key_7>
		<_key_8 get="inline" set="null" line="90" static="1"><x path="Int"/></_key_8>
		<_key_9 get="inline" set="null" line="91" static="1"><x path="Int"/></_key_9>
		<_key_A get="inline" set="null" line="93" static="1"><x path="Int"/></_key_A>
		<_key_B get="inline" set="null" line="94" static="1"><x path="Int"/></_key_B>
		<_key_C get="inline" set="null" line="95" static="1"><x path="Int"/></_key_C>
		<_key_D get="inline" set="null" line="96" static="1"><x path="Int"/></_key_D>
		<_key_E get="inline" set="null" line="97" static="1"><x path="Int"/></_key_E>
		<_key_F get="inline" set="null" line="98" static="1"><x path="Int"/></_key_F>
		<_key_G get="inline" set="null" line="99" static="1"><x path="Int"/></_key_G>
		<_key_H get="inline" set="null" line="100" static="1"><x path="Int"/></_key_H>
		<_key_I get="inline" set="null" line="101" static="1"><x path="Int"/></_key_I>
		<_key_J get="inline" set="null" line="102" static="1"><x path="Int"/></_key_J>
		<_key_K get="inline" set="null" line="103" static="1"><x path="Int"/></_key_K>
		<_key_L get="inline" set="null" line="104" static="1"><x path="Int"/></_key_L>
		<_key_M get="inline" set="null" line="105" static="1"><x path="Int"/></_key_M>
		<_key_N get="inline" set="null" line="106" static="1"><x path="Int"/></_key_N>
		<_key_O get="inline" set="null" line="107" static="1"><x path="Int"/></_key_O>
		<_key_P get="inline" set="null" line="108" static="1"><x path="Int"/></_key_P>
		<_key_Q get="inline" set="null" line="109" static="1"><x path="Int"/></_key_Q>
		<_key_R get="inline" set="null" line="110" static="1"><x path="Int"/></_key_R>
		<_key_S get="inline" set="null" line="111" static="1"><x path="Int"/></_key_S>
		<_key_T get="inline" set="null" line="112" static="1"><x path="Int"/></_key_T>
		<_key_U get="inline" set="null" line="113" static="1"><x path="Int"/></_key_U>
		<_key_V get="inline" set="null" line="114" static="1"><x path="Int"/></_key_V>
		<_key_W get="inline" set="null" line="115" static="1"><x path="Int"/></_key_W>
		<_key_X get="inline" set="null" line="116" static="1"><x path="Int"/></_key_X>
		<_key_Y get="inline" set="null" line="117" static="1"><x path="Int"/></_key_Y>
		<_key_Z get="inline" set="null" line="118" static="1"><x path="Int"/></_key_Z>
		<_equals get="inline" set="null" line="120" static="1"><x path="Int"/></_equals>
		<_minus get="inline" set="null" line="121" static="1"><x path="Int"/></_minus>
		<_tilde get="inline" set="null" line="122" static="1"><x path="Int"/></_tilde>
		<toKeyValue public="1" set="method" line="182" static="1"><f a="_value">
	<x path="Int"/>
	<e path="lime.utils.KeyValue"/>
</f></toKeyValue>
		<tilde public="1"><x path="Int"/></tilde>
		<minus public="1"><x path="Int"/></minus>
		<equals public="1"><x path="Int"/></equals>
		<key_Z public="1"><x path="Int"/></key_Z>
		<key_Y public="1"><x path="Int"/></key_Y>
		<key_X public="1"><x path="Int"/></key_X>
		<key_W public="1"><x path="Int"/></key_W>
		<key_V public="1"><x path="Int"/></key_V>
		<key_U public="1"><x path="Int"/></key_U>
		<key_T public="1"><x path="Int"/></key_T>
		<key_S public="1"><x path="Int"/></key_S>
		<key_R public="1"><x path="Int"/></key_R>
		<key_Q public="1"><x path="Int"/></key_Q>
		<key_P public="1"><x path="Int"/></key_P>
		<key_O public="1"><x path="Int"/></key_O>
		<key_N public="1"><x path="Int"/></key_N>
		<key_M public="1"><x path="Int"/></key_M>
		<key_L public="1"><x path="Int"/></key_L>
		<key_K public="1"><x path="Int"/></key_K>
		<key_J public="1"><x path="Int"/></key_J>
		<key_I public="1"><x path="Int"/></key_I>
		<key_H public="1"><x path="Int"/></key_H>
		<key_G public="1"><x path="Int"/></key_G>
		<key_F public="1"><x path="Int"/></key_F>
		<key_E public="1"><x path="Int"/></key_E>
		<key_D public="1"><x path="Int"/></key_D>
		<key_C public="1"><x path="Int"/></key_C>
		<key_B public="1"><x path="Int"/></key_B>
		<key_A public="1"><x path="Int"/></key_A>
		<key_9 public="1"><x path="Int"/></key_9>
		<key_8 public="1"><x path="Int"/></key_8>
		<key_7 public="1"><x path="Int"/></key_7>
		<key_6 public="1"><x path="Int"/></key_6>
		<key_5 public="1"><x path="Int"/></key_5>
		<key_4 public="1"><x path="Int"/></key_4>
		<key_3 public="1"><x path="Int"/></key_3>
		<key_2 public="1"><x path="Int"/></key_2>
		<key_1 public="1"><x path="Int"/></key_1>
		<key_0 public="1"><x path="Int"/></key_0>
		<down public="1"><x path="Int"/></down>
		<right public="1"><x path="Int"/></right>
		<up public="1"><x path="Int"/></up>
		<left public="1"><x path="Int"/></left>
		<space public="1"><x path="Int"/></space>
		<escape public="1"><x path="Int"/></escape>
		<capslock public="1"><x path="Int"/></capslock>
		<leftalt public="1"><x path="Int"/></leftalt>
		<leftctrl public="1"><x path="Int"/></leftctrl>
		<shift public="1"><x path="Int"/></shift>
		<meta public="1"><x path="Int"/></meta>
		<enter public="1"><x path="Int"/></enter>
		<tab public="1"><x path="Int"/></tab>
		<new public="1" set="method" line="181"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="lime.utils.UInt8Array" params="" file="/Users/Sven/dev/lab/lime/lime/utils/UInt8Array.hx">
		<extends path="lime.utils.ArrayBufferView"/>
		<SBYTES_PER_ELEMENT public="1" get="inline" set="null" line="12" static="1"><x path="Int"/></SBYTES_PER_ELEMENT>
		<__set public="1" get="inline" set="null" line="67">
			<f a="index:value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":keep"/>
			</meta>
		</__set>
		<__get public="1" get="inline" set="null" line="66">
			<f a="index">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":keep"/>
			</meta>
		</__get>
		<length public="1" set="null"><x path="Int"/></length>
		<BYTES_PER_ELEMENT public="1" set="null"><x path="Int"/></BYTES_PER_ELEMENT>
		<new public="1" set="method" line="18"><f a="bufferOrArray:?start:?length">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<abstract path="lime.utils.Vector" params="T" file="/Users/Sven/dev/lab/lime/lime/utils/Vector.hx">
		<from><c path="Array"><c path="fromArray.U"/></c></from>
		<to><c path="Array"><c path="toArray.T"/></c></to>
		<meta><m n=":arrayAccess"/></meta>
	</abstract>
	<class path="lime.utils._Vector.Vector_Impl_" params="" file="/Users/Sven/dev/lab/lime/lime/utils/Vector.hx" private="1" module="lime.utils.Vector">
		<length public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<fixed public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</fixed>
		<_new public="1" set="method" line="11" static="1">
			<f a="?length:?fixed">
				<x path="Int"/>
				<x path="Bool"/>
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<concat public="1" set="method" line="18" static="1">
			<f a="this:?a">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<x path="lime.utils.Vector"><c path="lime.utils.Vector.T"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</concat>
		<copy public="1" set="method" line="25" static="1">
			<f a="this">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<x path="lime.utils.Vector"><c path="lime.utils.Vector.T"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</copy>
		<iterator public="1" params="T" set="method" line="32" static="1">
			<f a="this">
				<c path="Array"><c path="iterator.T"/></c>
				<t path="Iterator"><c path="iterator.T"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</iterator>
		<join public="1" set="method" line="39" static="1">
			<f a="this:sep">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</join>
		<pop public="1" set="method" line="46" static="1">
			<f a="this">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<t path="Null"><c path="lime.utils.Vector.T"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</pop>
		<push public="1" set="method" line="53" static="1">
			<f a="this:x">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<c path="lime.utils.Vector.T"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</push>
		<reverse public="1" set="method" line="60" static="1">
			<f a="this">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</reverse>
		<shift public="1" set="method" line="67" static="1">
			<f a="this">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<t path="Null"><c path="lime.utils.Vector.T"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</shift>
		<unshift public="1" set="method" line="74" static="1">
			<f a="this:x">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<c path="lime.utils.Vector.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</unshift>
		<slice public="1" set="method" line="81" static="1">
			<f a="this:?pos:?end">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Vector"><c path="lime.utils.Vector.T"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</slice>
		<sort public="1" set="method" line="88" static="1">
			<f a="this:f">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<f a=":">
					<c path="lime.utils.Vector.T"/>
					<c path="lime.utils.Vector.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</sort>
		<splice public="1" set="method" line="95" static="1">
			<f a="this:pos:len">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Vector"><c path="lime.utils.Vector.T"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</splice>
		<toString public="1" set="method" line="102" static="1">
			<f a="this">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<indexOf public="1" set="method" line="109" static="1">
			<f a="this:x:?from">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<c path="lime.utils.Vector.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</indexOf>
		<lastIndexOf public="1" set="method" line="126" static="1">
			<f a="this:x:?from">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<c path="lime.utils.Vector.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</lastIndexOf>
		<ofArray public="1" params="T" get="inline" set="null" line="142" static="1"><f a="a">
	<c path="Array"><d/></c>
	<x path="lime.utils.Vector"><c path="ofArray.T"/></x>
</f></ofArray>
		<convert public="1" params="T:U" get="inline" set="null" line="149" static="1"><f a="v">
	<c path="Array"><c path="convert.T"/></c>
	<x path="lime.utils.Vector"><c path="convert.U"/></x>
</f></convert>
		<fromArray public="1" params="T:U" get="inline" set="null" line="156" static="1">
			<f a="a">
				<c path="Array"><c path="fromArray.U"/></c>
				<x path="lime.utils.Vector"><c path="fromArray.T"/></x>
			</f>
			<meta><m n=":from"/></meta>
		</fromArray>
		<toArray public="1" params="T" get="inline" set="null" line="163" static="1">
			<f a="this">
				<c path="Array"><c path="toArray.T"/></c>
				<c path="Array"><c path="toArray.T"/></c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toArray>
		<get_length set="method" line="177" static="1">
			<f a="this">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<set_length set="method" line="184" static="1">
			<f a="this:value">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_length>
		<get_fixed set="method" line="191" static="1">
			<f a="this">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_fixed>
		<set_fixed set="method" line="198" static="1">
			<f a="this:value">
				<c path="Array"><c path="lime.utils.Vector.T"/></c>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_fixed>
	</class>
	<class path="lime.utils.native.ByteArray" params="" file="/Users/Sven/dev/lab/lime/lime/utils/native/ByteArray.hx">
		<extends path="haxe.io.Bytes"/>
		<implements path="lime.utils.IMemoryRange"/>
		<implements path="lime.utils.IDataInput"/>
		<fromBytes public="1" set="method" line="191" static="1"><f a="inBytes">
	<c path="haxe.io.Bytes"/>
	<c path="lime.utils.native.ByteArray"/>
</f></fromBytes>
		<readFile public="1" set="method" line="281" static="1"><f a="inString">
	<c path="String"/>
	<c path="lime.utils.native.ByteArray"/>
</f></readFile>
		<_double_bytes line="620" static="1">
			<f a=":">
				<x path="Float"/>
				<x path="Bool"/>
				<t path="haxe.io.BytesData"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</_double_bytes>
		<_double_of_bytes line="621" static="1">
			<f a=":">
				<t path="haxe.io.BytesData"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</_double_of_bytes>
		<_float_bytes line="622" static="1">
			<f a=":">
				<x path="Float"/>
				<x path="Bool"/>
				<t path="haxe.io.BytesData"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</_float_bytes>
		<_float_of_bytes line="623" static="1">
			<f a=":">
				<t path="haxe.io.BytesData"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</_float_of_bytes>
		<nme_byte_array_overwrite_file line="625" static="1"><f a=":">
	<c path="String"/>
	<c path="lime.utils.native.ByteArray"/>
	<unknown/>
</f></nme_byte_array_overwrite_file>
		<nme_byte_array_read_file line="626" static="1"><f a="">
	<c path="String"/>
	<c path="lime.utils.native.ByteArray"/>
</f></nme_byte_array_read_file>
		<nme_lzma_encode line="628" static="1"><f a="">
	<unknown/>
	<t path="haxe.io.BytesData"/>
</f></nme_lzma_encode>
		<nme_lzma_decode line="629" static="1"><f a="">
	<t path="haxe.io.BytesData"/>
	<t path="haxe.io.BytesData"/>
</f></nme_lzma_decode>
		<set_endian set="method" line="617"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></set_endian>
		<get_endian set="method" line="616"><f a=""><c path="String"/></f></get_endian>
		<get_byteLength set="method" line="615"><f a=""><x path="Int"/></f></get_byteLength>
		<get_bytesAvailable set="method" line="614"><f a=""><x path="Int"/></f></get_bytesAvailable>
		<writeUTFBytes public="1" set="method" line="602"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTFBytes>
		<writeUTF public="1" set="method" line="590"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTF>
		<writeUnsignedInt public="1" set="method" line="585"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeUnsignedInt>
		<writeShort public="1" set="method" line="569"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeShort>
		<writeInt public="1" set="method" line="547"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt>
		<writeFloat public="1" set="method" line="532"><f a="x">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeFile public="1" set="method" line="526"><f a="inString">
	<c path="String"/>
	<x path="Void"/>
</f></writeFile>
		<writeDouble public="1" set="method" line="510"><f a="x">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeBytes public="1" set="method" line="501"><f a="bytes:?inOffset:?inLength">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></writeBytes>
		<writeByte public="1" get="inline" set="null" line="490"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBoolean public="1" set="method" line="485"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></writeBoolean>
		<write_uncheck get="inline" set="null" line="477">
			<f a="inByte">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</write_uncheck>
		<uncompress public="1" set="method" line="435"><f a="?algorithm">
	<e path="lime.utils.CompressionAlgorithm"/>
	<x path="Void"/>
</f></uncompress>
		<ThrowEOFi set="method" line="427">
			<f a=""><x path="Int"/></f>
			<haxe_doc>@private</haxe_doc>
		</ThrowEOFi>
		<slice public="1" set="method" line="395"><f a="inBegin:?inEnd">
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.native.ByteArray"/>
</f></slice>
		<setLength public="1" set="method" line="387"><f a="inLength">
	<x path="Int"/>
	<x path="Void"/>
</f></setLength>
		<readUTFBytes public="1" set="method" line="363"><f a="inLen">
	<x path="Int"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUTF public="1" set="method" line="357"><f a=""><c path="String"/></f></readUTF>
		<readUnsignedShort public="1" set="method" line="349"><f a=""><x path="Int"/></f></readUnsignedShort>
		<readUnsignedInt public="1" set="method" line="339"><f a=""><x path="Int"/></f></readUnsignedInt>
		<readUnsignedByte public="1" get="inline" set="null" line="334"><f a=""><x path="Int"/></f></readUnsignedByte>
		<readShort public="1" set="method" line="324"><f a=""><x path="Int"/></f></readShort>
		<readMultiByte public="1" get="inline" set="null" line="318"><f a="inLen:charSet">
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readInt public="1" set="method" line="308"><f a=""><x path="Int"/></f></readInt>
		<readFloat public="1" set="method" line="287"><f a=""><x path="Float"/></f></readFloat>
		<readDouble public="1" set="method" line="259"><f a=""><x path="Float"/></f></readDouble>
		<readBytes public="1" set="method" line="235"><f a="outData:?inOffset:?inLen">
	<c path="lime.utils.native.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></readBytes>
		<readByte public="1" get="inline" set="null" line="229"><f a=""><x path="Int"/></f></readByte>
		<readBoolean public="1" get="inline" set="null" line="224"><f a=""><x path="Bool"/></f></readBoolean>
		<nmeFromBytes get="inline" set="null" line="214"><f a="inBytes">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></nmeFromBytes>
		<inflate public="1" set="method" line="206"><f a=""><x path="Void"/></f></inflate>
		<getStart public="1" set="method" line="202"><f a=""><x path="Int"/></f></getStart>
		<getByteBuffer public="1" set="method" line="201"><f a=""><c path="lime.utils.native.ByteArray"/></f></getByteBuffer>
		<getLength public="1" set="method" line="198"><f a=""><x path="Int"/></f></getLength>
		<ensureElem set="method" line="171">
			<f a="inSize:inUpdateLenght">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</ensureElem>
		<deflate public="1" set="method" line="164"><f a=""><x path="Void"/></f></deflate>
		<compress public="1" set="method" line="126"><f a="?algorithm">
	<e path="lime.utils.CompressionAlgorithm"/>
	<x path="Void"/>
</f></compress>
		<clear public="1" set="method" line="117"><f a=""><x path="Void"/></f></clear>
		<checkData public="1" set="method" line="111"><f a="inLength">
	<x path="Int"/>
	<x path="Void"/>
</f></checkData>
		<asString public="1" set="method" line="106"><f a=""><c path="String"/></f></asString>
		<__set public="1" get="inline" set="null" line="96">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
		</__set>
		<__get public="1" get="inline" set="null" line="63">
			<f a="pos">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":keep"/></meta>
		</__get>
		<byteLength public="1" get="accessor" set="null"><x path="Int"/></byteLength>
		<position public="1"><x path="Int"/></position>
		<endian public="1" get="accessor" set="accessor"><c path="String"/></endian>
		<bytesAvailable public="1" get="accessor" set="null"><x path="Int"/></bytesAvailable>
		<bigEndian public="1"><x path="Bool"/></bigEndian>
		<new public="1" set="method" line="42"><f a="?inSize">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.Audio" params="" file="/Users/Sven/dev/lab/luxe/luxe/Audio.hx">
		<process public="1" set="method" line="50"><f a=""><x path="Void"/></f></process>
		<pan public="1" set="method" line="41"><f a="_name:_p">
	<c path="String"/>
	<x path="Float"/>
	<x path="Void"/>
</f></pan>
		<volume public="1" set="method" line="32"><f a="_name:_v">
	<c path="String"/>
	<x path="Float"/>
	<x path="Void"/>
</f></volume>
		<play public="1" set="method" line="23"><f a="_name">
	<c path="String"/>
	<x path="Void"/>
</f></play>
		<create public="1" set="method" line="19"><f a="_name:_file:?_forcemusic">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></create>
		<shutdown public="1" set="method" line="15"><f a=""><x path="Void"/></f></shutdown>
		<startup public="1" set="method" line="10"><f a=""><x path="Void"/></f></startup>
		<core public="1"><c path="luxe.Core"/></core>
		<new public="1" set="method" line="8"><f a="_core">
	<c path="luxe.Core"/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="luxe.ProjectionType" params="" file="/Users/Sven/dev/lab/luxe/luxe/Camera.hx" module="luxe.Camera"><e path="phoenix.ProjectionType"/></typedef>
	<class path="luxe.Entity" params="" file="/Users/Sven/dev/lab/luxe/luxe/Entity.hx">
		<extends path="luxe.Objects"/>
		<_attach_listener set="method" line="563"><f a="_v:listener">
	<t path="luxe.Vector"/>
	<f a="">
		<x path="Float"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></_attach_listener>
		<_rotation_change set="method" line="559"><f a="_v">
	<x path="Float"/>
	<x path="Void"/>
</f></_rotation_change>
		<_scale_change set="method" line="554"><f a="_v">
	<x path="Float"/>
	<x path="Void"/>
</f></_scale_change>
		<_pos_change set="method" line="552"><f a="_v">
	<x path="Float"/>
	<x path="Void"/>
</f></_pos_change>
		<get_parent set="method" line="547"><f a=""><c path="luxe.Entity"/></f></get_parent>
		<get_scaleRelative set="method" line="545"><f a=""><t path="luxe.Vector"/></f></get_scaleRelative>
		<get_rotationRelative set="method" line="544"><f a=""><t path="luxe.Vector"/></f></get_rotationRelative>
		<get_posRelative set="method" line="543"><f a=""><t path="luxe.Vector"/></f></get_posRelative>
		<set_scene set="method" line="541"><f a="_scene">
	<c path="luxe.Scene"/>
	<c path="luxe.Scene"/>
</f></set_scene>
		<get_scene set="method" line="540"><f a=""><c path="luxe.Scene"/></f></get_scene>
		<get_scale set="method" line="538"><f a=""><t path="luxe.Vector"/></f></get_scale>
		<get_rotation set="method" line="537"><f a=""><t path="luxe.Vector"/></f></get_rotation>
		<get_pos set="method" line="536"><f a=""><t path="luxe.Vector"/></f></get_pos>
		<set_parent set="method" line="506"><f a="other">
	<c path="luxe.Entity"/>
	<c path="luxe.Entity"/>
</f></set_parent>
		<internal_parent_scale_changed public="1" set="method" line="500"><f a="_parent_scale">
	<t path="luxe.Vector"/>
	<x path="Void"/>
</f></internal_parent_scale_changed>
		<internal_parent_rotation_changed public="1" set="method" line="494"><f a="_parent_rotation">
	<t path="luxe.Vector"/>
	<x path="Void"/>
</f></internal_parent_rotation_changed>
		<internal_parent_pos_changed public="1" set="method" line="488"><f a="_parent_pos">
	<t path="luxe.Vector"/>
	<x path="Void"/>
</f></internal_parent_pos_changed>
		<set_scale set="method" line="460"><f a="_s">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_scale>
		<set_rotation set="method" line="433"><f a="_r">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_rotation>
		<set_pos set="method" line="408"><f a="_p">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_pos>
		<set_scaleRelative set="method" line="388"><f a="_s">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_scaleRelative>
		<set_rotationRelative set="method" line="368"><f a="_r">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_rotationRelative>
		<set_posRelative set="method" line="348"><f a="_p">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_posRelative>
		<remove_child public="1" set="method" line="342"><f a="child">
	<c path="luxe.Entity"/>
	<x path="Void"/>
</f></remove_child>
		<add_child public="1" set="method" line="336"><f a="child">
	<c path="luxe.Entity"/>
	<x path="Void"/>
</f></add_child>
		<get_components set="method" line="332"><f a=""><x path="Map">
	<c path="String"/>
	<c path="luxe.components.Component"/>
</x></f></get_components>
		<has public="1" set="method" line="328"><f a="_name">
	<c path="String"/>
	<x path="Bool"/>
</f></has>
		<get public="1" set="method" line="324"><f a="_name:?_in_children:?_first_only">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<d/>
</f></get>
		<add public="1" params="T" set="method" line="320"><f a="type:?_name">
	<x path="Class"><c path="add.T"/></x>
	<c path="String"/>
	<c path="add.T"/>
</f></add>
		<_start_fixed_rate_timer set="method" line="310"><f a="_rate">
	<x path="Float"/>
	<x path="Void"/>
</f></_start_fixed_rate_timer>
		<_stop_fixed_rate_timer set="method" line="303"><f a=""><x path="Void"/></f></_stop_fixed_rate_timer>
		<set_fixed_rate set="method" line="293"><f a="_rate">
	<x path="Float"/>
	<x path="Float"/>
</f></set_fixed_rate>
		<get_fixed_rate set="method" line="289"><f a=""><x path="Float"/></f></get_fixed_rate>
		<_fixed_update public="1" set="method" line="267"><f a=""><x path="Void"/></f></_fixed_update>
		<_update public="1" set="method" line="245"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></_update>
		<_destroy public="1" set="method" line="217"><f a=""><x path="Void"/></f></_destroy>
		<_start public="1" set="method" line="195"><f a=""><x path="Void"/></f></_start>
		<_oninputup public="1" set="method" line="174"><f a="_name:e">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></_oninputup>
		<_oninputdown public="1" set="method" line="153"><f a="_name:e">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></_oninputdown>
		<_onmousemove public="1" set="method" line="132"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></_onmousemove>
		<_onmouseup public="1" set="method" line="111"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></_onmouseup>
		<_onmousedown public="1" set="method" line="90"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></_onmousedown>
		<_init public="1" set="method" line="69"><f a=""><x path="Void"/></f></_init>
		<_last_scale><t path="luxe.Vector"/></_last_scale>
		<scene public="1" get="accessor" set="accessor">
			<c path="luxe.Scene"/>
			<meta><m n=":isVar"/></meta>
		</scene>
		<scaleRelative public="1" get="accessor" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</scaleRelative>
		<scale public="1" get="accessor" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</scale>
		<rotationRelative public="1" get="accessor" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</rotationRelative>
		<rotation public="1" get="accessor" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</rotation>
		<posRelative public="1" get="accessor" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</posRelative>
		<pos public="1" get="accessor" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</pos>
		<parent public="1" get="accessor" set="accessor">
			<c path="luxe.Entity"/>
			<meta><m n=":isVar"/></meta>
		</parent>
		<_destroyed><x path="Bool"/></_destroyed>
		<fixed_rate_timer><c path="haxe.Timer"/></fixed_rate_timer>
		<fixed_rate public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</fixed_rate>
		<children public="1"><c path="Array"><c path="luxe.Entity"/></c></children>
		<events public="1"><c path="luxe.Events"/></events>
		<_components><c path="luxe.components.Components"/></_components>
		<components public="1" get="accessor" set="null"><x path="Map">
	<c path="String"/>
	<c path="luxe.components.Component"/>
</x></components>
		<new public="1" set="method" line="45"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="luxe.Camera" params="" file="/Users/Sven/dev/lab/luxe/luxe/Camera.hx">
		<extends path="luxe.Entity"/>
		<update public="1" set="method" line="74"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<shake public="1" set="method" line="69"><f a="amount">
	<x path="Float"/>
	<x path="Void"/>
</f></shake>
		<set_pos public="1" set="method" line="51" override="1">
			<f a="v">
				<t path="luxe.Vector"/>
				<t path="luxe.Vector"/>
			</f>
			<meta><m n=":nocompletion"/></meta>
		</set_pos>
		<center public="1" set="method" line="42"><f a="_p:?_t:?oncomplete">
	<t path="luxe.Vector"/>
	<x path="Float"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></center>
		<shaking public="1"><x path="Bool"/></shaking>
		<shake_amount public="1"><x path="Float"/></shake_amount>
		<shake_vector public="1"><t path="luxe.Vector"/></shake_vector>
		<bounds public="1"><t path="luxe.Rectangle"/></bounds>
		<view_position><t path="luxe.Vector"/></view_position>
		<view public="1"><c path="phoenix.Camera"/></view>
		<new public="1" set="method" line="23"><f a="?options">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="luxe.Color" params="" file="/Users/Sven/dev/lab/luxe/luxe/Color.hx"><c path="phoenix.Color"/></typedef>
	<typedef path="luxe.ColorHSV" params="" file="/Users/Sven/dev/lab/luxe/luxe/Color.hx" module="luxe.Color"><c path="phoenix.ColorHSV"/></typedef>
	<typedef path="luxe.ColorHSL" params="" file="/Users/Sven/dev/lab/luxe/luxe/Color.hx" module="luxe.Color"><c path="phoenix.ColorHSL"/></typedef>
	<class path="luxe.Core" params="" file="/Users/Sven/dev/lab/luxe/luxe/Core.hx">
		<load public="1" set="method" line="318" static="1"><f a="library:method:?args">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<d/>
</f></load>
		<_debug public="1" set="method" line="493"><f a="value:?_verbose:?_more_verbose">
	<d/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></_debug>
		<more_verbose public="1"><x path="Bool"/></more_verbose>
		<verbose public="1"><x path="Bool"/></verbose>
		<log public="1"><x path="Bool"/></log>
		<onjoybuttonup public="1" set="method" line="482"><f a="e">
	<unknown/>
	<x path="Void"/>
</f></onjoybuttonup>
		<onjoybuttondown public="1" set="method" line="479"><f a="e">
	<unknown/>
	<x path="Void"/>
</f></onjoybuttondown>
		<onjoyhatmove public="1" set="method" line="476"><f a="e">
	<unknown/>
	<x path="Void"/>
</f></onjoyhatmove>
		<onjoyballmove public="1" set="method" line="473"><f a="e">
	<unknown/>
	<x path="Void"/>
</f></onjoyballmove>
		<onjoyaxismove public="1" set="method" line="470"><f a="e">
	<unknown/>
	<x path="Void"/>
</f></onjoyaxismove>
		<ontouchmove public="1" set="method" line="466"><f a="e">
	<t path="luxe.TouchEvent"/>
	<x path="Void"/>
</f></ontouchmove>
		<ontouchend public="1" set="method" line="463"><f a="e">
	<t path="luxe.TouchEvent"/>
	<x path="Void"/>
</f></ontouchend>
		<ontouchbegin public="1" set="method" line="460"><f a="e">
	<t path="luxe.TouchEvent"/>
	<x path="Void"/>
</f></ontouchbegin>
		<onmousemove public="1" set="method" line="448"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></onmousemove>
		<onmouseup public="1" set="method" line="434"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></onmouseup>
		<onmousedown public="1" set="method" line="420"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></onmousedown>
		<oninputup public="1" set="method" line="409"><f a="_name:e">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></oninputup>
		<oninputdown public="1" set="method" line="400"><f a="_name:e">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></oninputdown>
		<onkeyup public="1" set="method" line="376"><f a="e">
	<t path="luxe.KeyEvent"/>
	<x path="Void"/>
</f></onkeyup>
		<onkeydown public="1" set="method" line="343"><f a="e">
	<t path="luxe.KeyEvent"/>
	<x path="Void"/>
</f></onkeydown>
		<onresize public="1" set="method" line="328"><f a="e">
	<a>
		<y set="null"><x path="Float"/></y>
		<x set="null"><x path="Float"/></x>
	</a>
	<x path="Void"/>
</f></onresize>
		<show_console public="1" set="method" line="322"><f a="?_show">
	<x path="Bool"/>
	<x path="Void"/>
</f></show_console>
		<set_renderer public="1" set="method" line="311"><f a="_renderer">
	<c path="luxe.Renderer"/>
	<x path="Void"/>
</f></set_renderer>
		<render public="1" set="method" line="294"><f a=""><x path="Void"/></f></render>
		<update public="1" set="method" line="251"><f a=""><x path="Void"/></f></update>
		<shutdown public="1" set="method" line="205"><f a=""><x path="Void"/></f></shutdown>
		<startup public="1" set="method" line="133"><f a=""><x path="Void"/></f></startup>
		<ready set="method" line="102"><f a="_lime">
	<c path="lime.LiME"/>
	<x path="Void"/>
</f></ready>
		<has_shutdown public="1"><x path="Bool"/></has_shutdown>
		<shutting_down public="1"><x path="Bool"/></shutting_down>
		<add_internal_update public="1" set="method" line="68"><f a="_update">
	<f a="">
		<x path="Float"/>
		<x path="Void"/>
	</f>
	<c path="String"/>
</f></add_internal_update>
		<_update_handlers><x path="Map">
	<c path="String"/>
	<f a="">
		<x path="Float"/>
		<x path="Void"/>
	</f>
</x></_update_handlers>
		<_mouse_pos><t path="luxe.Vector"/></_mouse_pos>
		<profiling public="1"><x path="Bool"/></profiling>
		<profile_path public="1"><c path="String"/></profile_path>
		<dt public="1"><x path="Float"/></dt>
		<end_dt><x path="Float"/></end_dt>
		<screen public="1"><t path="luxe.Rectangle"/></screen>
		<renderer public="1"><d/></renderer>
		<scene public="1"><c path="luxe.Scene"/></scene>
		<audio public="1"><c path="luxe.Audio"/></audio>
		<input public="1"><c path="luxe.Input"/></input>
		<events public="1"><c path="luxe.Events"/></events>
		<time public="1"><c path="luxe.Time"/></time>
		<draw public="1"><c path="luxe.Draw"/></draw>
		<file public="1"><c path="luxe.Files"/></file>
		<debug public="1"><c path="luxe.Debug"/></debug>
		<lime public="1"><c path="lime.LiME"/></lime>
		<console_visible public="1"><x path="Bool"/></console_visible>
		<config public="1"><d/></config>
		<host public="1"><d/></host>
		<version public="1"><c path="String"/></version>
		<new public="1" set="method" line="82"><f a="_host">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.Debug" params="" file="/Users/Sven/dev/lab/luxe/luxe/Debug.hx">
		<internal_trace public="1" set="method" line="87" static="1"><f a="v:?inf">
	<d/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></internal_trace>
		<process public="1" set="method" line="572"><f a=""><x path="Void"/></f></process>
		<update_render_stats public="1" set="method" line="547"><f a=""><x path="Void"/></f></update_render_stats>
		<toggle_debug_stats public="1" set="method" line="544"><f a=""><x path="Void"/></f></toggle_debug_stats>
		<hide_debug public="1"><x path="Bool"/></hide_debug>
		<refresh_render_stats public="1" set="method" line="526"><f a=""><x path="Void"/></f></refresh_render_stats>
		<shutdown public="1" set="method" line="522"><f a=""><x path="Void"/></f></shutdown>
		<show_stats_console public="1" set="method" line="510"><f a="?_show">
	<x path="Bool"/>
	<x path="Void"/>
</f></show_stats_console>
		<show_log_console public="1" set="method" line="502"><f a="?_show">
	<x path="Bool"/>
	<x path="Void"/>
</f></show_log_console>
		<show_batcher_list public="1" set="method" line="491"><f a="?_show">
	<x path="Bool"/>
	<x path="Void"/>
</f></show_batcher_list>
		<draw_batcher_tree public="1" set="method" line="474"><f a=""><x path="Void"/></f></draw_batcher_tree>
		<draw_geom_leaf public="1" set="method" line="427"><f a="L:_leaf:_p">
	<x path="Bool"/>
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="phoenix.geometry.Geometry"/>
		<c path="phoenix.geometry.Geometry"/>
	</c>
	<t path="luxe.Vector"/>
	<x path="Void"/>
</f></draw_geom_leaf>
		<draw_geom_node public="1" set="method" line="379"><f a="l:_g:_p">
	<x path="Bool"/>
	<c path="phoenix.geometry.Geometry"/>
	<t path="luxe.Vector"/>
	<x path="Void"/>
</f></draw_geom_node>
		<clear_batcher_tree public="1" set="method" line="372"><f a=""><x path="Void"/></f></clear_batcher_tree>
		<_tree_geom><c path="phoenix.geometry.CompositeGeometry"/></_tree_geom>
		<show_console public="1" set="method" line="341"><f a="?_show">
	<x path="Bool"/>
	<x path="Void"/>
</f></show_console>
		<last_cursor_locked><x path="Bool"/></last_cursor_locked>
		<last_cursor_shown><x path="Bool"/></last_cursor_shown>
		<switch_console public="1" set="method" line="315"><f a="?_change">
	<x path="Bool"/>
	<x path="Void"/>
</f></switch_console>
		<get_resource_stats_string public="1" set="method" line="311"><f a=""><c path="String"/></f></get_resource_stats_string>
		<get_render_stats_string public="1" set="method" line="301"><f a=""><c path="String"/></f></get_render_stats_string>
		<get_batcher_list_string public="1" set="method" line="293"><f a=""><c path="String"/></f></get_batcher_list_string>
		<refresh public="1" set="method" line="264"><f a=""><x path="Void"/></f></refresh>
		<create_stats_console public="1" set="method" line="228"><f a=""><x path="Void"/></f></create_stats_console>
		<create_batch_console public="1" set="method" line="213"><f a=""><x path="Void"/></f></create_batch_console>
		<refresh_lines set="method" line="180"><f a=""><x path="Void"/></f></refresh_lines>
		<_last_logged_length><x path="Int"/></_last_logged_length>
		<add_line public="1" set="method" line="166"><f a="_t">
	<c path="String"/>
	<x path="Void"/>
</f></add_line>
		<create_log_console public="1" set="method" line="147"><f a=""><x path="Void"/></f></create_log_console>
		<onresize public="1" set="method" line="143"><f a="e">
	<a>
		<y set="null"><x path="Float"/></y>
		<x set="null"><x path="Float"/></x>
	</a>
	<x path="Void"/>
</f></onresize>
		<create_debug_console public="1" set="method" line="99"><f a=""><x path="Void"/></f></create_debug_console>
		<startup public="1" set="method" line="60"><f a=""><x path="Void"/></f></startup>
		<_render_stats public="1"><d/></_render_stats>
		<_last_render_stats public="1"><d/></_last_render_stats>
		<started public="1"><x path="Bool"/></started>
		<padding public="1"><t path="luxe.Vector"/></padding>
		<view_count public="1"><x path="Int"/></view_count>
		<current_view public="1"><x path="Int"/></current_view>
		<dt_average_count public="1"><x path="Int"/></dt_average_count>
		<dt_average_span public="1"><x path="Int"/></dt_average_span>
		<dt_average_accum public="1"><x path="Float"/></dt_average_accum>
		<dt_average public="1"><x path="Float"/></dt_average>
		<debug_geometry_count public="1"><x path="Int"/></debug_geometry_count>
		<debug_draw_call_count public="1"><x path="Int"/></debug_draw_call_count>
		<debug_overlay public="1"><c path="phoenix.geometry.QuadGeometry"/></debug_overlay>
		<debug_font public="1"><c path="phoenix.BitmapFont"/></debug_font>
		<debug_view public="1"><c path="phoenix.Camera"/></debug_view>
		<debug_batcher public="1"><c path="phoenix.Batcher"/></debug_batcher>
		<max_lines public="1"><x path="Int"/></max_lines>
		<lines public="1"><c path="luxe.Text"/></lines>
		<logged public="1"><c path="Array"><c path="String"/></c></logged>
		<resource_list_text public="1"><c path="luxe.Text"/></resource_list_text>
		<resource_stats_text public="1"><c path="luxe.Text"/></resource_stats_text>
		<render_stats_text public="1"><c path="luxe.Text"/></render_stats_text>
		<batcher_list_text public="1"><c path="luxe.Text"/></batcher_list_text>
		<scene_inspector public="1"><c path="luxe.debug.Inspector"/></scene_inspector>
		<visible public="1"><x path="Bool"/></visible>
		<core public="1"><c path="luxe.Core"/></core>
		<new public="1" set="method" line="19"><f a="_core">
	<c path="luxe.Core"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.Draw" params="" file="/Users/Sven/dev/lab/luxe/luxe/Draw.hx">
		<axis3D public="1" set="method" line="115"><f a="?options">
	<d/>
	<x path="Void"/>
</f></axis3D>
		<plane public="1" set="method" line="103"><f a="options">
	<d/>
	<c path="phoenix.geometry.PlaneGeometry"/>
</f></plane>
		<circle public="1" set="method" line="91"><f a="options">
	<d/>
	<c path="phoenix.geometry.CircleGeometry"/>
</f></circle>
		<ring public="1" set="method" line="79"><f a="options">
	<d/>
	<c path="phoenix.geometry.RingGeometry"/>
</f></ring>
		<text public="1" set="method" line="69"><f a="options">
	<d/>
	<c path="phoenix.geometry.Geometry"/>
</f></text>
		<rectangle public="1" set="method" line="57"><f a="options">
	<d/>
	<c path="phoenix.geometry.RectangleGeometry"/>
</f></rectangle>
		<box public="1" set="method" line="45"><f a="options">
	<d/>
	<c path="phoenix.geometry.QuadGeometry"/>
</f></box>
		<line public="1" set="method" line="30"><f a="options">
	<d/>
	<c path="phoenix.geometry.LineGeometry"/>
</f></line>
		<default_options set="method" line="16"><f a="options">
	<d/>
	<unknown/>
</f></default_options>
		<core public="1"><c path="luxe.Core"/></core>
		<new public="1" set="method" line="14"><f a="_core">
	<c path="luxe.Core"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.Events" params="" file="/Users/Sven/dev/lab/luxe/luxe/Events.hx">
		<unschedule public="1" set="method" line="252"><f a="schedule_id">
	<c path="String"/>
	<x path="Bool"/>
</f></unschedule>
		<schedule public="1" set="method" line="236"><f a="time:event_name:?properties">
	<x path="Float"/>
	<c path="String"/>
	<d/>
	<c path="String"/>
</f></schedule>
		<fire public="1" set="method" line="189"><f a="_event_name:?_properties">
	<c path="String"/>
	<d/>
	<x path="Bool"/>
</f></fire>
		<tag_properties set="method" line="171"><f a="_properties:_name:_count">
	<d/>
	<c path="String"/>
	<x path="Int"/>
	<unknown/>
</f></tag_properties>
		<process public="1" set="method" line="154"><f a=""><x path="Void"/></f></process>
		<dequeue public="1" set="method" line="141"><f a="event_id">
	<c path="String"/>
	<x path="Bool"/>
</f></dequeue>
		<queue public="1" set="method" line="127"><f a="event_name:?properties">
	<c path="String"/>
	<d/>
	<c path="String"/>
</f></queue>
		<disconnect public="1" set="method" line="95"><f a="event_id">
	<c path="String"/>
	<x path="Bool"/>
</f></disconnect>
		<listen public="1" set="method" line="50"><f a="_event_name:_listener">
	<c path="String"/>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<c path="String"/>
</f></listen>
		<does_filter_event public="1" set="method" line="36"><f a="_filter:_event">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></does_filter_event>
		<shutdown public="1" set="method" line="31"><f a=""><x path="Void"/></f></shutdown>
		<startup public="1" set="method" line="27"><f a=""><x path="Void"/></f></startup>
		<event_schedules public="1"><x path="Map">
	<c path="String"/>
	<c path="haxe.Timer"/>
</x></event_schedules>
		<event_filters public="1"><x path="Map">
	<c path="String"/>
	<c path="Array"><c path="luxe.EventConnection"/></c>
</x></event_filters>
		<event_slots public="1"><x path="Map">
	<c path="String"/>
	<c path="Array"><c path="luxe.EventConnection"/></c>
</x></event_slots>
		<event_connections public="1"><x path="Map">
	<c path="String"/>
	<c path="luxe.EventConnection"/>
</x></event_connections>
		<event_queue public="1"><x path="Map">
	<c path="String"/>
	<c path="luxe.EventObject"/>
</x></event_queue>
		<new public="1" set="method" line="18"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="luxe.EventConnection" params="" file="/Users/Sven/dev/lab/luxe/luxe/Events.hx" module="luxe.Events">
		<event_name public="1"><c path="String"/></event_name>
		<id public="1"><c path="String"/></id>
		<listener public="1"><f a="">
	<d/>
	<x path="Void"/>
</f></listener>
		<new public="1" set="method" line="277"><f a="_id:_event_name:_listener">
	<c path="String"/>
	<c path="String"/>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.EventObject" params="" file="/Users/Sven/dev/lab/luxe/luxe/Events.hx" module="luxe.Events">
		<properties public="1"><d/></properties>
		<name public="1"><c path="String"/></name>
		<id public="1"><c path="String"/></id>
		<new public="1" set="method" line="291"><f a="_id:_event_name:_event_properties">
	<c path="String"/>
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.Files" params="" file="/Users/Sven/dev/lab/luxe/luxe/Files.hx">
		<process public="1" set="method" line="19"><f a=""><x path="Void"/></f></process>
		<shutdown public="1" set="method" line="15"><f a=""><x path="Void"/></f></shutdown>
		<startup public="1" set="method" line="11"><f a=""><x path="Void"/></f></startup>
		<core public="1"><c path="luxe.Core"/></core>
		<new public="1" set="method" line="8"><f a="_core">
	<c path="luxe.Core"/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="luxe.KeyValue" params="" file="/Users/Sven/dev/lab/luxe/luxe/Input.hx" module="luxe.Input"><e path="lime.utils.KeyValue"/></typedef>
	<typedef path="luxe.MouseButton" params="" file="/Users/Sven/dev/lab/luxe/luxe/Input.hx" module="luxe.Input"><e path="lime.MouseButton"/></typedef>
	<typedef path="luxe.MouseState" params="" file="/Users/Sven/dev/lab/luxe/luxe/Input.hx" module="luxe.Input"><e path="lime.MouseState"/></typedef>
	<typedef path="luxe.TouchState" params="" file="/Users/Sven/dev/lab/luxe/luxe/Input.hx" module="luxe.Input"><e path="lime.TouchState"/></typedef>
	<typedef path="luxe.KeyEvent" params="" file="/Users/Sven/dev/lab/luxe/luxe/Input.hx" module="luxe.Input"><t path="lime.KeyEvent"/></typedef>
	<typedef path="luxe.TouchEvent" params="" file="/Users/Sven/dev/lab/luxe/luxe/Input.hx" module="luxe.Input"><t path="lime.TouchEvent"/></typedef>
	<typedef path="luxe.GamepadEvent" params="" file="/Users/Sven/dev/lab/luxe/luxe/Input.hx" module="luxe.Input"><t path="lime.GamepadEvent"/></typedef>
	<typedef path="luxe.MouseEvent" params="" file="/Users/Sven/dev/lab/luxe/luxe/Input.hx" module="luxe.Input"><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
	<state><e path="lime.MouseState"/></state>
	<shift_down><x path="Bool"/></shift_down>
	<raw><d/></raw>
	<pos><t path="luxe.Vector"/></pos>
	<meta_down><x path="Bool"/></meta_down>
	<flags><x path="Int"/></flags>
	<deltaY><x path="Float"/></deltaY>
	<deltaX><x path="Float"/></deltaX>
	<ctrl_down><x path="Bool"/></ctrl_down>
	<button><e path="lime.MouseButton"/></button>
	<alt_down><x path="Bool"/></alt_down>
</a></typedef>
	<class path="luxe.Input" params="" file="/Users/Sven/dev/lab/luxe/luxe/Input.hx">
		<Keys public="1" static="1"><c path="lime.utils.Keys"/></Keys>
		<Gamepad public="1" static="1"><c path="lime.utils.Gamepad"/></Gamepad>
		<joybuttonup public="1" set="method" line="202">
			<f a="_event">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</joybuttonup>
		<joybuttondown public="1" set="method" line="199">
			<f a="_event">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</joybuttondown>
		<joyhatmove public="1" set="method" line="196">
			<f a="_event">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</joyhatmove>
		<joyballmove public="1" set="method" line="193">
			<f a="_event">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</joyballmove>
		<joyaxismove public="1" set="method" line="190">
			<f a="_event">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</joyaxismove>
		<touchtap public="1" set="method" line="185">
			<f a="_event">
				<t path="luxe.TouchEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</touchtap>
		<touchend public="1" set="method" line="182">
			<f a="_event">
				<t path="luxe.TouchEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</touchend>
		<touchmove public="1" set="method" line="179">
			<f a="_event">
				<t path="luxe.TouchEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</touchmove>
		<touchbegin public="1" set="method" line="176">
			<f a="_event">
				<t path="luxe.TouchEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</touchbegin>
		<mouseup public="1" set="method" line="170">
			<f a="_event">
				<t path="luxe.MouseEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</mouseup>
		<mouseclick public="1" set="method" line="167">
			<f a="_event">
				<t path="luxe.MouseEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</mouseclick>
		<mousedown public="1" set="method" line="164">
			<f a="_event">
				<t path="luxe.MouseEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</mousedown>
		<mousemove public="1" set="method" line="161">
			<f a="_event">
				<t path="luxe.MouseEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</mousemove>
		<lostinputfocus public="1" set="method" line="156">
			<f a="_event">
				<t path="luxe.KeyEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</lostinputfocus>
		<gotinputfocus public="1" set="method" line="153">
			<f a="_event">
				<t path="luxe.KeyEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</gotinputfocus>
		<onkeyup public="1" set="method" line="150">
			<f a="_event">
				<t path="luxe.KeyEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</onkeyup>
		<onkeydown public="1" set="method" line="147">
			<f a="_event">
				<t path="luxe.KeyEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</onkeydown>
		<onchar public="1" set="method" line="144">
			<f a="_event">
				<t path="luxe.KeyEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</onchar>
		<check_named_mouse public="1" set="method" line="117">
			<f a="e:?_down">
				<t path="luxe.MouseEvent"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</check_named_mouse>
		<check_named_keys public="1" set="method" line="93">
			<f a="e:?_down">
				<t path="luxe.KeyEvent"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</check_named_keys>
		<add public="1" set="method" line="82"><f a="_name:_event">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></add>
		<add_mouse_binding set="method" line="71"><f a="_name:_value">
	<c path="String"/>
	<t path="luxe.MouseButton"/>
	<x path="Void"/>
</f></add_mouse_binding>
		<add_key_binding set="method" line="60"><f a="_name:_value">
	<c path="String"/>
	<t path="luxe.KeyValue"/>
	<x path="Void"/>
</f></add_key_binding>
		<process public="1" set="method" line="54">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</process>
		<shutdown public="1" set="method" line="50">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</shutdown>
		<startup public="1" set="method" line="38">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</startup>
		<mouse_bindings><x path="Map">
	<c path="String"/>
	<x path="Map">
		<t path="luxe.MouseButton"/>
		<x path="Bool"/>
	</x>
</x></mouse_bindings>
		<key_bindings><x path="Map">
	<c path="String"/>
	<x path="Map">
		<t path="luxe.KeyValue"/>
		<x path="Bool"/>
	</x>
</x></key_bindings>
		<core public="1"><c path="luxe.Core"/></core>
		<new public="1" set="method" line="24"><f a="_core">
	<c path="luxe.Core"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.Modes" params="" file="/Users/Sven/dev/lab/luxe/luxe/Modes.hx">
		<onmousemove public="1" set="method" line="162"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></onmousemove>
		<onmouseup public="1" set="method" line="157"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></onmouseup>
		<onmousedown public="1" set="method" line="152"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></onmousedown>
		<oninputdown public="1" set="method" line="147"><f a="name:e">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></oninputdown>
		<oninputup public="1" set="method" line="142"><f a="name:e">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></oninputup>
		<onkeyup public="1" set="method" line="137"><f a="e">
	<t path="luxe.KeyEvent"/>
	<x path="Void"/>
</f></onkeyup>
		<onkeydown public="1" set="method" line="132"><f a="e">
	<t path="luxe.KeyEvent"/>
	<x path="Void"/>
</f></onkeydown>
		<_call set="method" line="125"><f a="_object:_name:?args">
	<c path="luxe.Mode"/>
	<c path="String"/>
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></_call>
		<destroy public="1" set="method" line="117"><f a=""><x path="Void"/></f></destroy>
		<update public="1" set="method" line="111"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<start public="1" set="method" line="106"><f a=""><x path="Void"/></f></start>
		<init public="1" set="method" line="101"><f a=""><x path="Void"/></f></init>
		<set public="1" set="method" line="84"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></set>
		<disable public="1" set="method" line="78"><f a="_name">
	<c path="String"/>
	<x path="Void"/>
</f></disable>
		<enable public="1" set="method" line="72"><f a="_name">
	<c path="String"/>
	<x path="Void"/>
</f></enable>
		<add_mode public="1" params="T" set="method" line="44"><f a="type:?_name">
	<x path="Class"><c path="add_mode.T"/></x>
	<c path="String"/>
	<c path="add_mode.T"/>
</f></add_mode>
		<currentmode public="1"><c path="luxe.Mode"/></currentmode>
		<activemodes public="1"><c path="Array"><c path="luxe.Mode"/></c></activemodes>
		<_modes public="1"><x path="Map">
	<c path="String"/>
	<c path="luxe.Mode"/>
</x></_modes>
		<new public="1" set="method" line="39"><f a=""><x path="Void"/></f></new>
	</class>
	<typedef path="luxe.Slice" params="" file="/Users/Sven/dev/lab/luxe/luxe/NineSlice.hx" module="luxe.NineSlice"><a>
	<width><x path="Float"/></width>
	<source_y><x path="Float"/></source_y>
	<source_x><x path="Float"/></source_x>
	<source_width><x path="Float"/></source_width>
	<source_height><x path="Float"/></source_height>
	<pos><t path="luxe.Vector"/></pos>
	<height><x path="Float"/></height>
	<geometry_id><c path="String"/></geometry_id>
</a></typedef>
	<class path="luxe.Sprite" params="" file="/Users/Sven/dev/lab/luxe/luxe/Sprite.hx">
		<extends path="luxe.Entity"/>
		<set_clip_rect public="1" set="method" line="455"><f a="val">
	<t path="luxe.Rectangle"/>
	<t path="luxe.Rectangle"/>
</f></set_clip_rect>
		<set_clip public="1" set="method" line="451"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_clip>
		<set_uv public="1" set="method" line="441"><f a="_uv">
	<t path="luxe.Rectangle"/>
	<t path="luxe.Rectangle"/>
</f></set_uv>
		<set_locked public="1" set="method" line="431"><f a="_l">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_locked>
		<set_size public="1" set="method" line="414"><f a="_v">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></set_size>
		<set_scale public="1" set="method" line="398" override="1"><f a="_v">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></set_scale>
		<set_radians public="1" set="method" line="379"><f a="_r">
	<x path="Float"/>
	<x path="Float"/>
</f></set_radians>
		<set_rotation_z public="1" set="method" line="371"><f a="_r">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rotation_z>
		<get_rotation_z public="1" set="method" line="365"><f a=""><x path="Float"/></f></get_rotation_z>
		<set_pos public="1" set="method" line="348" override="1"><f a="_p">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></set_pos>
		<set_centered public="1" set="method" line="330"><f a="_c">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_centered>
		<set_origin public="1" set="method" line="318"><f a="_o">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></set_origin>
		<set_shader set="method" line="307"><f a="_s">
	<c path="phoenix.Shader"/>
	<c path="phoenix.Shader"/>
</f></set_shader>
		<set_texture set="method" line="298"><f a="_t">
	<c path="phoenix.Texture"/>
	<c path="phoenix.Texture"/>
</f></set_texture>
		<set_color public="1" set="method" line="284"><f a="_c">
	<c path="phoenix.Color"/>
	<c path="phoenix.Color"/>
</f></set_color>
		<set_depth public="1" set="method" line="272"><f a="_v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_depth>
		<set_visible public="1" set="method" line="259"><f a="_v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<set_flipx public="1" set="method" line="248"><f a="_v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_flipx>
		<set_flipy public="1" set="method" line="238"><f a="_v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_flipy>
		<point_inside public="1" set="method" line="219"><f a="_p">
	<c path="phoenix.Vector"/>
	<x path="Bool"/>
</f></point_inside>
		<destroy public="1" set="method" line="202"><f a=""><x path="Void"/></f></destroy>
		<_create_geometry public="1" set="method" line="133"><f a="options">
	<d/>
	<x path="Void"/>
</f></_create_geometry>
		<_rotation_quat><c path="phoenix.Quaternion"/></_rotation_quat>
		<_rotation_vector><c path="phoenix.Vector"/></_rotation_vector>
		<flipx public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</flipx>
		<flipy public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</flipy>
		<clip_rect public="1" set="accessor">
			<t path="luxe.Rectangle"/>
			<meta><m n=":isVar"/></meta>
		</clip_rect>
		<clip public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</clip>
		<uv public="1" set="accessor">
			<t path="luxe.Rectangle"/>
			<meta><m n=":isVar"/></meta>
		</uv>
		<origin public="1" set="accessor">
			<c path="phoenix.Vector"/>
			<meta><m n=":isVar"/></meta>
		</origin>
		<centered public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</centered>
		<depth public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</depth>
		<radians public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</radians>
		<rotation_z public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</rotation_z>
		<visible public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</visible>
		<color public="1" set="accessor">
			<c path="phoenix.Color"/>
			<meta><m n=":isVar"/></meta>
		</color>
		<size public="1" set="accessor">
			<c path="phoenix.Vector"/>
			<meta><m n=":isVar"/></meta>
		</size>
		<shader public="1" set="accessor">
			<c path="phoenix.Shader"/>
			<meta><m n=":isVar"/></meta>
		</shader>
		<texture public="1" set="accessor">
			<c path="phoenix.Texture"/>
			<meta><m n=":isVar"/></meta>
		</texture>
		<locked public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</locked>
		<geometry public="1">
			<c path="phoenix.geometry.QuadGeometry"/>
			<meta><m n=":isVar"/></meta>
		</geometry>
		<new public="1" set="method" line="42"><f a="options">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.NineSlice" params="" file="/Users/Sven/dev/lab/luxe/luxe/NineSlice.hx">
		<extends path="luxe.Sprite"/>
		<create public="1" set="method" line="441"><f a="_pos:_w:_h:?_reset">
	<t path="luxe.Vector"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></create>
		<_create set="method" line="403"><f a="_pos:_w:_h:?_reset">
	<t path="luxe.Vector"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></_create>
		<set_color public="1" set="method" line="394" override="1"><f a="_color">
	<t path="luxe.Color"/>
	<t path="luxe.Color"/>
</f></set_color>
		<set_clip_rect public="1" set="method" line="385" override="1"><f a="val">
	<t path="luxe.Rectangle"/>
	<t path="luxe.Rectangle"/>
</f></set_clip_rect>
		<set_clip public="1" set="method" line="376" override="1"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_clip>
		<set_visible public="1" set="method" line="365" override="1"><f a="_v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<destroy public="1" set="method" line="355" override="1"><f a=""><x path="Void"/></f></destroy>
		<set_pos public="1" set="method" line="341" override="1"><f a="_v">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_pos>
		<set_size public="1" set="method" line="325" override="1"><f a="_v">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_size>
		<set public="1" set="method" line="204"><f a="_width:_height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set>
		<update_size public="1" set="method" line="111"><f a="_width:_height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></update_size>
		<dirty public="1" set="method" line="105"><f a=""><x path="Void"/></f></dirty>
		<lock public="1" set="method" line="100"><f a=""><x path="Void"/></f></lock>
		<_geometry public="1"><c path="phoenix.geometry.ComplexGeometry"/></_geometry>
		<_batcher><c path="phoenix.Batcher"/></_batcher>
		<midheight public="1"><x path="Float"/></midheight>
		<midwidth public="1"><x path="Float"/></midwidth>
		<is_set public="1"><x path="Bool"/></is_set>
		<source_h public="1"><x path="Float"/></source_h>
		<source_w public="1"><x path="Float"/></source_w>
		<source_y public="1"><x path="Float"/></source_y>
		<source_x public="1"><x path="Float"/></source_x>
		<height public="1"><x path="Float"/></height>
		<bottom public="1"><x path="Float"/></bottom>
		<width public="1"><x path="Float"/></width>
		<right public="1"><x path="Float"/></right>
		<left public="1"><x path="Float"/></left>
		<top public="1"><x path="Float"/></top>
		<options public="1"><d/></options>
		<added public="1"><x path="Bool"/></added>
		<slices public="1"><c path="Array"><t path="luxe.Slice"/></c></slices>
		<new public="1" set="method" line="48"><f a="_options">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="luxe.Quaternion" params="" file="/Users/Sven/dev/lab/luxe/luxe/Quaternion.hx"><c path="phoenix.Quaternion"/></typedef>
	<typedef path="luxe.Rectangle" params="" file="/Users/Sven/dev/lab/luxe/luxe/Rectangle.hx"><c path="phoenix.Rectangle"/></typedef>
	<class path="luxe.Renderer" params="" file="/Users/Sven/dev/lab/luxe/luxe/Renderer.hx">
		<process public="1" set="method" line="23"><f a=""><x path="Void"/></f></process>
		<shutdown public="1" set="method" line="19"><f a=""><x path="Void"/></f></shutdown>
		<startup public="1" set="method" line="14"><f a=""><x path="Void"/></f></startup>
		<core public="1"><c path="luxe.Core"/></core>
		<new public="1" set="method" line="12"><f a="_core">
	<c path="luxe.Core"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.Scene" params="" file="/Users/Sven/dev/lab/luxe/luxe/Scene.hx">
		<fixed_update public="1" set="method" line="125"><f a=""><x path="Void"/></f></fixed_update>
		<update public="1" set="method" line="120"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<start public="1" set="method" line="114"><f a=""><x path="Void"/></f></start>
		<init public="1" set="method" line="108"><f a=""><x path="Void"/></f></init>
		<destroy public="1" set="method" line="103"><f a=""><x path="Void"/></f></destroy>
		<onmousemove public="1" set="method" line="97"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></onmousemove>
		<onmouseup public="1" set="method" line="92"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></onmouseup>
		<onmousedown public="1" set="method" line="87"><f a="e">
	<t path="luxe.MouseEvent"/>
	<x path="Void"/>
</f></onmousedown>
		<oninputup public="1" set="method" line="82"><f a="_name:e">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></oninputup>
		<oninputdown public="1" set="method" line="77"><f a="_name:e">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></oninputdown>
		<shutdown public="1" set="method" line="73"><f a=""><x path="Void"/></f></shutdown>
		<empty public="1" set="method" line="61"><f a=""><x path="Void"/></f></empty>
		<remove public="1" set="method" line="56"><f a="entity">
	<c path="luxe.Entity"/>
	<x path="Void"/>
</f></remove>
		<add public="1" set="method" line="43"><f a="entity">
	<c path="luxe.Entity"/>
	<x path="Void"/>
</f></add>
		<create public="1" params="T" set="method" line="19"><f a="type:?_name">
	<x path="Class"><c path="create.T"/></x>
	<c path="String"/>
	<c path="create.T"/>
</f></create>
		<started public="1"><x path="Bool"/></started>
		<inited public="1"><x path="Bool"/></inited>
		<entities public="1"><x path="Map">
	<c path="String"/>
	<c path="luxe.Entity"/>
</x></entities>
		<name public="1"><c path="String"/></name>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
	</class>
	<typedef path="luxe.TextAlign" params="" file="/Users/Sven/dev/lab/luxe/luxe/Text.hx" module="luxe.Text"><e path="phoenix.TextAlign"/></typedef>
	<class path="luxe.Text" params="" file="/Users/Sven/dev/lab/luxe/luxe/Text.hx">
		<set_text public="1" set="method" line="117"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<set_visible public="1" set="method" line="106"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<set_color public="1" set="method" line="96"><f a="c">
	<t path="luxe.Color"/>
	<t path="luxe.Color"/>
</f></set_color>
		<set_size public="1" set="method" line="89"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_size>
		<set_pos public="1" set="method" line="77"><f a="v">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_pos>
		<destroy public="1" set="method" line="70"><f a=""><x path="Void"/></f></destroy>
		<onloaded public="1" set="method" line="65"><f a=""><x path="Void"/></f></onloaded>
		<text_options public="1"><d/></text_options>
		<ready public="1"><x path="Bool"/></ready>
		<visible public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</visible>
		<color public="1" set="accessor">
			<t path="luxe.Color"/>
			<meta><m n=":isVar"/></meta>
		</color>
		<size public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</size>
		<pos public="1" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</pos>
		<text public="1" set="accessor">
			<c path="String"/>
			<meta><m n=":isVar"/></meta>
		</text>
		<_batcher><c path="phoenix.Batcher"/></_batcher>
		<geometry public="1"><c path="phoenix.geometry.CompositeGeometry"/></geometry>
		<font public="1"><c path="phoenix.BitmapFont"/></font>
		<new public="1" set="method" line="26"><f a="_options">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.Time" params="" file="/Users/Sven/dev/lab/luxe/luxe/Time.hx">
		<process public="1" set="method" line="32"><f a=""><x path="Void"/></f></process>
		<schedule public="1" set="method" line="20"><f a="_time_in_seconds:_on_time:?repeat">
	<x path="Float"/>
	<f a=""><x path="Void"/></f>
	<x path="Bool"/>
	<c path="haxe.Timer"/>
</f></schedule>
		<shutdown public="1" set="method" line="16"><f a=""><x path="Void"/></f></shutdown>
		<startup public="1" set="method" line="12"><f a=""><x path="Void"/></f></startup>
		<core public="1"><c path="luxe.Core"/></core>
		<new public="1" set="method" line="9"><f a="_core">
	<c path="luxe.Core"/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="luxe.Vector" params="" file="/Users/Sven/dev/lab/luxe/luxe/Vector.hx"><c path="phoenix.Vector"/></typedef>
	<typedef path="luxe.Vec" params="" file="/Users/Sven/dev/lab/luxe/luxe/Vector.hx" module="luxe.Vector"><x path="phoenix.Vec"/></typedef>
	<class path="luxe.components.Components" params="" file="/Users/Sven/dev/lab/luxe/luxe/components/Components.hx">
		<_show_debug public="1" line="192" static="1"><x path="Bool"/></_show_debug>
		<_debug set="method" line="193"><f a="v">
	<c path="String"/>
	<x path="Void"/>
</f></_debug>
		<_call set="method" line="183"><f a="_object:_name:?args">
	<d/>
	<c path="String"/>
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></_call>
		<has public="1" set="method" line="179"><f a="_name">
	<c path="String"/>
	<x path="Bool"/>
</f></has>
		<get public="1" set="method" line="122"><f a="_name:?in_children:?first_only">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<d/>
</f></get>
		<add public="1" params="T" set="method" line="85"><f a="type:?_name">
	<x path="Class"><c path="add.T"/></x>
	<c path="String"/>
	<c path="add.T"/>
</f></add>
		<entity public="1"><c path="luxe.Entity"/></entity>
		<components public="1"><x path="Map">
	<c path="String"/>
	<c path="luxe.components.Component"/>
</x></components>
		<new public="1" set="method" line="78"><f a="_entity">
	<c path="luxe.Entity"/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="luxe.components.sprite.SpriteAnimationFrame" params="" file="/Users/Sven/dev/lab/luxe/luxe/components/sprite/SpriteAnimation.hx" module="luxe.components.sprite.SpriteAnimation"><a>
	<image_frame><x path="Int"/></image_frame>
	<events><c path="Array"><c path="String"/></c></events>
</a></typedef>
	<class path="luxe.components.sprite.SpriteAnimationData" params="" file="/Users/Sven/dev/lab/luxe/luxe/components/sprite/SpriteAnimation.hx" module="luxe.components.sprite.SpriteAnimation">
		<from_json public="1" set="method" line="35"><f a="_animdata">
	<d/>
	<c path="luxe.components.sprite.SpriteAnimationData"/>
</f></from_json>
		<get_frame_count set="method" line="25"><f a=""><x path="Int"/></f></get_frame_count>
		<frame_count public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":isVar"/></meta>
		</frame_count>
		<reverse public="1"><x path="Bool"/></reverse>
		<pingpong public="1"><x path="Bool"/></pingpong>
		<loop public="1"><x path="Bool"/></loop>
		<frame_time public="1"><x path="Float"/></frame_time>
		<frame_size public="1"><t path="luxe.Vector"/></frame_size>
		<frameset public="1"><c path="Array"><t path="luxe.components.sprite.SpriteAnimationFrame"/></c></frameset>
		<name public="1"><c path="String"/></name>
		<new public="1" set="method" line="29"><f a="?_name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.components.sprite.SpriteAnimation" params="" file="/Users/Sven/dev/lab/luxe/luxe/components/sprite/SpriteAnimation.hx">
		<extends path="luxe.components.Component"/>
		<update public="1" set="method" line="238"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<refresh_sprite set="method" line="222"><f a=""><x path="Void"/></f></refresh_sprite>
		<set_frame public="1" set="method" line="205"><f a="_frame">
	<x path="Int"/>
	<x path="Void"/>
</f></set_frame>
		<stop public="1" set="method" line="201"><f a=""><x path="Void"/></f></stop>
		<play public="1" set="method" line="197"><f a=""><x path="Void"/></f></play>
		<restart public="1" set="method" line="192"><f a=""><x path="Void"/></f></restart>
		<set_animation set="method" line="180"><f a="_name">
	<c path="String"/>
	<c path="String"/>
</f></set_animation>
		<get_animation set="method" line="176"><f a=""><c path="String"/></f></get_animation>
		<add_from_json public="1" set="method" line="151"><f a="_json_string">
	<c path="String"/>
	<x path="Void"/>
</f></add_from_json>
		<init public="1" set="method" line="136"><f a=""><x path="Void"/></f></init>
		<uv_cache><t path="luxe.Rectangle"/></uv_cache>
		<playing public="1"><x path="Bool"/></playing>
		<reverse public="1"><x path="Bool"/></reverse>
		<pingpong public="1"><x path="Bool"/></pingpong>
		<loop public="1"><x path="Bool"/></loop>
		<next_frame_time public="1"><x path="Float"/></next_frame_time>
		<frame_time public="1"><x path="Float"/></frame_time>
		<time><x path="Float"/></time>
		<image_frame public="1"><x path="Int"/></image_frame>
		<frame public="1"><x path="Int"/></frame>
		<animation public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":isVar"/></meta>
		</animation>
		<current public="1"><c path="luxe.components.sprite.SpriteAnimationData"/></current>
		<animation_list public="1"><x path="Map">
	<c path="String"/>
	<c path="luxe.components.sprite.SpriteAnimationData"/>
</x></animation_list>
		<sprite><c path="luxe.Sprite"/></sprite>
		<new public="1" set="method" line="110"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="luxe.debug.Inspector" params="" file="/Users/Sven/dev/lab/luxe/luxe/debug/Inspector.hx">
		<_create_window set="method" line="74"><f a=""><x path="Void"/></f></_create_window>
		<hide public="1" set="method" line="69"><f a=""><x path="Void"/></f></hide>
		<show public="1" set="method" line="64"><f a=""><x path="Void"/></f></show>
		<refresh public="1" set="method" line="54"><f a=""><x path="Void"/></f></refresh>
		<onrefresh public="1"><f a=""><x path="Void"/></f></onrefresh>
		<_batcher><c path="phoenix.Batcher"/></_batcher>
		<_window public="1"><c path="luxe.NineSlice"/></_window>
		<default_button_texture public="1"><c path="phoenix.Texture"/></default_button_texture>
		<default_box_texture public="1"><c path="phoenix.Texture"/></default_box_texture>
		<_title_text public="1"><c path="luxe.Text"/></_title_text>
		<size public="1"><t path="luxe.Vector"/></size>
		<pos public="1"><t path="luxe.Vector"/></pos>
		<font public="1"><c path="phoenix.BitmapFont"/></font>
		<title public="1"><c path="String"/></title>
		<new public="1" set="method" line="28"><f a="_options">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.defaults.TinyBox" params="" file="/Users/Sven/dev/lab/luxe/luxe/defaults/TinyUI.hx" module="luxe.defaults.TinyUI"><data public="1" set="method" line="5" static="1"><f a=""><c path="String"/></f></data></class>
	<class path="luxe.defaults.TinyButton" params="" file="/Users/Sven/dev/lab/luxe/luxe/defaults/TinyUI.hx" module="luxe.defaults.TinyUI"><data public="1" set="method" line="17" static="1"><f a=""><c path="String"/></f></data></class>
	<class path="luxe.structures.BalancedBinarySearchTree" params="K:T" file="/Users/Sven/dev/lab/luxe/luxe/structures/BalancedBinarySearchTree.hx">
		<RED public="1" get="inline" set="null" line="6" static="1"><x path="Bool"/></RED>
		<BLACK public="1" get="inline" set="null" line="7" static="1"><x path="Bool"/></BLACK>
		<traverse public="1" set="method" line="471"><f a="_node:_traverse_method:_process_node_function">
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
	<e path="luxe.structures.BalancedBinarySearchTraverseMethod"/>
	<f a="">
		<c path="luxe.structures.BalancedBinarySearchTreeNode">
			<c path="luxe.structures.BalancedBinarySearchTree.K"/>
			<c path="luxe.structures.BalancedBinarySearchTree.T"/>
		</c>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></traverse>
		<iterator public="1" set="method" line="465"><f a=""><t path="Iterator"><c path="luxe.structures.BalancedBinarySearchTree.T"/></t></f></iterator>
		<keys public="1" set="method" line="455"><f a=""><c path="Array"><c path="luxe.structures.BalancedBinarySearchTree.K"/></c></f></keys>
		<toArray public="1" set="method" line="445"><f a=""><c path="Array"><c path="luxe.structures.BalancedBinarySearchTree.T"/></c></f></toArray>
		<balance set="method" line="425"><f a="_node">
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
</f></balance>
		<move_red_right set="method" line="413"><f a="_node">
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
</f></move_red_right>
		<move_red_left set="method" line="399"><f a="_node">
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
</f></move_red_left>
		<flip_colors public="1" set="method" line="391"><f a="_node">
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
	<x path="Void"/>
</f></flip_colors>
		<rotate_right public="1" set="method" line="380"><f a="_node">
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
</f></rotate_right>
		<rotate_left public="1" set="method" line="369"><f a="_node">
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
</f></rotate_left>
		<is_red set="method" line="364"><f a="_node">
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
	<x path="Bool"/>
</f></is_red>
		<_remove set="method" line="313"><f a="_node:_key">
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
	<c path="luxe.structures.BalancedBinarySearchTree.K"/>
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
</f></_remove>
		<remove public="1" set="method" line="298"><f a="_key">
	<c path="luxe.structures.BalancedBinarySearchTree.K"/>
	<x path="Void"/>
</f></remove>
		<_deleteMax set="method" line="278"><f a="_node">
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
</f></_deleteMax>
		<deleteMax public="1" set="method" line="263"><f a=""><x path="Void"/></f></deleteMax>
		<_deleteMin set="method" line="247"><f a="_node">
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
</f></_deleteMin>
		<deleteMin public="1" set="method" line="233"><f a=""><x path="Void"/></f></deleteMin>
		<_ceil set="method" line="214"><f a="_node:_key">
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
	<c path="luxe.structures.BalancedBinarySearchTree.K"/>
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
</f></_ceil>
		<ceil public="1" set="method" line="205"><f a="_key">
	<c path="luxe.structures.BalancedBinarySearchTree.K"/>
	<t path="Null"><c path="luxe.structures.BalancedBinarySearchTree.K"/></t>
</f></ceil>
		<_floor set="method" line="187"><f a="_node:_key">
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
	<c path="luxe.structures.BalancedBinarySearchTree.K"/>
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
</f></_floor>
		<floor public="1" set="method" line="178"><f a="_key">
	<c path="luxe.structures.BalancedBinarySearchTree.K"/>
	<t path="Null"><c path="luxe.structures.BalancedBinarySearchTree.K"/></t>
</f></floor>
		<_max set="method" line="170"><f a="_node">
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
</f></_max>
		<max public="1" set="method" line="166"><f a=""><c path="luxe.structures.BalancedBinarySearchTree.K"/></f></max>
		<_min public="1" set="method" line="161"><f a="_node">
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
</f></_min>
		<min public="1" set="method" line="157"><f a=""><c path="luxe.structures.BalancedBinarySearchTree.K"/></f></min>
		<_select set="method" line="140"><f a="_node:_rank">
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
	<x path="Int"/>
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
</f></_select>
		<select public="1" set="method" line="136"><f a="_rank">
	<x path="Int"/>
	<c path="luxe.structures.BalancedBinarySearchTree.K"/>
</f></select>
		<_rank set="method" line="121"><f a="_key:_node">
	<c path="luxe.structures.BalancedBinarySearchTree.K"/>
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
	<x path="Int"/>
</f></_rank>
		<rank public="1" set="method" line="117"><f a="_key">
	<c path="luxe.structures.BalancedBinarySearchTree.K"/>
	<x path="Int"/>
</f></rank>
		<_find set="method" line="98"><f a="_node:_key">
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
	<c path="luxe.structures.BalancedBinarySearchTree.K"/>
	<c path="luxe.structures.BalancedBinarySearchTree.T"/>
</f></_find>
		<find public="1" set="method" line="94"><f a="_key">
	<c path="luxe.structures.BalancedBinarySearchTree.K"/>
	<c path="luxe.structures.BalancedBinarySearchTree.T"/>
</f></find>
		<contains public="1" set="method" line="89"><f a="_key">
	<c path="luxe.structures.BalancedBinarySearchTree.K"/>
	<x path="Bool"/>
</f></contains>
		<_insert set="method" line="54"><f a="_node:_key:_value">
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
	<c path="luxe.structures.BalancedBinarySearchTree.K"/>
	<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
</f></_insert>
		<insert public="1" set="method" line="49"><f a="_key:_value">
	<c path="luxe.structures.BalancedBinarySearchTree.K"/>
	<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	<x path="Void"/>
</f></insert>
		<_size set="method" line="40"><f a="_node">
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
	<x path="Int"/>
</f></_size>
		<_height set="method" line="33"><f a="_node">
	<c path="luxe.structures.BalancedBinarySearchTreeNode">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.T"/>
	</c>
	<x path="Int"/>
</f></_height>
		<height public="1" set="method" line="29"><f a=""><x path="Int"/></f></height>
		<size public="1" set="method" line="25"><f a=""><x path="Int"/></f></size>
		<empty public="1" set="method" line="21"><f a=""><x path="Bool"/></f></empty>
		<toString public="1" set="method" line="16"><f a=""><c path="String"/></f></toString>
		<compare public="1"><f a=":">
	<c path="luxe.structures.BalancedBinarySearchTree.K"/>
	<c path="luxe.structures.BalancedBinarySearchTree.K"/>
	<x path="Int"/>
</f></compare>
		<root public="1"><c path="luxe.structures.BalancedBinarySearchTreeNode">
	<c path="luxe.structures.BalancedBinarySearchTree.K"/>
	<c path="luxe.structures.BalancedBinarySearchTree.T"/>
</c></root>
		<new public="1" set="method" line="12"><f a="compare_function">
	<f a=":">
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<c path="luxe.structures.BalancedBinarySearchTree.K"/>
		<x path="Int"/>
	</f>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.structures.BalancedBinarySearchTreeNode" params="K:T" file="/Users/Sven/dev/lab/luxe/luxe/structures/BalancedBinarySearchTree.hx" module="luxe.structures.BalancedBinarySearchTree">
		<value public="1"><c path="luxe.structures.BalancedBinarySearchTreeNode.T"/></value>
		<key public="1"><c path="luxe.structures.BalancedBinarySearchTreeNode.K"/></key>
		<color public="1"><x path="Bool"/></color>
		<nodecount public="1"><x path="Int"/></nodecount>
		<right public="1"><c path="luxe.structures.BalancedBinarySearchTreeNode">
	<c path="luxe.structures.BalancedBinarySearchTreeNode.K"/>
	<c path="luxe.structures.BalancedBinarySearchTreeNode.T"/>
</c></right>
		<left public="1"><c path="luxe.structures.BalancedBinarySearchTreeNode">
	<c path="luxe.structures.BalancedBinarySearchTreeNode.K"/>
	<c path="luxe.structures.BalancedBinarySearchTreeNode.T"/>
</c></left>
		<new public="1" set="method" line="519"><f a="_key:_value:_nodecount:_color">
	<c path="luxe.structures.BalancedBinarySearchTreeNode.K"/>
	<c path="luxe.structures.BalancedBinarySearchTreeNode.T"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="luxe.structures.BalancedBinarySearchTraverseMethod" params="" file="/Users/Sven/dev/lab/luxe/luxe/structures/BalancedBinarySearchTree.hx" module="luxe.structures.BalancedBinarySearchTree">
		<PreOrder/>
		<PostOrder/>
		<InOrder/>
	</enum>
	<class path="luxe.structures.BinarySearchTree" params="K:T" file="/Users/Sven/dev/lab/luxe/luxe/structures/BinarySearchTree.hx">
		<traverse public="1" set="method" line="302"><f a="_node:_traverse_method:_process_node_function">
	<c path="luxe.structures.BinarySearchTreeNode">
		<c path="luxe.structures.BinarySearchTree.K"/>
		<c path="luxe.structures.BinarySearchTree.T"/>
	</c>
	<e path="luxe.structures.BinarySearchTraverseMethod"/>
	<f a="">
		<c path="luxe.structures.BinarySearchTreeNode">
			<c path="luxe.structures.BinarySearchTree.K"/>
			<c path="luxe.structures.BinarySearchTree.T"/>
		</c>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></traverse>
		<iterator public="1" set="method" line="296"><f a=""><t path="Iterator"><c path="luxe.structures.BinarySearchTree.T"/></t></f></iterator>
		<keys public="1" set="method" line="286"><f a=""><c path="Array"><c path="luxe.structures.BinarySearchTree.K"/></c></f></keys>
		<toArray public="1" set="method" line="276"><f a=""><c path="Array"><c path="luxe.structures.BinarySearchTree.T"/></c></f></toArray>
		<_remove set="method" line="241"><f a="_node:_key">
	<c path="luxe.structures.BinarySearchTreeNode">
		<c path="luxe.structures.BinarySearchTree.K"/>
		<c path="luxe.structures.BinarySearchTree.T"/>
	</c>
	<c path="luxe.structures.BinarySearchTree.K"/>
	<c path="luxe.structures.BinarySearchTreeNode">
		<c path="luxe.structures.BinarySearchTree.K"/>
		<c path="luxe.structures.BinarySearchTree.T"/>
	</c>
</f></_remove>
		<remove public="1" set="method" line="237"><f a="_key">
	<c path="luxe.structures.BinarySearchTree.K"/>
	<x path="Void"/>
</f></remove>
		<_deleteMax set="method" line="224"><f a="_node">
	<c path="luxe.structures.BinarySearchTreeNode">
		<c path="luxe.structures.BinarySearchTree.K"/>
		<c path="luxe.structures.BinarySearchTree.T"/>
	</c>
	<c path="luxe.structures.BinarySearchTreeNode">
		<c path="luxe.structures.BinarySearchTree.K"/>
		<c path="luxe.structures.BinarySearchTree.T"/>
	</c>
</f></_deleteMax>
		<deleteMax public="1" set="method" line="220"><f a=""><x path="Void"/></f></deleteMax>
		<_deleteMin set="method" line="207"><f a="_node">
	<c path="luxe.structures.BinarySearchTreeNode">
		<c path="luxe.structures.BinarySearchTree.K"/>
		<c path="luxe.structures.BinarySearchTree.T"/>
	</c>
	<c path="luxe.structures.BinarySearchTreeNode">
		<c path="luxe.structures.BinarySearchTree.K"/>
		<c path="luxe.structures.BinarySearchTree.T"/>
	</c>
</f></_deleteMin>
		<deleteMin public="1" set="method" line="203"><f a=""><x path="Void"/></f></deleteMin>
		<_ceil set="method" line="184"><f a="_node:_key">
	<c path="luxe.structures.BinarySearchTreeNode">
		<c path="luxe.structures.BinarySearchTree.K"/>
		<c path="luxe.structures.BinarySearchTree.T"/>
	</c>
	<c path="luxe.structures.BinarySearchTree.K"/>
	<c path="luxe.structures.BinarySearchTreeNode">
		<c path="luxe.structures.BinarySearchTree.K"/>
		<c path="luxe.structures.BinarySearchTree.T"/>
	</c>
</f></_ceil>
		<ceil public="1" set="method" line="175"><f a="_key">
	<c path="luxe.structures.BinarySearchTree.K"/>
	<t path="Null"><c path="luxe.structures.BinarySearchTree.K"/></t>
</f></ceil>
		<_floor set="method" line="157"><f a="_node:_key">
	<c path="luxe.structures.BinarySearchTreeNode">
		<c path="luxe.structures.BinarySearchTree.K"/>
		<c path="luxe.structures.BinarySearchTree.T"/>
	</c>
	<c path="luxe.structures.BinarySearchTree.K"/>
	<c path="luxe.structures.BinarySearchTreeNode">
		<c path="luxe.structures.BinarySearchTree.K"/>
		<c path="luxe.structures.BinarySearchTree.T"/>
	</c>
</f></_floor>
		<floor public="1" set="method" line="148"><f a="_key">
	<c path="luxe.structures.BinarySearchTree.K"/>
	<t path="Null"><c path="luxe.structures.BinarySearchTree.K"/></t>
</f></floor>
		<_max set="method" line="140"><f a="_node">
	<c path="luxe.structures.BinarySearchTreeNode">
		<c path="luxe.structures.BinarySearchTree.K"/>
		<c path="luxe.structures.BinarySearchTree.T"/>
	</c>
	<c path="luxe.structures.BinarySearchTreeNode">
		<c path="luxe.structures.BinarySearchTree.K"/>
		<c path="luxe.structures.BinarySearchTree.T"/>
	</c>
</f></_max>
		<max public="1" set="method" line="136"><f a=""><c path="luxe.structures.BinarySearchTree.K"/></f></max>
		<_min public="1" set="method" line="131"><f a="_node">
	<c path="luxe.structures.BinarySearchTreeNode">
		<c path="luxe.structures.BinarySearchTree.K"/>
		<c path="luxe.structures.BinarySearchTree.T"/>
	</c>
	<c path="luxe.structures.BinarySearchTreeNode">
		<c path="luxe.structures.BinarySearchTree.K"/>
		<c path="luxe.structures.BinarySearchTree.T"/>
	</c>
</f></_min>
		<min public="1" set="method" line="127"><f a=""><c path="luxe.structures.BinarySearchTree.K"/></f></min>
		<_select set="method" line="110"><f a="_node:_rank">
	<c path="luxe.structures.BinarySearchTreeNode">
		<c path="luxe.structures.BinarySearchTree.K"/>
		<c path="luxe.structures.BinarySearchTree.T"/>
	</c>
	<x path="Int"/>
	<c path="luxe.structures.BinarySearchTreeNode">
		<c path="luxe.structures.BinarySearchTree.K"/>
		<c path="luxe.structures.BinarySearchTree.T"/>
	</c>
</f></_select>
		<select public="1" set="method" line="106"><f a="_rank">
	<x path="Int"/>
	<c path="luxe.structures.BinarySearchTree.K"/>
</f></select>
		<_rank set="method" line="91"><f a="_key:_node">
	<c path="luxe.structures.BinarySearchTree.K"/>
	<c path="luxe.structures.BinarySearchTreeNode">
		<c path="luxe.structures.BinarySearchTree.K"/>
		<c path="luxe.structures.BinarySearchTree.T"/>
	</c>
	<x path="Int"/>
</f></_rank>
		<rank public="1" set="method" line="87"><f a="_key">
	<c path="luxe.structures.BinarySearchTree.K"/>
	<x path="Int"/>
</f></rank>
		<_find set="method" line="68"><f a="_node:_key">
	<c path="luxe.structures.BinarySearchTreeNode">
		<c path="luxe.structures.BinarySearchTree.K"/>
		<c path="luxe.structures.BinarySearchTree.T"/>
	</c>
	<c path="luxe.structures.BinarySearchTree.K"/>
	<c path="luxe.structures.BinarySearchTree.T"/>
</f></_find>
		<find public="1" set="method" line="64"><f a="_key">
	<c path="luxe.structures.BinarySearchTree.K"/>
	<c path="luxe.structures.BinarySearchTree.T"/>
</f></find>
		<contains public="1" set="method" line="59"><f a="_key">
	<c path="luxe.structures.BinarySearchTree.K"/>
	<x path="Bool"/>
</f></contains>
		<_insert set="method" line="36"><f a="_node:_key:_value">
	<c path="luxe.structures.BinarySearchTreeNode">
		<c path="luxe.structures.BinarySearchTree.K"/>
		<c path="luxe.structures.BinarySearchTree.T"/>
	</c>
	<c path="luxe.structures.BinarySearchTree.K"/>
	<c path="luxe.structures.BinarySearchTree.T"/>
	<c path="luxe.structures.BinarySearchTreeNode">
		<c path="luxe.structures.BinarySearchTree.K"/>
		<c path="luxe.structures.BinarySearchTree.T"/>
	</c>
</f></_insert>
		<insert public="1" set="method" line="32"><f a="_key:_value">
	<c path="luxe.structures.BinarySearchTree.K"/>
	<c path="luxe.structures.BinarySearchTree.T"/>
	<x path="Void"/>
</f></insert>
		<_size set="method" line="23"><f a="_node">
	<c path="luxe.structures.BinarySearchTreeNode">
		<c path="luxe.structures.BinarySearchTree.K"/>
		<c path="luxe.structures.BinarySearchTree.T"/>
	</c>
	<x path="Int"/>
</f></_size>
		<size public="1" set="method" line="18"><f a=""><x path="Int"/></f></size>
		<toString public="1" set="method" line="12"><f a=""><c path="String"/></f></toString>
		<compare public="1"><f a=":">
	<c path="luxe.structures.BinarySearchTree.K"/>
	<c path="luxe.structures.BinarySearchTree.K"/>
	<x path="Int"/>
</f></compare>
		<root public="1"><c path="luxe.structures.BinarySearchTreeNode">
	<c path="luxe.structures.BinarySearchTree.K"/>
	<c path="luxe.structures.BinarySearchTree.T"/>
</c></root>
		<new public="1" set="method" line="8"><f a="compare_function">
	<f a=":">
		<c path="luxe.structures.BinarySearchTree.K"/>
		<c path="luxe.structures.BinarySearchTree.K"/>
		<x path="Int"/>
	</f>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.structures.BinarySearchTreeNode" params="K:T" file="/Users/Sven/dev/lab/luxe/luxe/structures/BinarySearchTree.hx" module="luxe.structures.BinarySearchTree">
		<value public="1"><c path="luxe.structures.BinarySearchTreeNode.T"/></value>
		<key public="1"><c path="luxe.structures.BinarySearchTreeNode.K"/></key>
		<nodecount public="1"><x path="Int"/></nodecount>
		<right public="1"><c path="luxe.structures.BinarySearchTreeNode">
	<c path="luxe.structures.BinarySearchTreeNode.K"/>
	<c path="luxe.structures.BinarySearchTreeNode.T"/>
</c></right>
		<left public="1"><c path="luxe.structures.BinarySearchTreeNode">
	<c path="luxe.structures.BinarySearchTreeNode.K"/>
	<c path="luxe.structures.BinarySearchTreeNode.T"/>
</c></left>
		<new public="1" set="method" line="349"><f a="_key:_value:_nodecount">
	<c path="luxe.structures.BinarySearchTreeNode.K"/>
	<c path="luxe.structures.BinarySearchTreeNode.T"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="luxe.structures.BinarySearchTraverseMethod" params="" file="/Users/Sven/dev/lab/luxe/luxe/structures/BinarySearchTree.hx" module="luxe.structures.BinarySearchTree">
		<PreOrder/>
		<PostOrder/>
		<InOrder/>
	</enum>
	<class path="luxe.tween.actuators.IGenericActuator" params="" file="/Users/Sven/dev/lab/luxe/luxe/tween/actuators/GenericActuator.hx" module="luxe.tween.actuators.GenericActuator" interface="1">
		<snapping public="1" set="method">
			<f a="?value">
				<x path="Bool"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Snapping causes tween values to be rounded automatically
	 * @param	value		Whether tween values should be rounded (Default is true)
	 * @return		The current actuator instance</haxe_doc>
		</snapping>
		<smartRotation public="1" set="method">
			<f a="?value">
				<x path="Bool"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Enabling smartRotation can prevent undesired results when tweening rotation values
	 * @param	value		Whether smart rotation should be enabled (Default is true)
	 * @return		The current actuator instance</haxe_doc>
		</smartRotation>
		<reverse public="1" set="method">
			<f a="?value">
				<x path="Bool"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Sets if the tween should be handled in reverse
	 * @param	value		Whether the tween should be reversed (Default is true)
	 * @return		The current actuator instance</haxe_doc>
		</reverse>
		<repeat public="1" set="method">
			<f a="?times">
				<x path="Int"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Repeats the tween after it finishes
	 * @param	times		The number of times you would like the tween to repeat, or -1 if you would like to repeat the tween indefinitely (Default is -1)
	 * @return		The current actuator instance</haxe_doc>
		</repeat>
		<reflect public="1" set="method">
			<f a="?value">
				<x path="Bool"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Automatically changes the reverse value when the tween repeats. Repeat must be enabled for this to have any effect
	 * @param	value		Whether reflect should be enabled (Default is true)
	 * @return		The current actuator instance</haxe_doc>
		</reflect>
		<onUpdate public="1" set="method">
			<f a="handler:?parameters">
				<d/>
				<c path="Array"><d/></c>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Defines a function which will be called when the tween updates
	 * @param	handler		The function you would like to be called
	 * @param	parameters		Parameters you would like to pass to the handler function when it is called
	 * @return		The current actuator instance</haxe_doc>
		</onUpdate>
		<onRepeat public="1" set="method">
			<f a="handler:?parameters">
				<d/>
				<c path="Array"><d/></c>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Defines a function which will be called when the tween repeats
	 * @param	handler		The function you would like to be called
	 * @param	parameters		Parameters you would like to pass to the handler function when it is called
	 * @return		The current actuator instance</haxe_doc>
		</onRepeat>
		<onComplete public="1" set="method">
			<f a="handler:?parameters">
				<d/>
				<c path="Array"><d/></c>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Defines a function which will be called when the tween finishes
	 * @param	handler		The function you would like to be called
	 * @param	parameters		Parameters you would like to pass to the handler function when it is called
	 * @return		The current actuator instance</haxe_doc>
		</onComplete>
		<ease public="1" set="method">
			<f a="easing">
				<c path="luxe.tween.easing.IEasing"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Sets the easing which is used when running the tween
	 * @param	easing		An easing equation, like Elastic.easeIn or Quad.easeOut
	 * @return		The current actuator instance</haxe_doc>
		</ease>
		<delay public="1" set="method">
			<f a="duration">
				<x path="Float"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Increases the delay before a tween is executed
	 * @param	duration		The amount of seconds to delay
	 * @return		The current actuator instance</haxe_doc>
		</delay>
		<autoVisible public="1" set="method">
			<f a="?value">
				<x path="Bool"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Flash performs faster when objects are set to visible = false rather than only alpha = 0. autoVisible toggles automatically based on alpha values
	 * @param	value		Whether autoVisible should be enabled (Default is true)
	 * @return		The current actuator instance</haxe_doc>
		</autoVisible>
	</class>
	<class path="luxe.tween.actuators.GenericActuator" params="" file="/Users/Sven/dev/lab/luxe/luxe/tween/actuators/GenericActuator.hx">
		<implements path="luxe.tween.actuators.IGenericActuator"/>
		<stop public="1" set="method" line="380"><f a="properties:complete:sendEvent">
	<d/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></stop>
		<snapping public="1" set="method" line="364">
			<f a="?value">
				<x path="Bool"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Snapping causes tween values to be rounded automatically
	 * @param	value		Whether tween values should be rounded (Default is true)
	 * @return		The current actuator instance</haxe_doc>
		</snapping>
		<smartRotation public="1" set="method" line="343">
			<f a="?value">
				<x path="Bool"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Enabling smartRotation can prevent undesired results when tweening rotation values
	 * @param	value		Whether smart rotation should be enabled (Default is true)
	 * @return		The current actuator instance</haxe_doc>
		</smartRotation>
		<reverse public="1" set="method" line="322">
			<f a="?value">
				<x path="Bool"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Sets if the tween should be handled in reverse
	 * @param	value		Whether the tween should be reversed (Default is true)
	 * @return		The current actuator instance</haxe_doc>
		</reverse>
		<resume public="1" set="method" line="310"><f a=""><x path="Void"/></f></resume>
		<repeat public="1" set="method" line="295">
			<f a="?times">
				<x path="Int"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Repeats the tween after it finishes
	 * @param	times		The number of times you would like the tween to repeat, or -1 if you would like to repeat the tween indefinitely (Default is -1)
	 * @return		The current actuator instance</haxe_doc>
		</repeat>
		<reflect public="1" set="method" line="274">
			<f a="?value">
				<x path="Bool"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Automatically changes the reverse value when the tween repeats. Repeat must be enabled for this to have any effect
	 * @param	value		Whether reflect should be enabled (Default is true)
	 * @return		The current actuator instance</haxe_doc>
		</reflect>
		<pause public="1" set="method" line="262"><f a=""><x path="Void"/></f></pause>
		<onUpdate public="1" set="method" line="243">
			<f a="handler:?parameters">
				<d/>
				<c path="Array"><d/></c>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Defines a function which will be called when the tween updates
	 * @param	handler		The function you would like to be called
	 * @param	parameters		Parameters you would like to pass to the handler function when it is called
	 * @return		The current actuator instance</haxe_doc>
		</onUpdate>
		<onRepeat public="1" set="method" line="218">
			<f a="handler:?parameters">
				<d/>
				<c path="Array"><d/></c>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Defines a function which will be called when the tween repeats
	 * @param	handler		The function you would like to be called
	 * @param	parameters		Parameters you would like to pass to the handler function when it is called
	 * @return		The current actuator instance</haxe_doc>
		</onRepeat>
		<onComplete public="1" set="method" line="187">
			<f a="handler:?parameters">
				<d/>
				<c path="Array"><d/></c>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Defines a function which will be called when the tween finishes
	 * @param	handler		The function you would like to be called
	 * @param	parameters		Parameters you would like to pass to the handler function when it is called
	 * @return		The current actuator instance</haxe_doc>
		</onComplete>
		<move public="1" set="method" line="174"><f a=""><x path="Void"/></f></move>
		<ease public="1" set="method" line="165">
			<f a="easing">
				<c path="luxe.tween.easing.IEasing"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Sets the easing which is used when running the tween
	 * @param	easing		An easing equation, like Elastic.easeIn or Quad.easeOut
	 * @return		The current actuator instance</haxe_doc>
		</ease>
		<delay public="1" set="method" line="151">
			<f a="duration">
				<x path="Float"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Increases the delay before a tween is executed
	 * @param	duration		The amount of seconds to delay
	 * @return		The current actuator instance</haxe_doc>
		</delay>
		<complete set="method" line="118"><f a="?sendEvent">
	<x path="Bool"/>
	<x path="Void"/>
</f></complete>
		<change set="method" line="98"><f a=""><x path="Void"/></f></change>
		<autoVisible public="1" set="method" line="83">
			<f a="?value">
				<x path="Bool"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* sometimes drawing performs faster when objects are set to visible = false rather than only alpha = 0. autoVisible toggles automatically based on alpha values
	 * @param	value		Whether autoVisible should be enabled (Default is true)
	 * @return		The current actuator instance</haxe_doc>
		</autoVisible>
		<apply public="1" set="method" line="59"><f a=""><x path="Void"/></f></apply>
		<special><x path="Bool"/></special>
		<_snapping><x path="Bool"/></_snapping>
		<_smartRotation><x path="Bool"/></_smartRotation>
		<_reverse><x path="Bool"/></_reverse>
		<_repeat><x path="Int"/></_repeat>
		<_reflect><x path="Bool"/></_reflect>
		<_onUpdateParams><c path="Array"><d/></c></_onUpdateParams>
		<_onUpdate><d/></_onUpdate>
		<_onRepeatParams><c path="Array"><d/></c></_onRepeatParams>
		<_onRepeat><d/></_onRepeat>
		<_onCompleteParams><c path="Array"><d/></c></_onCompleteParams>
		<_onComplete><d/></_onComplete>
		<_ease><c path="luxe.tween.easing.IEasing"/></_ease>
		<_delay><x path="Float"/></_delay>
		<_autoVisible><x path="Bool"/></_autoVisible>
		<target public="1"><d/></target>
		<properties public="1"><d/></properties>
		<id public="1"><c path="String"/></id>
		<duration public="1"><x path="Float"/></duration>
		<new public="1" set="method" line="39"><f a="target:duration:properties">
	<d/>
	<x path="Float"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.tween.actuators.SimpleActuator" params="" file="/Users/Sven/dev/lab/luxe/luxe/tween/actuators/SimpleActuator.hx">
		<extends path="luxe.tween.actuators.GenericActuator"/>
		<actuators line="22" static="1"><c path="Array"><c path="luxe.tween.actuators.SimpleActuator"/></c></actuators>
		<actuatorsLength line="23" static="1"><x path="Int"/></actuatorsLength>
		<addedEvent line="24" static="1"><x path="Bool"/></addedEvent>
		<timer static="1"><c path="haxe.Timer"/></timer>
		<on_internal_update set="method" line="423" static="1"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></on_internal_update>
		<update set="method" line="269"><f a="currentTime">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<stop public="1" set="method" line="226" override="1"><f a="properties:complete:sendEvent">
	<d/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></stop>
		<setField get="inline" set="null" line="203"><f a="details:value">
	<c path="luxe.tween.actuators.PropertyDetails"/>
	<d/>
	<x path="Void"/>
</f></setField>
		<resume public="1" set="method" line="190" override="1"><f a=""><x path="Void"/></f></resume>
		<pause public="1" set="method" line="181" override="1"><f a=""><x path="Void"/></f></pause>
		<onUpdate public="1" set="method" line="170" override="1">
			<f a="handler:?parameters">
				<d/>
				<c path="Array"><d/></c>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</onUpdate>
		<move public="1" set="method" line="148" override="1"><f a=""><x path="Void"/></f></move>
		<initialize set="method" line="109"><f a=""><x path="Void"/></f></initialize>
		<delay public="1" set="method" line="99" override="1">
			<f a="duration">
				<x path="Float"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</delay>
		<autoVisible public="1" set="method" line="69" override="1">
			<f a="?value">
				<x path="Bool"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</autoVisible>
		<toggleVisible><x path="Bool"/></toggleVisible>
		<startTime><x path="Float"/></startTime>
		<setVisible><x path="Bool"/></setVisible>
		<sendChange><x path="Bool"/></sendChange>
		<propertyDetails><c path="Array"><c path="luxe.tween.actuators.PropertyDetails"/></c></propertyDetails>
		<pauseTime><x path="Float"/></pauseTime>
		<paused><x path="Bool"/></paused>
		<initialized><x path="Bool"/></initialized>
		<detailsLength><x path="Int"/></detailsLength>
		<cacheVisible><x path="Bool"/></cacheVisible>
		<active><x path="Bool"/></active>
		<timeOffset><x path="Float"/></timeOffset>
		<new public="1" set="method" line="41"><f a="target:duration:properties">
	<d/>
	<x path="Float"/>
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* @author Joshua Granick
 * @version 1.2</haxe_doc>
	</class>
	<class path="luxe.tween.easing.Expo" params="" file="/Users/Sven/dev/lab/luxe/luxe/tween/easing/Expo.hx">
		<easeIn public="1" get="accessor" set="null" static="1"><c path="luxe.tween.easing.IEasing"/></easeIn>
		<easeInOut public="1" get="accessor" set="null" static="1"><c path="luxe.tween.easing.IEasing"/></easeInOut>
		<easeOut public="1" get="accessor" set="null" static="1"><c path="luxe.tween.easing.IEasing"/></easeOut>
		<get_easeIn set="method" line="19" static="1"><f a=""><c path="luxe.tween.easing.IEasing"/></f></get_easeIn>
		<get_easeInOut set="method" line="26" static="1"><f a=""><c path="luxe.tween.easing.IEasing"/></f></get_easeInOut>
		<get_easeOut set="method" line="33" static="1"><f a=""><c path="luxe.tween.easing.IEasing"/></f></get_easeOut>
	</class>
	<class path="luxe.tween.easing.IEasing" params="" file="/Users/Sven/dev/lab/luxe/luxe/tween/easing/IEasing.hx" interface="1">
		<ease public="1" set="method"><f a="t:b:c:d">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></ease>
		<calculate public="1" set="method"><f a="k">
	<x path="Float"/>
	<x path="Float"/>
</f></calculate>
		<haxe_doc>* @author Joshua Granick
 * @author Philippe / http://philippe.elsass.me</haxe_doc>
	</class>
	<class path="luxe.tween.easing.ExpoEaseOut" params="" file="/Users/Sven/dev/lab/luxe/luxe/tween/easing/Expo.hx" module="luxe.tween.easing.Expo">
		<implements path="luxe.tween.easing.IEasing"/>
		<ease public="1" set="method" line="128"><f a="t:b:c:d">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></ease>
		<calculate public="1" set="method" line="121"><f a="k">
	<x path="Float"/>
	<x path="Float"/>
</f></calculate>
		<new public="1" set="method" line="114"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="luxe.tween.Actuate" params="" file="/Users/Sven/dev/lab/luxe/luxe/tween/Actuate.hx">
		<defaultActuator public="1" line="17" static="1"><x path="Class"><c path="luxe.tween.actuators.GenericActuator"/></x></defaultActuator>
		<defaultEase public="1" line="18" static="1"><c path="luxe.tween.easing.IEasing"/></defaultEase>
		<targetLibraries line="19" static="1"><t path="luxe.tween.ObjectHash"><c path="Array"><c path="luxe.tween.actuators.GenericActuator"/></c></t></targetLibraries>
		<apply public="1" set="method" line="30" static="1">
			<f a="target:properties:?customActuator">
				<d/>
				<d/>
				<x path="Class"><c path="luxe.tween.actuators.GenericActuator"/></x>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc><![CDATA[* Copies properties from one object to another. Conflicting tweens are stopped automatically
	 * @example		<code>Actuate.apply (MyClip, { alpha: 1 } );</code>
	 * @param	target		The object to copy to
	 * @param	properties		The object to copy from
	 * @param	customActuator		A custom actuator to use instead of the default (Optional)
	 * @return		The current actuator instance, which can be used to apply properties like onComplete or onUpdate handlers]]></haxe_doc>
		</apply>
		<getLibrary set="method" line="47" static="1"><f a="target">
	<d/>
	<c path="Array"><c path="luxe.tween.actuators.GenericActuator"/></c>
</f></getLibrary>
		<motionPath public="1" set="method" line="68" static="1">
			<f a="target:duration:properties:?overwrite">
				<d/>
				<x path="Float"/>
				<d/>
				<x path="Bool"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Creates a new MotionPath tween
	 * @param	target		The object to tween
	 * @param	duration		The length of the tween in seconds
	 * @param	properties		An object containing a motion path for each property you wish to tween
	 * @param	overwrite		Sets whether previous tweens for the same target and properties will be overwritten (Default is true)
	 * @return		The current actuator instance, which can be used to apply properties like ease, delay, onComplete or onUpdate</haxe_doc>
		</motionPath>
		<pause public="1" set="method" line="80" static="1">
			<f a="target">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Pauses tweens for the specified target objects
	 * @param	... targets		The target objects which will have their tweens paused. Passing no value pauses tweens for all objects</haxe_doc>
		</pause>
		<pauseAll public="1" set="method" line="101" static="1"><f a=""><x path="Void"/></f></pauseAll>
		<reset public="1" set="method" line="119" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets Actuate by stopping and removing tweens for all objects</haxe_doc>
		</reset>
		<resume public="1" set="method" line="140" static="1">
			<f a="target">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Resumes paused tweens for the specified target objects
	 * @param	... targets		The target objects which will have their tweens resumed. Passing no value resumes tweens for all objects</haxe_doc>
		</resume>
		<resumeAll public="1" set="method" line="161" static="1"><f a=""><x path="Void"/></f></resumeAll>
		<stop public="1" set="method" line="183" static="1">
			<f a="target:?properties:?complete:?sendEvent">
				<d/>
				<d/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Stops all tweens for an individual object
	 * @param	target		The target object which will have its tweens stopped, or a generic actuator instance
	 * @param	properties		A string, array or object which contains the properties you wish to stop, like "alpha", [ "x", "y" ] or { alpha: null }. Passing no value removes all tweens for the object (Optional)
	 * @param	complete		If tweens should apply their final target values before stopping. Default is false (Optional) 
	 * @param	sendEvent	If a complete() event should be dispatched for the specified target. Default is true (Optional)</haxe_doc>
		</stop>
		<timer public="1" set="method" line="235" static="1">
			<f a="duration:?customActuator">
				<x path="Float"/>
				<x path="Class"><c path="luxe.tween.actuators.GenericActuator"/></x>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc><![CDATA[* Creates a tween-based timer, which is useful for synchronizing function calls with other animations
	 * @example		<code>Actuate.timer (1).onComplete (trace, [ "Timer is now complete" ]);</code>
	 * @param	duration		The length of the timer in seconds
	 * @param	customActuator		A custom actuator to use instead of the default (Optional)
	 * @return		The current actuator instance, which can be used to apply properties like onComplete or to gain a reference to the target timer object]]></haxe_doc>
		</timer>
		<tween public="1" set="method" line="252" static="1">
			<f a="target:duration:properties:?overwrite:?customActuator">
				<d/>
				<x path="Float"/>
				<d/>
				<x path="Bool"/>
				<x path="Class"><c path="luxe.tween.actuators.GenericActuator"/></x>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new tween
	 * @example		<code>Actuate.tween (MyClip, 1, { alpha: 1 } ).onComplete (trace, [ "MyClip is now visible" ]);</code>
	 * @param	target		The object to tween
	 * @param	duration		The length of the tween in seconds
	 * @param	properties		The end values to tween the target to
	 * @param	overwrite			Sets whether previous tweens for the same target and properties will be overwritten (Default is true)
	 * @param	customActuator		A custom actuator to use instead of the default (Optional)
	 * @return		The current actuator instance, which can be used to apply properties like ease, delay, onComplete or onUpdate]]></haxe_doc>
		</tween>
		<unload public="1" set="method" line="309" static="1"><f a="actuator">
	<c path="luxe.tween.actuators.GenericActuator"/>
	<x path="Void"/>
</f></unload>
		<update public="1" set="method" line="338" static="1">
			<f a="target:duration:?start:?end:?overwrite">
				<d/>
				<x path="Float"/>
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
				<x path="Bool"/>
				<c path="luxe.tween.actuators.IGenericActuator"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new tween that updates a method rather than setting the properties of an object
	 * @example		<code>Actuate.update (trace, 1, ["Value: ", 0], ["", 1]).onComplete (trace, [ "Finished tracing values between 0 and 1" ]);</code>
	 * @param	target		The method to update		
	 * @param	duration		The length of the tween in seconds
	 * @param	start		The starting parameters of the method call. You may use both numeric and non-numeric values
	 * @param	end		The ending parameters of the method call. You may use both numeric and non-numeric values, but the signature should match the start parameters
	 * @param	overwrite		Sets whether previous tweens for the same target and properties will be overwritten (Default is true)
	 * @return		The current actuator instance, which can be used to apply properties like ease, delay, onComplete or onUpdate]]></haxe_doc>
		</update>
	</class>
	<class path="luxe.tween._Actuate.TweenTimer" params="" file="/Users/Sven/dev/lab/luxe/luxe/tween/Actuate.hx" private="1" module="luxe.tween.Actuate">
		<progress public="1"><x path="Float"/></progress>
		<new public="1" set="method" line="357"><f a="progress">
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="luxe.tween.ObjectHash" params="T" file="/Users/Sven/dev/lab/luxe/luxe/tween/Actuate.hx" module="luxe.tween.Actuate"><c path="haxe.ds.ObjectMap">
	<d/>
	<c path="luxe.tween.ObjectHash.T"/>
</c></typedef>
	<class path="luxe.tween.MotionPath" params="" file="/Users/Sven/dev/lab/luxe/luxe/tween/MotionPath.hx">
		<get_y set="method" line="75"><f a=""><c path="luxe.tween.IComponentPath"/></f></get_y>
		<get_x set="method" line="68"><f a=""><c path="luxe.tween.IComponentPath"/></f></get_x>
		<line public="1" set="method" line="51">
			<f a="x:y:?strength">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="luxe.tween.MotionPath"/>
			</f>
			<haxe_doc>* Adds a line to the current motion path
	 * @param	x		The x position of the end point for the line
	 * @param	x		The y position of the end point for the line
	 * @param	strength		The degree of emphasis that should be placed on this segment . If a motion path contains multiple segments with the same strength, they all receive equal emphasis (Default is 1)
	 * @return		The current motion path instance</haxe_doc>
		</line>
		<bezier public="1" set="method" line="34">
			<f a="x:y:controlX:controlY:?strength">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="luxe.tween.MotionPath"/>
			</f>
			<haxe_doc>* Adds a bezier curve to the current motion path
	 * @param	x		The x position of the end point for the curve
	 * @param	y		The y position of the end point for the curve
	 * @param	controlX		The x position of the control point for the curve, which affects the angle and midpoint
	 * @param	controlX		The x position of the control point for the curve, which affects the angle and midpoint
	 * @param	strength		The degree of emphasis that should be placed on this segment. If a motion path contains multiple segments with the same strength, they all receive equal emphasis (Default is 1)
	 * @return		The current motion path instance</haxe_doc>
		</bezier>
		<_y><c path="luxe.tween.ComponentPath"/></_y>
		<_x><c path="luxe.tween.ComponentPath"/></_x>
		<y public="1" get="accessor" set="null"><c path="luxe.tween.IComponentPath"/></y>
		<x public="1" get="accessor" set="null"><c path="luxe.tween.IComponentPath"/></x>
		<new public="1" set="method" line="17"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* @author Joshua Granick</haxe_doc>
	</class>
	<class path="luxe.tween.IComponentPath" params="" file="/Users/Sven/dev/lab/luxe/luxe/tween/MotionPath.hx" module="luxe.tween.MotionPath" interface="1">
		<calculate public="1" set="method"><f a="k">
	<x path="Float"/>
	<x path="Float"/>
</f></calculate>
		<start public="1"><x path="Float"/></start>
		<end public="1" get="null" set="null"><x path="Float"/></end>
	</class>
	<class path="luxe.tween.ComponentPath" params="" file="/Users/Sven/dev/lab/luxe/luxe/tween/MotionPath.hx" module="luxe.tween.MotionPath">
		<implements path="luxe.tween.IComponentPath"/>
		<get_end set="method" line="151"><f a=""><x path="Float"/></f></get_end>
		<calculate public="1" set="method" line="112"><f a="k">
	<x path="Float"/>
	<x path="Float"/>
</f></calculate>
		<addPath public="1" set="method" line="104"><f a="path">
	<c path="luxe.tween.BezierPath"/>
	<x path="Void"/>
</f></addPath>
		<totalStrength><x path="Float"/></totalStrength>
		<paths><c path="Array"><c path="luxe.tween.BezierPath"/></c></paths>
		<end public="1" get="accessor" set="null"><x path="Float"/></end>
		<start public="1"><x path="Float"/></start>
		<new public="1" set="method" line="95"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="luxe.tween.BezierPath" params="" file="/Users/Sven/dev/lab/luxe/luxe/tween/MotionPath.hx" module="luxe.tween.MotionPath">
		<calculate public="1" set="method" line="201"><f a="start:k">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></calculate>
		<strength public="1"><x path="Float"/></strength>
		<end public="1"><x path="Float"/></end>
		<control public="1"><x path="Float"/></control>
		<new public="1" set="method" line="192"><f a="end:control:strength">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.tween.LinearPath" params="" file="/Users/Sven/dev/lab/luxe/luxe/tween/MotionPath.hx" module="luxe.tween.MotionPath">
		<extends path="luxe.tween.BezierPath"/>
		<calculate public="1" set="method" line="221" override="1"><f a="start:k">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></calculate>
		<new public="1" set="method" line="214"><f a="end:strength">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.tween.actuators.MethodActuator" params="" file="/Users/Sven/dev/lab/luxe/luxe/tween/actuators/MethodActuator.hx">
		<extends path="luxe.tween.actuators.SimpleActuator"/>
		<update set="method" line="109" override="1"><f a="currentTime">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<initialize set="method" line="81" override="1"><f a=""><x path="Void"/></f></initialize>
		<complete set="method" line="58" override="1"><f a="?sendEvent">
	<x path="Bool"/>
	<x path="Void"/>
</f></complete>
		<apply public="1" set="method" line="43" override="1"><f a=""><x path="Void"/></f></apply>
		<tweenProperties><d/></tweenProperties>
		<currentParameters><c path="Array"><d/></c></currentParameters>
		<new public="1" set="method" line="15"><f a="target:duration:properties">
	<d/>
	<x path="Float"/>
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* @author Joshua Granick
 * @version 1.2</haxe_doc>
	</class>
	<class path="luxe.tween.actuators.MotionPathActuator" params="" file="/Users/Sven/dev/lab/luxe/luxe/tween/actuators/MotionPathActuator.hx">
		<extends path="luxe.tween.actuators.SimpleActuator"/>
		<update set="method" line="77" override="1"><f a="currentTime">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<initialize set="method" line="39" override="1"><f a=""><x path="Void"/></f></initialize>
		<apply public="1" set="method" line="20" override="1"><f a=""><x path="Void"/></f></apply>
		<new public="1" set="method" line="13"><f a="target:duration:properties">
	<d/>
	<x path="Float"/>
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* @author Joshua Granick</haxe_doc>
	</class>
	<class path="luxe.tween.actuators.PropertyDetails" params="" file="/Users/Sven/dev/lab/luxe/luxe/tween/actuators/PropertyDetails.hx">
		<target public="1"><d/></target>
		<start public="1"><x path="Float"/></start>
		<propertyName public="1"><c path="String"/></propertyName>
		<isField public="1"><x path="Bool"/></isField>
		<change public="1"><x path="Float"/></change>
		<new public="1" set="method" line="19"><f a="target:propertyName:start:change:?isField">
	<d/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.tween.actuators.PropertyPathDetails" params="" file="/Users/Sven/dev/lab/luxe/luxe/tween/actuators/MotionPathActuator.hx" module="luxe.tween.actuators.MotionPathActuator">
		<extends path="luxe.tween.actuators.PropertyDetails"/>
		<path public="1"><c path="luxe.tween.IComponentPath"/></path>
		<new public="1" set="method" line="224"><f a="target:propertyName:path:?isField">
	<d/>
	<c path="String"/>
	<c path="luxe.tween.IComponentPath"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.tween.easing.ExpoEaseIn" params="" file="/Users/Sven/dev/lab/luxe/luxe/tween/easing/Expo.hx" module="luxe.tween.easing.Expo">
		<implements path="luxe.tween.easing.IEasing"/>
		<ease public="1" set="method" line="60"><f a="t:b:c:d">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></ease>
		<calculate public="1" set="method" line="53"><f a="k">
	<x path="Float"/>
	<x path="Float"/>
</f></calculate>
		<new public="1" set="method" line="46"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="luxe.tween.easing.ExpoEaseInOut" params="" file="/Users/Sven/dev/lab/luxe/luxe/tween/easing/Expo.hx" module="luxe.tween.easing.Expo">
		<implements path="luxe.tween.easing.IEasing"/>
		<ease public="1" set="method" line="92"><f a="t:b:c:d">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></ease>
		<calculate public="1" set="method" line="80"><f a="k">
	<x path="Float"/>
	<x path="Float"/>
</f></calculate>
		<new public="1" set="method" line="73"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="luxe.tween.easing.Quad" params="" file="/Users/Sven/dev/lab/luxe/luxe/tween/easing/Quad.hx">
		<easeIn public="1" get="accessor" set="null" static="1"><c path="luxe.tween.easing.IEasing"/></easeIn>
		<easeInOut public="1" get="accessor" set="null" static="1"><c path="luxe.tween.easing.IEasing"/></easeInOut>
		<easeOut public="1" get="accessor" set="null" static="1"><c path="luxe.tween.easing.IEasing"/></easeOut>
		<get_easeIn set="method" line="19" static="1"><f a=""><c path="luxe.tween.easing.IEasing"/></f></get_easeIn>
		<get_easeInOut set="method" line="26" static="1"><f a=""><c path="luxe.tween.easing.IEasing"/></f></get_easeInOut>
		<get_easeOut set="method" line="33" static="1"><f a=""><c path="luxe.tween.easing.IEasing"/></f></get_easeOut>
	</class>
	<class path="luxe.tween.easing.QuadEaseIn" params="" file="/Users/Sven/dev/lab/luxe/luxe/tween/easing/Quad.hx" module="luxe.tween.easing.Quad">
		<implements path="luxe.tween.easing.IEasing"/>
		<ease public="1" set="method" line="60"><f a="t:b:c:d">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></ease>
		<calculate public="1" set="method" line="53"><f a="k">
	<x path="Float"/>
	<x path="Float"/>
</f></calculate>
		<new public="1" set="method" line="46"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="luxe.tween.easing.QuadEaseInOut" params="" file="/Users/Sven/dev/lab/luxe/luxe/tween/easing/Quad.hx" module="luxe.tween.easing.Quad">
		<implements path="luxe.tween.easing.IEasing"/>
		<ease public="1" set="method" line="90"><f a="t:b:c:d">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></ease>
		<calculate public="1" set="method" line="80"><f a="k">
	<x path="Float"/>
	<x path="Float"/>
</f></calculate>
		<new public="1" set="method" line="73"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="luxe.tween.easing.QuadEaseOut" params="" file="/Users/Sven/dev/lab/luxe/luxe/tween/easing/Quad.hx" module="luxe.tween.easing.Quad">
		<implements path="luxe.tween.easing.IEasing"/>
		<ease public="1" set="method" line="120"><f a="t:b:c:d">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></ease>
		<calculate public="1" set="method" line="113"><f a="k">
	<x path="Float"/>
	<x path="Float"/>
</f></calculate>
		<new public="1" set="method" line="106"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="luxe.utils.GeometryUtils" params="" file="/Users/Sven/dev/lab/luxe/luxe/utils/GeometryUtils.hx">
		<intersect_ray_plane public="1" set="method" line="46"><f a="_ray_start:_ray_dir:_plane_normal:_plane_point">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></intersect_ray_plane>
		<point_in_polygon public="1" set="method" line="22"><f a="_point:_offset:_verts">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
	<c path="Array"><t path="luxe.Vector"/></c>
	<x path="Bool"/>
</f></point_in_polygon>
		<random_point_in_unit_circle public="1" set="method" line="15"><f a=""><t path="luxe.Vector"/></f></random_point_in_unit_circle>
		<segments_for_smooth_circle public="1" set="method" line="11"><f a="_radius:?_smooth">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></segments_for_smooth_circle>
		<luxe public="1"><c path="luxe.Core"/></luxe>
		<new public="1" set="method" line="7"><f a="_luxe">
	<c path="luxe.Core"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.utils.JSON" params="" file="/Users/Sven/dev/lab/luxe/luxe/utils/JSON.hx">
		<encode public="1" get="inline" set="null" line="44" static="1">
			<f a="o">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>* Encodes a object into a JSON string.
	 *
	 * @param o The object to create a JSON string for
	 * @return the JSON string representing o</haxe_doc>
		</encode>
		<decode public="1" get="inline" set="null" line="54" static="1">
			<f a="s:?strict">
				<c path="String"/>
				<x path="Bool"/>
				<d/>
			</f>
			<haxe_doc>* Decodes a JSON string into a native object.
	 * 
	 * @param s The JSON string representing the object
	 * @return A native object as specified by s</haxe_doc>
		</decode>
		<stringify public="1" get="inline" set="null" line="64" static="1">
			<f a="o">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>* Encodes a object into a JSON string.
	 *
	 * @param o The object to create a JSON string for
	 * @return the JSON string representing o</haxe_doc>
		</stringify>
		<parse public="1" get="inline" set="null" line="74" static="1">
			<f a="s:?strict">
				<c path="String"/>
				<x path="Bool"/>
				<d/>
			</f>
			<haxe_doc>* Decodes a JSON string into a native object.
	 * 
	 * @param s The JSON string representing the object
	 * @return A native object as specified by s</haxe_doc>
		</parse>
	</class>
	<enum path="luxe.utils.JSONTokenType" params="" file="/Users/Sven/dev/lab/luxe/luxe/utils/JSONDecoder.hx" module="luxe.utils.JSONDecoder">
		<tUNKNOWN/>
		<tTRUE/>
		<tSTRING/>
		<tRIGHT_BRACKET/>
		<tRIGHT_BRACE/>
		<tNUMBER/>
		<tNULL/>
		<tNAN/>
		<tLEFT_BRACKET/>
		<tLEFT_BRACE/>
		<tFALSE/>
		<tCOMMA/>
		<tCOLON/>
	</enum>
	<class path="luxe.utils.JSONDecoder" params="" file="/Users/Sven/dev/lab/luxe/luxe/utils/JSONDecoder.hx">
		<parseValue set="method" line="232">
			<f a=""><d/></f>
			<haxe_doc>* Attempt to parse a value</haxe_doc>
		</parseValue>
		<parseObject set="method" line="157">
			<f a=""><d/></f>
			<haxe_doc>* Attempt to parse an object</haxe_doc>
		</parseObject>
		<parseArray set="method" line="102">
			<f a=""><c path="Array"><d/></c></f>
			<haxe_doc>* Attempt to parse an array</haxe_doc>
		</parseArray>
		<nextToken set="method" line="95">
			<f a=""><c path="luxe.utils.JSONToken"/></f>
			<haxe_doc>* Returns the next token from the tokenzier reading
	 * the JSON string</haxe_doc>
		</nextToken>
		<getValue public="1" set="method" line="87">
			<f a=""><d/></f>
			<haxe_doc>* Gets the internal object that was created by parsing
	 * the JSON string passed to the constructor.
	 *
	 * @return The internal object representation of the JSON
	 * 		string that was passed to the constructor</haxe_doc>
		</getValue>
		<token>
			<c path="luxe.utils.JSONToken"/>
			<haxe_doc>The current token from the tokenizer</haxe_doc>
		</token>
		<tokenizer>
			<c path="luxe.utils.JSONTokenizer"/>
			<haxe_doc>The tokenizer designated to read the JSON string</haxe_doc>
		</tokenizer>
		<value>
			<d/>
			<haxe_doc>The value that will get parsed from the JSON string</haxe_doc>
		</value>
		<strict><x path="Bool"/></strict>
		<new public="1" set="method" line="71">
			<f a="s:strict">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructs a new JSONDecoder to parse a JSON string 
	 * into a native object.
	 *
	 * @param s The JSON string to be converted into a native object</haxe_doc>
		</new>
	</class>
	<class path="luxe.utils.JSONEncoder" params="" file="/Users/Sven/dev/lab/luxe/luxe/utils/JSONEncoder.hx">
		<instanceToString set="method" line="299">
			<f a="o:cls">
				<d/>
				<x path="Class"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Converts an instance object to it's JSON string equivalent
   *
   * @param o The instance object to convert
   * @param cls The class of instance object
   * @return The JSON string representation of <code>o</code>]]></haxe_doc>
		</instanceToString>
		<objectToString set="method" line="267">
			<f a="o">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Converts an object to it's JSON string equivalent
	 *
	 * @param o The object to convert
	 * @return The JSON string representation of <code>o</code>]]></haxe_doc>
		</objectToString>
		<arrayToString set="method" line="224">
			<f a="a">
				<c path="Array"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Converts an array to it's JSON string equivalent
	 *
	 * @param a The array to convert
	 * @return The JSON string representation of <code>a</code>]]></haxe_doc>
		</arrayToString>
		<escapeString set="method" line="139">
			<f a="str">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Escapes a string accoding to the JSON specification.
	 *
	 * @param str The string to be escaped
	 * @return The string with escaped special characters
	 * 		according to the JSON specification</haxe_doc>
		</escapeString>
		<mapHash set="method" line="125"><f a="value">
	<x path="Map">
		<c path="String"/>
		<d/>
	</x>
	<d/>
</f></mapHash>
		<convertToString set="method" line="77">
			<f a="value">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>* Converts a value to it's JSON string equivalent.
	 *
	 * @param value The value to convert.  Could be any 
	 *		type (object, number, array, etc)</haxe_doc>
		</convertToString>
		<_trace public="1" set="method" line="69"><f a="e">
	<c path="String"/>
	<x path="Void"/>
</f></_trace>
		<debug public="1"><x path="Bool"/></debug>
		<getString public="1" set="method" line="64">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Gets the JSON string from the encoder.
	 *
	 * @return The JSON string representation of the object
	 * 		that was passed to the constructor</haxe_doc>
		</getString>
		<jsonString>
			<c path="String"/>
			<haxe_doc>The string that is going to represent the object we're encoding</haxe_doc>
		</jsonString>
		<new public="1" set="method" line="54">
			<f a="value">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new JSONEncoder.
	 *
	 * @param o The object to encode as a JSON string</haxe_doc>
		</new>
	</class>
	<class path="luxe.utils.JSONParseError" params="" file="/Users/Sven/dev/lab/luxe/luxe/utils/JSONParseError.hx">
		<toString public="1" set="method" line="78"><f a=""><c path="String"/></f></toString>
		<get_text public="1" set="method" line="74">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Provides read-only access to the text variable.
	 *
	 * @return The string in which the error occurred</haxe_doc>
		</get_text>
		<get_location public="1" set="method" line="65">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Provides read-only access to the location variable.
	 *
	 * @return The location in the string where the error occurred</haxe_doc>
		</get_location>
		<message><c path="String"/></message>
		<location public="1" get="accessor" set="null"><x path="Int"/></location>
		<text public="1" get="accessor" set="null"><c path="String"/></text>
		<name><c path="String"/></name>
		<_text>
			<c path="String"/>
			<haxe_doc>The string in which the parse error occurred</haxe_doc>
		</_text>
		<_location>
			<x path="Int"/>
			<haxe_doc>The location in the string where the error occurred</haxe_doc>
		</_location>
		<new public="1" set="method" line="52">
			<f a="?message:?location:?text">
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructs a new JSONParseError.
	 *
	 * @param message The error message that occured during parsing</haxe_doc>
		</new>
	</class>
	<class path="luxe.utils.JSONToken" params="" file="/Users/Sven/dev/lab/luxe/luxe/utils/JSONToken.hx">
		<value public="1">
			<d/>
			<haxe_doc>value of the token</haxe_doc>
		</value>
		<type public="1">
			<e path="luxe.utils.JSONTokenType"/>
			<haxe_doc>type of the token</haxe_doc>
		</type>
		<new public="1" set="method" line="51">
			<f a="?type:?value">
				<e path="luxe.utils.JSONTokenType"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new JSONToken with a specific token type and value.
	 *
	 * @param type The JSONTokenType of the token
	 * @param value The value of the token</haxe_doc>
		</new>
	</class>
	<class path="luxe.utils.JSONTokenizer" params="" file="/Users/Sven/dev/lab/luxe/luxe/utils/JSONTokenizer.hx">
		<parseError public="1" set="method" line="551">
			<f a="message">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Raises a parsing error with a specified message, tacking
	 * on the error location and the original string.
	 *
	 * @param message The message indicating why the error occurred</haxe_doc>
		</parseError>
		<isHexDigit set="method" line="536">
			<f a="ch">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Determines if a character is a digit [0-9].
	 *
	 * @return True if the character passed in is a digit</haxe_doc>
		</isHexDigit>
		<isDigit set="method" line="523">
			<f a="ch">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Determines if a character is a digit [0-9].
	 *
	 * @return True if the character passed in is a digit</haxe_doc>
		</isDigit>
		<isWhiteSpace set="method" line="514">
			<f a="ch">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Determines if a character is whitespace or not.
	 *
	 * @return True if the character passed in is a whitespace
	 *	character</haxe_doc>
		</isWhiteSpace>
		<skipWhite set="method" line="499">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Skip any whitespace in the input string and advances
	 * the character to the first character after any possible
	 * whitespace.</haxe_doc>
		</skipWhite>
		<skipComments set="method" line="450">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Skips comments in the input string, either
	 * single-line or multi-line.  Advances the character
	 * to the first position after the end of the comment.</haxe_doc>
		</skipComments>
		<skipIgnored set="method" line="434">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Advances the character location past any
	 * sort of white space and comments</haxe_doc>
		</skipIgnored>
		<nextChar set="method" line="426">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Reads the next character in the input
	 * string and advances the character location.
	 *
	 * @return The next character in the input string, or
	 *		null if we've read past the end.</haxe_doc>
		</nextChar>
		<readNumber set="method" line="317">
			<f a=""><c path="luxe.utils.JSONToken"/></f>
			<haxe_doc>* Attempts to read a number from the input string.  Places
	 * the character location at the first character after the
	 * number.
	 * 
	 * @return The JSONToken with the number value if a number could
	 * 		be read.  Throws an error otherwise.</haxe_doc>
		</readNumber>
		<hexValToInt get="inline" set="null" line="284"><f a="hexVal">
	<c path="String"/>
	<x path="Int"/>
</f></hexValToInt>
		<readString set="method" line="197">
			<f a=""><c path="luxe.utils.JSONToken"/></f>
			<haxe_doc>* Attempts to read a string from the input string.  Places
	 * the character location at the first character after the
	 * string.  It is assumed that ch is " before this method is called.
	 *
	 * @return the JSONToken with the string value if a string could
	 *		be read.  Throws an error otherwise.</haxe_doc>
		</readString>
		<getNextToken public="1" set="method" line="75">
			<f a=""><c path="luxe.utils.JSONToken"/></f>
			<haxe_doc>* Gets the next token in the input sting and advances
	* the character to the next character after the token</haxe_doc>
		</getNextToken>
		<strict><x path="Bool"/></strict>
		<ch>
			<c path="String"/>
			<haxe_doc>The current character in the JSON string during parsing</haxe_doc>
		</ch>
		<loc>
			<x path="Int"/>
			<haxe_doc>The current parsing location in the JSON string</haxe_doc>
		</loc>
		<jsonString>
			<c path="String"/>
			<haxe_doc>The JSON string to be parsed</haxe_doc>
		</jsonString>
		<obj>
			<d/>
			<haxe_doc>The object that will get parsed from the JSON string</haxe_doc>
		</obj>
		<new public="1" set="method" line="63">
			<f a="s:strict">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructs a new JSONDecoder to parse a JSON string 
	 * into a native object.
	 *
	 * @param s The JSON string to be converted
	 *		into a native object</haxe_doc>
		</new>
	</class>
	<class path="luxe.utils._UUID.Rule30" params="" file="/Users/Sven/dev/lab/luxe/luxe/utils/UUID.hx" private="1" module="luxe.utils.UUID">
		<createWithLength public="1" set="method" line="123" static="1"><f a="length">
	<x path="Int"/>
	<c path="luxe.utils._UUID.Rule30"/>
</f></createWithLength>
		<getBit set="method" line="163"><f a=""><x path="Int"/></f></getBit>
		<getBits public="1" set="method" line="152"><f a="length">
	<x path="Int"/>
	<x path="Int"/>
</f></getBits>
		<cellsLength><x path="Int"/></cellsLength>
		<cells><c path="String"/></cells>
		<new set="method" line="137"><f a="cells">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="luxe.utils.UUID" params="" file="/Users/Sven/dev/lab/luxe/luxe/utils/UUID.hx">
		<rule30 line="40" static="1"><c path="luxe.utils._UUID.Rule30"/></rule30>
		<hexChars line="41" static="1"><c path="String"/></hexChars>
		<generate_undashed public="1" set="method" line="45" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Generate a Universal Unique Identifier string.
		For example: B859AA4C0A96CA94F7F82DBECD24205F</haxe_doc>
		</generate_undashed>
		<get public="1" set="method" line="74" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Generate a Universal Unique Identifier string, with dashes according to the spec.
		For example: BD5FB953-0BD3-D6B4-82AB-E642B7036246</haxe_doc>
		</get>
		<hex set="method" line="105" static="1"><f a="sbuf:n">
	<c path="StringBuf"/>
	<x path="Int"/>
	<x path="Void"/>
</f></hex>
	</class>
	<class path="luxe.utils.Utils" params="" file="/Users/Sven/dev/lab/luxe/luxe/utils/Utils.hx">
		<file_bytes_to_class public="1" set="method" line="52"><f a="_file:_outfile:?_string_length">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></file_bytes_to_class>
		<arrayToBytes public="1" set="method" line="45"><f a="array">
	<c path="Array"><x path="Int"/></c>
	<c path="haxe.io.Bytes"/>
</f></arrayToBytes>
		<bytes_to_string public="1" set="method" line="39"><f a="bytes">
	<x path="Int"/>
	<c path="String"/>
</f></bytes_to_string>
		<nearest_power_of_two public="1" set="method" line="28"><f a="_value">
	<x path="Int"/>
	<x path="Int"/>
</f></nearest_power_of_two>
		<clamp public="1" set="method" line="24"><f a="value:min:max">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></clamp>
		<uuid public="1" set="method" line="20"><f a=""><c path="String"/></f></uuid>
		<luxe public="1"><c path="luxe.Core"/></luxe>
		<_byte_levels><c path="Array"><c path="String"/></c></_byte_levels>
		<geometry public="1"><c path="luxe.utils.GeometryUtils"/></geometry>
		<new public="1" set="method" line="12"><f a="_luxe">
	<c path="luxe.Core"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.BatchState" params="" file="/Users/Sven/dev/lab/luxe/phoenix/BatchState.hx">
		<str public="1" set="method" line="186"><f a=""><x path="Void"/></f></str>
		<update public="1" set="method" line="169"><f a="geom">
	<c path="phoenix.geometry.Geometry"/>
	<x path="Bool"/>
</f></update>
		<deactivate public="1" set="method" line="147"><f a="batcher">
	<c path="phoenix.Batcher"/>
	<x path="Void"/>
</f></deactivate>
		<activate public="1" set="method" line="32"><f a="batcher">
	<c path="phoenix.Batcher"/>
	<x path="Void"/>
</f></activate>
		<log public="1"><x path="Bool"/></log>
		<last_clip_rect public="1"><c path="phoenix.Rectangle"/></last_clip_rect>
		<clip_rect public="1"><c path="phoenix.Rectangle"/></clip_rect>
		<is_clipping public="1"><x path="Bool"/></is_clipping>
		<last_group public="1"><x path="Int"/></last_group>
		<last_shader_id public="1"><d/></last_shader_id>
		<last_texture_id public="1"><d/></last_texture_id>
		<last_geom_state public="1"><c path="phoenix.geometry.GeometryState"/></last_geom_state>
		<geom_state public="1"><c path="phoenix.geometry.GeometryState"/></geom_state>
		<batcher public="1"><c path="phoenix.Batcher"/></batcher>
		<new public="1" set="method" line="26"><f a="_r">
	<c path="phoenix.Batcher"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="phoenix.PrimitiveType" params="" file="/Users/Sven/dev/lab/luxe/phoenix/Batcher.hx" module="phoenix.Batcher">
		<triangles/>
		<triangle_strip/>
		<triangle_fan/>
		<none/>
		<line_strip/>
		<line_loop/>
	</enum>
	<enum path="phoenix.BlendMode" params="" file="/Users/Sven/dev/lab/luxe/phoenix/Batcher.hx" module="phoenix.Batcher">
		<zero/>
		<src_color/>
		<src_alpha_saturate/>
		<src_alpha/>
		<one_minus_src_color/>
		<one_minus_src_alpha/>
		<one_minus_dst_color/>
		<one_minus_dst_alpha/>
		<one/>
		<dst_color/>
		<dst_alpha/>
	</enum>
	<class path="phoenix.BatchGroup" params="" file="/Users/Sven/dev/lab/luxe/phoenix/Batcher.hx" module="phoenix.Batcher">
		<post_render public="1"><f a="">
	<c path="phoenix.Batcher"/>
	<x path="Void"/>
</f></post_render>
		<pre_render public="1"><f a="">
	<c path="phoenix.Batcher"/>
	<x path="Void"/>
</f></pre_render>
		<new public="1" set="method" line="39"><f a="_pre:_post">
	<f a="">
		<c path="phoenix.Batcher"/>
		<x path="Void"/>
	</f>
	<f a="">
		<c path="phoenix.Batcher"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.Batcher" params="" file="/Users/Sven/dev/lab/luxe/phoenix/Batcher.hx">
		<submit_vertex_list public="1" set="method" line="520"><f a="vertlist:tcoordlist:colorlist:normallist:type">
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Float"/></c>
	<e path="phoenix.PrimitiveType"/>
	<x path="Void"/>
</f></submit_vertex_list>
		<submit_static_buffer_object public="1" set="method" line="439"><f a="geom">
	<c path="phoenix.geometry.Geometry"/>
	<x path="Void"/>
</f></submit_static_buffer_object>
		<_disable_attributes set="method" line="429"><f a=""><x path="Void"/></f></_disable_attributes>
		<_enable_attributes set="method" line="415"><f a=""><x path="Void"/></f></_enable_attributes>
		<get_opengl_primitive_type public="1" set="method" line="398"><f a="type">
	<e path="phoenix.PrimitiveType"/>
	<x path="Int"/>
</f></get_opengl_primitive_type>
		<draw public="1" set="method" line="381"><f a="?persist_immediate">
	<x path="Bool"/>
	<x path="Void"/>
</f></draw>
		<batch public="1" set="method" line="276"><f a="?persist_immediate">
	<x path="Bool"/>
	<x path="Void"/>
</f></batch>
		<shader_activate public="1" set="method" line="232"><f a="_shader">
	<c path="phoenix.Shader"/>
	<x path="Void"/>
</f></shader_activate>
		<remove public="1" set="method" line="217"><f a="_geom:?_remove_batcher_from_geometry">
	<c path="phoenix.geometry.Geometry"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></remove>
		<add public="1" set="method" line="195"><f a="_geom:?_force_add">
	<c path="phoenix.geometry.Geometry"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></add>
		<geometry_compare public="1" set="method" line="189"><f a="a:b">
	<c path="phoenix.geometry.Geometry"/>
	<c path="phoenix.geometry.Geometry"/>
	<x path="Int"/>
</f></geometry_compare>
		<blend_mode public="1" set="method" line="179"><f a="?_src_mode:?_dst_mode">
	<e path="phoenix.BlendMode"/>
	<e path="phoenix.BlendMode"/>
	<x path="Void"/>
</f></blend_mode>
		<blend_mode_from_BlendMode public="1" set="method" line="151"><f a="_b">
	<e path="phoenix.BlendMode"/>
	<x path="Int"/>
</f></blend_mode_from_BlendMode>
		<l public="1" set="method" line="146"><f a="v">
	<d/>
	<x path="Void"/>
</f></l>
		<add_group public="1" set="method" line="138"><f a="_group:_pre_render:_post_render">
	<x path="Int"/>
	<f a="">
		<c path="phoenix.Batcher"/>
		<x path="Void"/>
	</f>
	<f a="">
		<c path="phoenix.Batcher"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></add_group>
		<compare public="1" set="method" line="132"><f a="other">
	<c path="phoenix.Batcher"/>
	<x path="Int"/>
</f></compare>
		<toString public="1" set="method" line="127"><f a=""><c path="String"/></f></toString>
		<name public="1"><c path="String"/></name>
		<log public="1"><x path="Bool"/></log>
		<enabled_count public="1"><x path="Int"/></enabled_count>
		<static_batched_count public="1"><x path="Int"/></static_batched_count>
		<dynamic_batched_count public="1"><x path="Int"/></dynamic_batched_count>
		<draw_calls public="1"><x path="Int"/></draw_calls>
		<view public="1"><c path="phoenix.Camera"/></view>
		<renderer public="1"><c path="phoenix.Renderer"/></renderer>
		<tex7_attribute public="1"><d/></tex7_attribute>
		<tex6_attribute public="1"><d/></tex6_attribute>
		<tex5_attribute public="1"><d/></tex5_attribute>
		<tex4_attribute public="1"><d/></tex4_attribute>
		<tex3_attribute public="1"><d/></tex3_attribute>
		<tex2_attribute public="1"><d/></tex2_attribute>
		<tex1_attribute public="1"><d/></tex1_attribute>
		<tex0_attribute public="1"><d/></tex0_attribute>
		<normal_attribute public="1"><d/></normal_attribute>
		<color_attribute public="1"><d/></color_attribute>
		<tcoord_attribute public="1"><d/></tcoord_attribute>
		<vert_attribute public="1"><d/></vert_attribute>
		<modelviewmatrix_attribute public="1"><d/></modelviewmatrix_attribute>
		<projectionmatrix_attribute public="1"><d/></projectionmatrix_attribute>
		<normalBuffer public="1"><c path="lime.gl.GLBuffer"/></normalBuffer>
		<vcolorBuffer public="1"><c path="lime.gl.GLBuffer"/></vcolorBuffer>
		<tcoordBuffer public="1"><c path="lime.gl.GLBuffer"/></tcoordBuffer>
		<vertexBuffer public="1"><c path="lime.gl.GLBuffer"/></vertexBuffer>
		<normal_list public="1"><c path="Array"><x path="Float"/></c></normal_list>
		<color_list public="1"><c path="Array"><x path="Float"/></c></color_list>
		<tcoord_list public="1"><c path="Array"><x path="Float"/></c></tcoord_list>
		<vert_list public="1"><c path="Array"><x path="Float"/></c></vert_list>
		<tree_changed public="1"><x path="Bool"/></tree_changed>
		<groups public="1"><x path="Map">
	<x path="Int"/>
	<c path="Array"><c path="phoenix.BatchGroup"/></c>
</x></groups>
		<geometry public="1"><c path="luxe.structures.BalancedBinarySearchTree">
	<c path="phoenix.geometry.Geometry"/>
	<c path="phoenix.geometry.Geometry"/>
</c></geometry>
		<enabled public="1"><x path="Bool"/></enabled>
		<layer public="1"><x path="Int"/></layer>
		<new public="1" set="method" line="96"><f a="_r:?_name">
	<c path="phoenix.Renderer"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="phoenix.TextAlign" params="" file="/Users/Sven/dev/lab/luxe/phoenix/BitmapFont.hx" module="phoenix.BitmapFont">
		<top/>
		<right/>
		<left/>
		<center/>
		<bottom/>
	</enum>
	<typedef path="phoenix.Character" params="" file="/Users/Sven/dev/lab/luxe/phoenix/BitmapFont.hx" module="phoenix.BitmapFont"><a>
	<yoffset><x path="Int"/></yoffset>
	<y><x path="Int"/></y>
	<xoffset><x path="Int"/></xoffset>
	<xadvance><x path="Int"/></xadvance>
	<x><x path="Int"/></x>
	<width><x path="Int"/></width>
	<page><x path="Int"/></page>
	<id><x path="Int"/></id>
	<height><x path="Int"/></height>
</a></typedef>
	<typedef path="phoenix.KerningKey" params="" file="/Users/Sven/dev/lab/luxe/phoenix/BitmapFont.hx" module="phoenix.BitmapFont"><a>
	<index><x path="Int"/></index>
	<glyph><x path="Int"/></glyph>
</a></typedef>
	<typedef path="phoenix.KeyValuePair" params="" file="/Users/Sven/dev/lab/luxe/phoenix/BitmapFont.hx" module="phoenix.BitmapFont"><a>
	<value><c path="String"/></value>
	<key><c path="String"/></key>
</a></typedef>
	<class path="phoenix.Droppable" params="" file="/Users/Sven/dev/lab/luxe/phoenix/Droppable.hx">
		<drop public="1" set="method" line="7"><f a=""><x path="Void"/></f></drop>
		<dropped public="1"><x path="Bool"/></dropped>
		<references public="1"><x path="Int"/></references>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="phoenix.Resource" params="" file="/Users/Sven/dev/lab/luxe/phoenix/Resource.hx">
		<extends path="phoenix.Droppable"/>
		<drop public="1" set="method" line="29" override="1"><f a=""><x path="Void"/></f></drop>
		<persistent public="1"><x path="Bool"/></persistent>
		<id public="1"><c path="String"/></id>
		<type public="1"><e path="phoenix.ResourceType"/></type>
		<manager public="1"><c path="phoenix.ResourceManager"/></manager>
		<new public="1" set="method" line="22"><f a="_manager:_type">
	<c path="phoenix.ResourceManager"/>
	<e path="phoenix.ResourceType"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.BitmapFont" params="" file="/Users/Sven/dev/lab/luxe/phoenix/BitmapFont.hx">
		<extends path="phoenix.Resource"/>
		<set_character public="1" set="method" line="517"><f a="_index:_char_info">
	<x path="Int"/>
	<t path="phoenix.Character"/>
	<x path="Void"/>
</f></set_character>
		<draw_text public="1" set="method" line="307"><f a="options">
	<d/>
	<c path="phoenix.geometry.CompositeGeometry"/>
</f></draw_text>
		<get_text_dimensions public="1" set="method" line="243"><f a="_string:_scale">
	<c path="String"/>
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></get_text_dimensions>
		<get_kerning public="1" set="method" line="233"><f a="_glyph:_index">
	<x path="Int"/>
	<x path="Int"/>
	<t path="Null"><x path="Int"/></t>
</f></get_kerning>
		<set_kerning public="1" set="method" line="229"><f a="_glyph:_index:_amount">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set_kerning>
		<load_from_string public="1" set="method" line="107"><f a="?_bitmap_file:?_folder:?onloaded:?custom_pages">
	<c path="String"/>
	<c path="String"/>
	<f a=""><x path="Void"/></f>
	<c path="Array"><c path="phoenix.Texture"/></c>
	<x path="Void"/>
</f></load_from_string>
		<one_page_loaded public="1" set="method" line="100"><f a="t">
	<c path="phoenix.Texture"/>
	<x path="Void"/>
</f></one_page_loaded>
		<on_all_pages_loaded public="1" set="method" line="94"><f a=""><x path="Void"/></f></on_all_pages_loaded>
		<_tokenize_font_line set="method" line="85"><f a="_line_tokens">
	<c path="Array"><c path="String"/></c>
	<x path="Map">
		<c path="String"/>
		<t path="phoenix.KeyValuePair"/>
	</x>
</f></_tokenize_font_line>
		<toString public="1" set="method" line="81"><f a=""><c path="String"/></f></toString>
		<onload public="1"><f a=""><x path="Void"/></f></onload>
		<pages_loaded public="1"><x path="Int"/></pages_loaded>
		<on_pages_loaded public="1"><f a=""><x path="Void"/></f></on_pages_loaded>
		<line_widths><c path="Array"><x path="Float"/></c></line_widths>
		<scale public="1"><t path="luxe.Vector"/></scale>
		<kernings public="1"><x path="Map">
	<t path="phoenix.KerningKey"/>
	<x path="Int"/>
</x></kernings>
		<characters public="1"><x path="Map">
	<x path="Int"/>
	<t path="phoenix.Character"/>
</x></characters>
		<pages public="1"><x path="Map">
	<x path="Int"/>
	<c path="phoenix.Texture"/>
</x></pages>
		<font_character_count public="1"><x path="Int"/></font_character_count>
		<font_size public="1"><x path="Float"/></font_size>
		<line_height public="1"><x path="Float"/></line_height>
		<spacing public="1"><x path="Float"/></spacing>
		<dimensions public="1"><t path="luxe.Vector"/></dimensions>
		<new public="1" set="method" line="64"><f a="?_resource_manager">
	<c path="phoenix.ResourceManager"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="phoenix.ProjectionType" params="" file="/Users/Sven/dev/lab/luxe/phoenix/Camera.hx" module="phoenix.Camera">
		<perspective/>
		<ortho/>
		<custom/>
	</enum>
	<class path="phoenix.Camera" params="" file="/Users/Sven/dev/lab/luxe/phoenix/Camera.hx">
		<_merge_options set="method" line="203"><f a="projection_options:options">
	<d/>
	<d/>
	<x path="Void"/>
</f></_merge_options>
		<world_point_to_screen public="1" set="method" line="183"><f a="_vector:?_viewport">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Rectangle"/>
	<c path="phoenix.Vector"/>
</f></world_point_to_screen>
		<screen_point_to_ray public="1" set="method" line="177"><f a="_vector">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Ray"/>
</f></screen_point_to_ray>
		<unprojectVector public="1" set="method" line="169"><f a="_vector">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></unprojectVector>
		<projectVector public="1" set="method" line="161"><f a="_vector">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></projectVector>
		<set_perspective public="1" set="method" line="150"><f a="?options">
	<d/>
	<x path="Void"/>
</f></set_perspective>
		<set_ortho public="1" set="method" line="140"><f a="?options">
	<d/>
	<x path="Void"/>
</f></set_ortho>
		<apply_perspective public="1" set="method" line="121"><f a=""><x path="Void"/></f></apply_perspective>
		<apply_ortho public="1" set="method" line="108"><f a=""><x path="Void"/></f></apply_ortho>
		<update_look_at public="1" set="method" line="98"><f a=""><x path="Void"/></f></update_look_at>
		<process public="1" set="method" line="84"><f a=""><x path="Void"/></f></process>
		<up public="1"><c path="phoenix.Vector"/></up>
		<target public="1"><c path="phoenix.Vector"/></target>
		<projection public="1"><e path="phoenix.ProjectionType"/></projection>
		<ortho_options public="1"><d/></ortho_options>
		<perspective_options public="1"><d/></perspective_options>
		<view_matrix public="1"><c path="phoenix.Matrix4"/></view_matrix>
		<projection_matrix public="1"><c path="phoenix.Matrix4"/></projection_matrix>
		<size public="1"><c path="phoenix.Vector"/></size>
		<scale public="1"><c path="phoenix.Vector"/></scale>
		<rotation public="1"><c path="phoenix.Quaternion"/></rotation>
		<pos public="1"><c path="phoenix.Vector"/></pos>
		<new public="1" set="method" line="40"><f a="?options">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.Circle" params="" file="/Users/Sven/dev/lab/luxe/phoenix/Circle.hx">
		<set public="1" set="method" line="29"><f a="?_x:?_y:?_w:?_r">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="phoenix.Circle"/>
</f></set>
		<clone public="1" set="method" line="25"><f a=""><c path="phoenix.Circle"/></f></clone>
		<point_inside public="1" set="method" line="20"><f a="_p">
	<c path="phoenix.Vector"/>
	<x path="Bool"/>
</f></point_inside>
		<toString public="1" set="method" line="16"><f a=""><c path="String"/></f></toString>
		<r public="1"><x path="Float"/></r>
		<y public="1"><x path="Float"/></y>
		<x public="1"><x path="Float"/></x>
		<new public="1" set="method" line="10"><f a="?_x:?_y:?_r">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.Color" params="" file="/Users/Sven/dev/lab/luxe/phoenix/Color.hx">
		<from_int set="method" line="201"><f a="_i">
	<x path="Int"/>
	<x path="Void"/>
</f></from_int>
		<toString public="1" set="method" line="197"><f a=""><c path="String"/></f></toString>
		<fromColorHSL public="1" set="method" line="147"><f a="_color_hsl">
	<c path="phoenix.ColorHSL"/>
	<c path="phoenix.Color"/>
</f></fromColorHSL>
		<fromColorHSV public="1" set="method" line="117"><f a="_color_hsv">
	<c path="phoenix.ColorHSV"/>
	<x path="Void"/>
</f></fromColorHSV>
		<toColorHSL public="1" set="method" line="113"><f a=""><c path="phoenix.ColorHSL"/></f></toColorHSL>
		<rgb public="1" set="method" line="108"><f a="?_rgb">
	<x path="Int"/>
	<c path="phoenix.Color"/>
</f></rgb>
		<clone public="1" set="method" line="104"><f a=""><c path="phoenix.Color"/></f></clone>
		<tween public="1" set="method" line="54"><f a="?_time_in_seconds:?_dest:?_override">
	<x path="Float"/>
	<d/>
	<x path="Bool"/>
	<c path="luxe.tween.actuators.IGenericActuator"/>
</f></tween>
		<minRGB public="1" set="method" line="50"><f a=""><x path="Float"/></f></minRGB>
		<maxRGB public="1" set="method" line="46"><f a=""><x path="Float"/></f></maxRGB>
		<set public="1" set="method" line="25"><f a="?_r:?_g:?_b:?_a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="phoenix.Color"/>
</f></set>
		<a public="1"><x path="Float"/></a>
		<b public="1"><x path="Float"/></b>
		<g public="1"><x path="Float"/></g>
		<r public="1"><x path="Float"/></r>
		<new public="1" set="method" line="16"><f a="?_r:?_g:?_b:?_a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.ColorHSL" params="" file="/Users/Sven/dev/lab/luxe/phoenix/Color.hx" module="phoenix.Color">
		<extends path="phoenix.Color"/>
		<toString public="1" set="method" line="379" override="1"><f a=""><c path="String"/></f></toString>
		<fromColor public="1" set="method" line="342"><f a="_color">
	<c path="phoenix.Color"/>
	<c path="phoenix.ColorHSL"/>
</f></fromColor>
		<toColor public="1" set="method" line="338"><f a=""><c path="phoenix.Color"/></f></toColor>
		<clone public="1" set="method" line="334" override="1"><f a=""><c path="phoenix.ColorHSL"/></f></clone>
		<_refresh public="1" set="method" line="329"><f a=""><c path="phoenix.ColorHSL"/></f></_refresh>
		<tween public="1" set="method" line="279" override="1"><f a="?_time_in_seconds:?_dest:?_override">
	<x path="Float"/>
	<d/>
	<x path="Bool"/>
	<c path="luxe.tween.actuators.IGenericActuator"/>
</f></tween>
		<set public="1" set="method" line="255" override="1"><f a="?_h:?_s:?_l:?_a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="phoenix.Color"/>
</f></set>
		<set_l set="method" line="236"><f a="_l">
	<x path="Float"/>
	<x path="Float"/>
</f></set_l>
		<set_s set="method" line="231"><f a="_s">
	<x path="Float"/>
	<x path="Float"/>
</f></set_s>
		<set_h set="method" line="226"><f a="_h">
	<x path="Float"/>
	<x path="Float"/>
</f></set_h>
		<l public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</l>
		<s public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</s>
		<h public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</h>
		<new public="1" set="method" line="242"><f a="?_h:?_s:?_l:?_a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.ColorHSV" params="" file="/Users/Sven/dev/lab/luxe/phoenix/Color.hx" module="phoenix.Color">
		<extends path="phoenix.Color"/>
		<toString public="1" set="method" line="556" override="1"><f a=""><c path="String"/></f></toString>
		<fromColor public="1" set="method" line="522"><f a="_color">
	<c path="phoenix.Color"/>
	<c path="phoenix.ColorHSV"/>
</f></fromColor>
		<fromColorHSL public="1" set="method" line="516" override="1"><f a="_color_hsl">
	<c path="phoenix.ColorHSL"/>
	<c path="phoenix.ColorHSV"/>
</f></fromColorHSL>
		<toColorHSL public="1" set="method" line="511" override="1"><f a=""><c path="phoenix.ColorHSL"/></f></toColorHSL>
		<toColor public="1" set="method" line="506"><f a=""><c path="phoenix.Color"/></f></toColor>
		<clone public="1" set="method" line="502" override="1"><f a=""><c path="phoenix.ColorHSV"/></f></clone>
		<_refresh public="1" set="method" line="497"><f a=""><c path="phoenix.ColorHSV"/></f></_refresh>
		<tween public="1" set="method" line="447" override="1"><f a="?_time_in_seconds:?_dest:?_override">
	<x path="Float"/>
	<d/>
	<x path="Bool"/>
	<c path="luxe.tween.actuators.IGenericActuator"/>
</f></tween>
		<set public="1" set="method" line="422" override="1"><f a="?_h:?_s:?_v:?_a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="phoenix.Color"/>
</f></set>
		<set_v set="method" line="403"><f a="_v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_v>
		<set_s set="method" line="398"><f a="_s">
	<x path="Float"/>
	<x path="Float"/>
</f></set_s>
		<set_h set="method" line="393"><f a="_h">
	<x path="Float"/>
	<x path="Float"/>
</f></set_h>
		<v public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</v>
		<s public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</s>
		<h public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</h>
		<new public="1" set="method" line="409"><f a="?_h:?_s:?_v:?_a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.Matrix4" params="" file="/Users/Sven/dev/lab/luxe/phoenix/Matrix4.hx">
		<GetLeft public="1" set="method" line="65" static="1"><f a="_m">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Vector"/>
</f></GetLeft>
		<GetRight public="1" set="method" line="69" static="1"><f a="_m">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Vector"/>
</f></GetRight>
		<GetUp public="1" set="method" line="73" static="1"><f a="_m">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Vector"/>
</f></GetUp>
		<GetDown public="1" set="method" line="77" static="1"><f a="_m">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Vector"/>
</f></GetDown>
		<GetForward public="1" set="method" line="81" static="1"><f a="_m">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Vector"/>
</f></GetForward>
		<GetBackward public="1" set="method" line="85" static="1"><f a="_m">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Vector"/>
</f></GetBackward>
		<clone public="1" set="method" line="912"><f a=""><c path="phoenix.Matrix4"/></f></clone>
		<toArray public="1" set="method" line="899"><f a=""><c path="Array"><x path="Float"/></c></f></toArray>
		<fromArray public="1" set="method" line="893"><f a="_from">
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></fromArray>
		<makeOrthographic public="1" set="method" line="872"><f a="_left:_right:_top:_bottom:_near:_far">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="phoenix.Matrix4"/>
</f></makeOrthographic>
		<makePerspective public="1" set="method" line="860"><f a="_fov:_aspect:_near:_far">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="phoenix.Matrix4"/>
</f></makePerspective>
		<makeFrustum public="1" set="method" line="838"><f a="_left:_right:_bottom:_top:_near:_far">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="phoenix.Matrix4"/>
</f></makeFrustum>
		<decompose public="1" set="method" line="785"><f a="?_position:?_quaternion:?_scale">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Quaternion"/>
	<c path="phoenix.Vector"/>
	<c path="Array"><d/></c>
</f></decompose>
		<compose public="1" set="method" line="775"><f a="_position:_quaternion:_scale">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Quaternion"/>
	<c path="phoenix.Vector"/>
	<c path="phoenix.Matrix4"/>
</f></compose>
		<makeScale public="1" set="method" line="761"><f a="_x:_y:_z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="phoenix.Matrix4"/>
</f></makeScale>
		<makeRotationAxis public="1" set="method" line="736"><f a="_axis:_angle">
	<c path="phoenix.Vector"/>
	<x path="Float"/>
	<c path="phoenix.Matrix4"/>
</f></makeRotationAxis>
		<makeRotationZ public="1" set="method" line="719"><f a="_theta">
	<x path="Float"/>
	<c path="phoenix.Matrix4"/>
</f></makeRotationZ>
		<makeRotationY public="1" set="method" line="702"><f a="_theta">
	<x path="Float"/>
	<c path="phoenix.Matrix4"/>
</f></makeRotationY>
		<makeRotationX public="1" set="method" line="685"><f a="_theta">
	<x path="Float"/>
	<c path="phoenix.Matrix4"/>
</f></makeRotationX>
		<makeTranslation public="1" set="method" line="671"><f a="_x:_y:_z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="phoenix.Matrix4"/>
</f></makeTranslation>
		<getMaxScaleOnAxis public="1" set="method" line="658"><f a=""><x path="Float"/></f></getMaxScaleOnAxis>
		<scale public="1" set="method" line="640"><f a="_v">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Matrix4"/>
</f></scale>
		<getInverse public="1" set="method" line="592"><f a="_m">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Matrix4"/>
</f></getInverse>
		<inverse public="1" set="method" line="588"><f a=""><c path="phoenix.Matrix4"/></f></inverse>
		<setPosition public="1" set="method" line="576"><f a="_v">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Matrix4"/>
</f></setPosition>
		<flattenToArrayOffset public="1" set="method" line="547"><f a="_flat:_offset">
	<c path="Array"><x path="Float"/></c>
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
</f></flattenToArrayOffset>
		<flattenToArray public="1" set="method" line="528"><f a="?_flat">
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Float"/></c>
</f></flattenToArray>
		<transpose public="1" set="method" line="511"><f a=""><c path="phoenix.Matrix4"/></f></transpose>
		<determinant public="1" set="method" line="466"><f a=""><x path="Float"/></f></determinant>
		<multiplyVector3Array public="1" set="method" line="440"><f a="_a">
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Float"/></c>
</f></multiplyVector3Array>
		<multiplyScalar public="1" set="method" line="426"><f a="_s">
	<x path="Float"/>
	<c path="phoenix.Matrix4"/>
</f></multiplyScalar>
		<multiplyToArray public="1" set="method" line="410"><f a="_a:_b:_r">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Matrix4"/>
	<c path="Array"><x path="Float"/></c>
	<c path="phoenix.Matrix4"/>
</f></multiplyToArray>
		<multiplyMatrices public="1" set="method" line="369"><f a="_a:_b">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Matrix4"/>
</f></multiplyMatrices>
		<multiply public="1" set="method" line="362"><f a="_m">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Matrix4"/>
</f></multiply>
		<lookAt public="1" set="method" line="330"><f a="_eye:_target:_up">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
	<c path="phoenix.Matrix4"/>
</f></lookAt>
		<makeRotationFromQuaternion public="1" set="method" line="293"><f a="q">
	<c path="phoenix.Quaternion"/>
	<c path="phoenix.Matrix4"/>
</f></makeRotationFromQuaternion>
		<makeRotationFromEuler public="1" set="method" line="168"><f a="_v:?_order">
	<c path="phoenix.Vector"/>
	<c path="String"/>
	<c path="phoenix.Matrix4"/>
</f></makeRotationFromEuler>
		<extractRotation public="1" set="method" line="144"><f a="m">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Matrix4"/>
</f></extractRotation>
		<copyPosition public="1" set="method" line="134"><f a="m">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Matrix4"/>
</f></copyPosition>
		<make2D public="1" set="method" line="116"><f a="_x:_y:?_scale:?_rotation">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="phoenix.Matrix4"/>
</f></make2D>
		<copy public="1" set="method" line="102"><f a="m">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Matrix4"/>
</f></copy>
		<identity public="1" set="method" line="89"><f a=""><c path="phoenix.Matrix4"/></f></identity>
		<float32array public="1" set="method" line="61"><f a=""><c path="lime.utils.Float32Array"/></f></float32array>
		<print public="1" set="method" line="52"><f a=""><x path="Void"/></f></print>
		<set public="1" set="method" line="33"><f a="n11:n12:n13:n14:n21:n22:n23:n24:n31:n32:n33:n34:n41:n42:n43:n44">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="phoenix.Matrix4"/>
</f></set>
		<elements public="1"><c path="Array"><x path="Float"/></c></elements>
		<new public="1" set="method" line="13"><f a="?n11:?n12:?n13:?n14:?n21:?n22:?n23:?n24:?n31:?n32:?n33:?n34:?n41:?n42:?n43:?n44">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.Quaternion" params="" file="/Users/Sven/dev/lab/luxe/phoenix/Quaternion.hx">
		<Slerp public="1" set="method" line="371" static="1"><f a="_qa:_qb:_qm:_t">
	<c path="phoenix.Quaternion"/>
	<c path="phoenix.Quaternion"/>
	<c path="phoenix.Quaternion"/>
	<x path="Float"/>
	<c path="phoenix.Quaternion"/>
</f></Slerp>
		<set_w set="method" line="413"><f a="_v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_w>
		<set_z set="method" line="403"><f a="_v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_z>
		<set_y set="method" line="393"><f a="_v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<set_x set="method" line="383"><f a="_v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<update_euler set="method" line="377"><f a=""><x path="Void"/></f></update_euler>
		<clone public="1" set="method" line="365"><f a=""><c path="phoenix.Quaternion"/></f></clone>
		<toArray public="1" set="method" line="359"><f a=""><c path="Array"><x path="Float"/></c></f></toArray>
		<fromArray public="1" set="method" line="347"><f a="_a">
	<c path="Array"><x path="Float"/></c>
	<c path="phoenix.Quaternion"/>
</f></fromArray>
		<equals public="1" set="method" line="340"><f a="_q">
	<c path="phoenix.Quaternion"/>
	<x path="Bool"/>
</f></equals>
		<slerp public="1" set="method" line="276"><f a="_qb:_t">
	<c path="phoenix.Quaternion"/>
	<x path="Float"/>
	<c path="phoenix.Quaternion"/>
</f></slerp>
		<multiplyQuaternions public="1" set="method" line="261"><f a="_a:_b">
	<c path="phoenix.Quaternion"/>
	<c path="phoenix.Quaternion"/>
	<c path="phoenix.Quaternion"/>
</f></multiplyQuaternions>
		<multiply public="1" set="method" line="255"><f a="_quaternion">
	<c path="phoenix.Quaternion"/>
	<c path="phoenix.Quaternion"/>
</f></multiply>
		<normalize public="1" set="method" line="228"><f a=""><c path="phoenix.Quaternion"/></f></normalize>
		<length public="1" set="method" line="221"><f a=""><x path="Float"/></f></length>
		<lengthSq public="1" set="method" line="214"><f a=""><x path="Float"/></f></lengthSq>
		<conjugate public="1" set="method" line="203"><f a=""><c path="phoenix.Quaternion"/></f></conjugate>
		<inverse public="1" set="method" line="196"><f a=""><c path="phoenix.Quaternion"/></f></inverse>
		<setFromRotationMatrix public="1" set="method" line="138"><f a="_m">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Quaternion"/>
</f></setFromRotationMatrix>
		<setFromAxisAngle public="1" set="method" line="120"><f a="_axis:_angle">
	<c path="phoenix.Vector"/>
	<x path="Float"/>
	<c path="phoenix.Quaternion"/>
</f></setFromAxisAngle>
		<setFromEuler public="1" set="method" line="57"><f a="_euler:?_order">
	<c path="phoenix.Vector"/>
	<c path="String"/>
	<c path="phoenix.Quaternion"/>
</f></setFromEuler>
		<copy public="1" set="method" line="45"><f a="_quaternion">
	<c path="phoenix.Quaternion"/>
	<c path="phoenix.Quaternion"/>
</f></copy>
		<set public="1" set="method" line="33"><f a="_x:_y:_z:_w">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="phoenix.Quaternion"/>
</f></set>
		<toString public="1" set="method" line="27"><f a=""><c path="String"/></f></toString>
		<euler><c path="phoenix.Vector"/></euler>
		<w public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</w>
		<z public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</z>
		<y public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</y>
		<x public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</x>
		<new public="1" set="method" line="16"><f a="?_x:?_y:?_z:?_w">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.Ray" params="" file="/Users/Sven/dev/lab/luxe/phoenix/Ray.hx">
		<refresh public="1" set="method" line="32"><f a="_screen_pos">
	<c path="phoenix.Vector"/>
	<x path="Void"/>
</f></refresh>
		<viewport><c path="phoenix.Rectangle"/></viewport>
		<camera><c path="phoenix.Camera"/></camera>
		<dir public="1"><c path="phoenix.Vector"/></dir>
		<end public="1"><c path="phoenix.Vector"/></end>
		<origin public="1"><c path="phoenix.Vector"/></origin>
		<new public="1" set="method" line="17"><f a="_screen_pos:_camera:?_viewport">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Camera"/>
	<c path="phoenix.Rectangle"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.Rectangle" params="" file="/Users/Sven/dev/lab/luxe/phoenix/Rectangle.hx">
		<set public="1" set="method" line="40"><f a="?_x:?_y:?_w:?_h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="phoenix.Rectangle"/>
</f></set>
		<equal public="1" set="method" line="34"><f a="other">
	<c path="phoenix.Rectangle"/>
	<x path="Bool"/>
</f></equal>
		<clone public="1" set="method" line="30"><f a=""><c path="phoenix.Rectangle"/></f></clone>
		<point_inside public="1" set="method" line="22"><f a="_p">
	<c path="phoenix.Vector"/>
	<x path="Bool"/>
</f></point_inside>
		<toString public="1" set="method" line="18"><f a=""><c path="String"/></f></toString>
		<h public="1"><x path="Float"/></h>
		<w public="1"><x path="Float"/></w>
		<y public="1"><x path="Float"/></y>
		<x public="1"><x path="Float"/></x>
		<new public="1" set="method" line="11"><f a="?_x:?_y:?_w:?_h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.RenderPath" params="" file="/Users/Sven/dev/lab/luxe/phoenix/RenderPath.hx">
		<render public="1" set="method" line="17"><f a="_batchers:_stats">
	<c path="luxe.structures.BinarySearchTree">
		<x path="Int"/>
		<c path="phoenix.Batcher"/>
	</c>
	<c path="phoenix.RendererStats"/>
	<x path="Void"/>
</f></render>
		<renderer public="1"><c path="phoenix.Renderer"/></renderer>
		<new public="1" set="method" line="13"><f a="_renderer">
	<c path="phoenix.Renderer"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.Texture" params="" file="/Users/Sven/dev/lab/luxe/phoenix/Texture.hx">
		<extends path="phoenix.Resource"/>
		<nme_bitmap_data_from_bytes line="434" static="1"><f a=":">
	<c path="haxe.io.Bytes"/>
	<unknown/>
	<unknown/>
</f></nme_bitmap_data_from_bytes>
		<nme_bitmap_data_height line="435" static="1"><f a="">
	<unknown/>
	<x path="Int"/>
</f></nme_bitmap_data_height>
		<nme_bitmap_data_width line="436" static="1"><f a="">
	<unknown/>
	<x path="Int"/>
</f></nme_bitmap_data_width>
		<nme_bitmap_data_get_pixels line="437" static="1"><f a=":">
	<unknown/>
	<a>
		<y><x path="Int"/></y>
		<x><x path="Int"/></x>
		<width><x path="Int"/></width>
		<height><x path="Int"/></height>
	</a>
	<unknown/>
</f></nme_bitmap_data_get_pixels>
		<destroy public="1" set="method" line="428"><f a=""><x path="Void"/></f></destroy>
		<drop public="1" set="method" line="423" override="1"><f a=""><x path="Void"/></f></drop>
		<unlock public="1" set="method" line="411"><f a=""><x path="Void"/></f></unlock>
		<lock public="1" set="method" line="398"><f a=""><x path="Bool"/></f></lock>
		<setPixel public="1" set="method" line="384"><f a="_pos:_color">
	<a>
		<y set="null"><x path="Float"/></y>
		<x set="null"><x path="Float"/></x>
	</a>
	<a>
		<r set="null"><x path="Int"/></r>
		<g set="null"><x path="Int"/></g>
		<b set="null"><x path="Int"/></b>
		<a set="null"><x path="Int"/></a>
	</a>
	<x path="Void"/>
</f></setPixel>
		<getPixel public="1" set="method" line="370"><f a="_pos">
	<a>
		<y set="null"><x path="Float"/></y>
		<x set="null"><x path="Float"/></x>
	</a>
	<a>
		<r><x path="Int"/></r>
		<g><x path="Int"/></g>
		<b><x path="Int"/></b>
		<a><x path="Int"/></a>
	</a>
</f></getPixel>
		<activate public="1" set="method" line="366"><f a="att">
	<unknown/>
	<x path="Void"/>
</f></activate>
		<bind public="1" set="method" line="342"><f a=""><x path="Void"/></f></bind>
		<generate_mipmaps public="1" set="method" line="335"><f a=""><x path="Void"/></f></generate_mipmaps>
		<set_filter set="method" line="322"><f a="_filter">
	<e path="phoenix.FilterType"/>
	<e path="phoenix.FilterType"/>
</f></set_filter>
		<_set_filter set="method" line="308"><f a="_filter">
	<e path="phoenix.FilterType"/>
	<x path="Void"/>
</f></_set_filter>
		<set_clamp set="method" line="294"><f a="_clamp">
	<e path="phoenix.ClampType"/>
	<e path="phoenix.ClampType"/>
</f></set_clamp>
		<_set_clamp set="method" line="279"><f a="_clamp">
	<e path="phoenix.ClampType"/>
	<x path="Void"/>
</f></_set_clamp>
		<create_from_bytes_using_haxe public="1" set="method" line="216"><f a="_asset_name:_asset_bytes">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></create_from_bytes_using_haxe>
		<create_from_bytes public="1" set="method" line="142"><f a="_asset_name:_asset_bytes">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></create_from_bytes>
		<create_from_bytes_html public="1" set="method" line="110"><f a="_asset_name:_asset_bytes:_width:_height">
	<c path="String"/>
	<unknown/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></create_from_bytes_html>
		<estimated_memory public="1" set="method" line="105"><f a=""><c path="String"/></f></estimated_memory>
		<build public="1" set="method" line="79"><f a="_size:_color">
	<c path="phoenix.Vector"/>
	<d/>
	<x path="Void"/>
</f></build>
		<toString public="1" set="method" line="75"><f a=""><c path="String"/></f></toString>
		<do_onload public="1" set="method" line="67"><f a=""><x path="Void"/></f></do_onload>
		<set_onload public="1" set="method" line="53"><f a="f">
	<f a="">
		<c path="phoenix.Texture"/>
		<x path="Void"/>
	</f>
	<f a="">
		<c path="phoenix.Texture"/>
		<x path="Void"/>
	</f>
</f></set_onload>
		<clamp public="1" set="accessor">
			<e path="phoenix.ClampType"/>
			<meta><m n=":isVar"/></meta>
		</clamp>
		<filter public="1" set="accessor">
			<e path="phoenix.FilterType"/>
			<meta><m n=":isVar"/></meta>
		</filter>
		<onload public="1" get="null" set="accessor">
			<f a="">
				<c path="phoenix.Texture"/>
				<x path="Void"/>
			</f>
			<meta><m n=":isVar"/></meta>
		</onload>
		<_onload_handlers public="1"><c path="Array"><f a="">
	<c path="phoenix.Texture"/>
	<x path="Void"/>
</f></c></_onload_handlers>
		<slot public="1"><x path="Int"/></slot>
		<loaded public="1"><x path="Bool"/></loaded>
		<height public="1"><x path="Int"/></height>
		<width public="1"><x path="Int"/></width>
		<actual_height public="1"><x path="Int"/></actual_height>
		<actual_width public="1"><x path="Int"/></actual_width>
		<data public="1"><c path="lime.utils.UInt8Array"/></data>
		<texture public="1"><c path="lime.gl.GLTexture"/></texture>
		<new public="1" set="method" line="43"><f a="_manager:?_type">
	<c path="phoenix.ResourceManager"/>
	<e path="phoenix.ResourceType"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.RenderTexture" params="" file="/Users/Sven/dev/lab/luxe/phoenix/RenderTexture.hx">
		<extends path="phoenix.Texture"/>
		<unbindBuffer public="1" set="method" line="81"><f a="?_other">
	<c path="lime.gl.GLFramebuffer"/>
	<x path="Void"/>
</f></unbindBuffer>
		<bindBuffer public="1" set="method" line="77"><f a=""><x path="Void"/></f></bindBuffer>
		<destroy public="1" set="method" line="70" override="1"><f a=""><x path="Void"/></f></destroy>
		<fbo public="1"><c path="lime.gl.GLFramebuffer"/></fbo>
		<new public="1" set="method" line="16"><f a="_manager:?_size">
	<c path="phoenix.ResourceManager"/>
	<c path="phoenix.Vector"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.Renderer" params="" file="/Users/Sven/dev/lab/luxe/phoenix/Renderer.hx">
		<process public="1" set="method" line="328"><f a=""><x path="Void"/></f></process>
		<load_texture public="1" set="method" line="237"><f a="_name:?_onloaded">
	<c path="String"/>
	<f a="">
		<c path="phoenix.Texture"/>
		<x path="Void"/>
	</f>
	<c path="phoenix.Texture"/>
</f></load_texture>
		<load_texture_from_string_byte_array public="1" set="method" line="192"><f a="?_name:_string_byte_array:_width:_height">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="phoenix.Texture"/>
</f></load_texture_from_string_byte_array>
		<load_shader public="1" set="method" line="149"><f a="_psid:?_vsid:?_onloaded">
	<c path="String"/>
	<c path="String"/>
	<f a="">
		<c path="phoenix.Shader"/>
		<x path="Void"/>
	</f>
	<c path="phoenix.Shader"/>
</f></load_shader>
		<load_font public="1" set="method" line="141"><f a="_fontid:?_path:?_onloaded">
	<c path="String"/>
	<c path="String"/>
	<f a=""><x path="Void"/></f>
	<c path="phoenix.BitmapFont"/>
</f></load_font>
		<_debug set="method" line="137"><f a="v">
	<d/>
	<x path="Void"/>
</f></_debug>
		<clear public="1" set="method" line="130"><f a="_color">
	<c path="phoenix.Color"/>
	<x path="Void"/>
</f></clear>
		<remove_batch public="1" set="method" line="126"><f a="batch">
	<c path="phoenix.Batcher"/>
	<x path="Void"/>
</f></remove_batch>
		<add_batch public="1" set="method" line="122"><f a="batch">
	<c path="phoenix.Batcher"/>
	<x path="Void"/>
</f></add_batch>
		<shutdown public="1" set="method" line="118"><f a=""><x path="Void"/></f></shutdown>
		<startup public="1" set="method" line="52"><f a=""><x path="Void"/></f></startup>
		<stats public="1"><c path="phoenix.RendererStats"/></stats>
		<clear_color public="1"><c path="phoenix.Color"/></clear_color>
		<stop_count public="1"><x path="Int"/></stop_count>
		<stop public="1"><x path="Bool"/></stop>
		<should_clear public="1"><x path="Bool"/></should_clear>
		<default_render_path public="1"><c path="phoenix.RenderPath"/></default_render_path>
		<render_path public="1"><c path="phoenix.RenderPath"/></render_path>
		<default_font public="1"><c path="phoenix.BitmapFont"/></default_font>
		<default_camera public="1"><c path="phoenix.Camera"/></default_camera>
		<default_batcher public="1"><c path="phoenix.Batcher"/></default_batcher>
		<default_shader_textured public="1"><c path="phoenix.Shader"/></default_shader_textured>
		<default_shader public="1"><c path="phoenix.Shader"/></default_shader>
		<batchers public="1"><c path="luxe.structures.BinarySearchTree">
	<x path="Int"/>
	<c path="phoenix.Batcher"/>
</c></batchers>
		<resource_manager public="1"><c path="phoenix.ResourceManager"/></resource_manager>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="phoenix.RendererStats" params="" file="/Users/Sven/dev/lab/luxe/phoenix/Renderer.hx" module="phoenix.Renderer">
		<toString public="1" set="method" line="372"><f a=""><c path="String"/></f></toString>
		<reset public="1" set="method" line="364"><f a=""><x path="Void"/></f></reset>
		<group_count public="1"><x path="Int"/></group_count>
		<draw_calls public="1"><x path="Int"/></draw_calls>
		<enabled_count public="1"><x path="Int"/></enabled_count>
		<static_batched_count public="1"><x path="Int"/></static_batched_count>
		<dynamic_batched_count public="1"><x path="Int"/></dynamic_batched_count>
		<geometry_count public="1"><x path="Int"/></geometry_count>
		<batchers public="1"><x path="Int"/></batchers>
		<new public="1" set="method" line="355"><f a=""><x path="Void"/></f></new>
	</class>
	<enum path="phoenix.ResourceType" params="" file="/Users/Sven/dev/lab/luxe/phoenix/Resource.hx" module="phoenix.Resource">
		<unknown/>
		<texture/>
		<shader/>
		<render_texture/>
		<font/>
	</enum>
	<class path="phoenix.ResourceStats" params="" file="/Users/Sven/dev/lab/luxe/phoenix/ResourceManager.hx" module="phoenix.ResourceManager">
		<reset public="1" set="method" line="27"><f a=""><x path="Void"/></f></reset>
		<toString public="1" set="method" line="16"><f a=""><c path="String"/></f></toString>
		<unknown public="1"><x path="Int"/></unknown>
		<shaders public="1"><x path="Int"/></shaders>
		<render_textures public="1"><x path="Int"/></render_textures>
		<textures public="1"><x path="Int"/></textures>
		<fonts public="1"><x path="Int"/></fonts>
		<resources public="1"><x path="Int"/></resources>
		<new public="1" set="method" line="9"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="phoenix.ResourceManager" params="" file="/Users/Sven/dev/lab/luxe/phoenix/ResourceManager.hx">
		<find public="1" set="method" line="159"><f a="id">
	<c path="String"/>
	<c path="phoenix.Resource"/>
</f></find>
		<clear public="1" set="method" line="134"><f a="?and_persistent">
	<x path="Bool"/>
	<x path="Void"/>
</f></clear>
		<find_font public="1" set="method" line="130"><f a="_name">
	<c path="String"/>
	<t path="Null"><c path="phoenix.BitmapFont"/></t>
</f></find_font>
		<find_shader public="1" set="method" line="127"><f a="_name">
	<c path="String"/>
	<t path="Null"><c path="phoenix.Shader"/></t>
</f></find_shader>
		<find_texture public="1" set="method" line="124"><f a="_name">
	<c path="String"/>
	<t path="Null"><c path="phoenix.Texture"/></t>
</f></find_texture>
		<find_render_texture public="1" set="method" line="121"><f a="_name">
	<c path="String"/>
	<t path="Null"><c path="phoenix.RenderTexture"/></t>
</f></find_render_texture>
		<cache public="1" set="method" line="107"><f a="res">
	<c path="phoenix.Resource"/>
	<x path="Void"/>
</f></cache>
		<uncache public="1" set="method" line="93"><f a="res">
	<c path="phoenix.Resource"/>
	<x path="Void"/>
</f></uncache>
		<remove public="1" set="method" line="74"><f a="res">
	<c path="phoenix.Resource"/>
	<x path="Void"/>
</f></remove>
		<add public="1" set="method" line="57"><f a="res">
	<c path="phoenix.Resource"/>
	<x path="Void"/>
</f></add>
		<stats public="1"><c path="phoenix.ResourceStats"/></stats>
		<fonts public="1"><x path="Map">
	<c path="String"/>
	<c path="phoenix.BitmapFont"/>
</x></fonts>
		<shaders public="1"><x path="Map">
	<c path="String"/>
	<c path="phoenix.Shader"/>
</x></shaders>
		<textures public="1"><x path="Map">
	<c path="String"/>
	<c path="phoenix.Texture"/>
</x></textures>
		<render_textures public="1"><x path="Map">
	<c path="String"/>
	<c path="phoenix.RenderTexture"/>
</x></render_textures>
		<resourcelist public="1"><c path="Array"><c path="phoenix.Resource"/></c></resourcelist>
		<new public="1" set="method" line="48"><f a=""><x path="Void"/></f></new>
	</class>
	<enum path="phoenix.UniformValueType" params="" file="/Users/Sven/dev/lab/luxe/phoenix/Shader.hx" module="phoenix.Shader">
		<vector4/>
		<vector3/>
		<vector2/>
		<unknown/>
		<texture/>
		<int/>
		<float/>
		<color/>
	</enum>
	<typedef path="phoenix.UniformValue" params="" file="/Users/Sven/dev/lab/luxe/phoenix/Shader.hx" module="phoenix.Shader"><a>
	<value><d/></value>
	<type><e path="phoenix.UniformValueType"/></type>
	<name><c path="String"/></name>
</a></typedef>
	<class path="phoenix.Shader" params="" file="/Users/Sven/dev/lab/luxe/phoenix/Shader.hx">
		<extends path="phoenix.Resource"/>
		<addError public="1" set="method" line="318"><f a="_error">
	<c path="String"/>
	<x path="Void"/>
</f></addError>
		<addLog public="1" set="method" line="314"><f a="_log">
	<c path="String"/>
	<x path="Void"/>
</f></addLog>
		<setUniformTexture public="1" set="method" line="308">
			<f a="uniform_name:value">
				<c path="String"/>
				<c path="phoenix.Texture"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</setUniformTexture>
		<setUniformColor public="1" set="method" line="305">
			<f a="uniform_name:value">
				<c path="String"/>
				<c path="phoenix.Color"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</setUniformColor>
		<setUniformVector4 public="1" set="method" line="302">
			<f a="uniform_name:value">
				<c path="String"/>
				<c path="phoenix.Vector"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</setUniformVector4>
		<setUniformVector3 public="1" set="method" line="299">
			<f a="uniform_name:value">
				<c path="String"/>
				<c path="phoenix.Vector"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</setUniformVector3>
		<setUniformVector2 public="1" set="method" line="296">
			<f a="uniform_name:value">
				<c path="String"/>
				<c path="phoenix.Vector"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</setUniformVector2>
		<setUniformFloat public="1" set="method" line="293">
			<f a="uniform_name:value">
				<c path="String"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</setUniformFloat>
		<setUniformInt public="1" set="method" line="290">
			<f a="uniform_name:value">
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</setUniformInt>
		<getUniform public="1" set="method" line="286">
			<f a="uniform_name">
				<c path="String"/>
				<t path="lime.gl.GLUniformLocation"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</getUniform>
		<apply_uniforms public="1" set="method" line="263">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</apply_uniforms>
		<load_from_string public="1" set="method" line="222"><f a="_vertex_source:_fragment_source:?_verbose">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></load_from_string>
		<destroy public="1" set="method" line="215"><f a=""><x path="Void"/></f></destroy>
		<drop public="1" set="method" line="210" override="1"><f a=""><x path="Void"/></f></drop>
		<link public="1" set="method" line="191"><f a=""><c path="lime.gl.GLProgram"/></f></link>
		<compile public="1" set="method" line="150"><f a="_type:_source:?_verbose">
	<x path="Int"/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="lime.gl.GLShader"/>
</f></compile>
		<set_uniform_texture public="1" set="method" line="136"><f a="_name:_value">
	<c path="String"/>
	<c path="phoenix.Texture"/>
	<x path="Void"/>
</f></set_uniform_texture>
		<set_uniform_color public="1" set="method" line="126"><f a="_name:_value">
	<c path="String"/>
	<c path="phoenix.Color"/>
	<x path="Void"/>
</f></set_uniform_color>
		<set_uniform_vector4 public="1" set="method" line="116"><f a="_name:_value">
	<c path="String"/>
	<c path="phoenix.Vector"/>
	<x path="Void"/>
</f></set_uniform_vector4>
		<set_uniform_vector3 public="1" set="method" line="106"><f a="_name:_value">
	<c path="String"/>
	<c path="phoenix.Vector"/>
	<x path="Void"/>
</f></set_uniform_vector3>
		<set_uniform_vector2 public="1" set="method" line="96"><f a="_name:_value">
	<c path="String"/>
	<c path="phoenix.Vector"/>
	<x path="Void"/>
</f></set_uniform_vector2>
		<set_uniform_float public="1" set="method" line="80"><f a="_name:_value">
	<c path="String"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set_uniform_float>
		<set_uniform_int public="1" set="method" line="65"><f a="_name:_value">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set_uniform_int>
		<deactivate public="1" set="method" line="61"><f a=""><x path="Void"/></f></deactivate>
		<activate public="1" set="method" line="51"><f a=""><x path="Void"/></f></activate>
		<uniform_textures><x path="Map">
	<c path="String"/>
	<c path="phoenix.Texture"/>
</x></uniform_textures>
		<uniforms public="1"><x path="Map">
	<c path="String"/>
	<d/>
</x></uniforms>
		<shader public="1"><c path="lime.gl.GLShader"/></shader>
		<program public="1"><c path="lime.gl.GLProgram"/></program>
		<frag_shader public="1"><d/></frag_shader>
		<vert_shader public="1"><d/></vert_shader>
		<log public="1"><c path="String"/></log>
		<errors public="1"><c path="String"/></errors>
		<new public="1" set="method" line="43"><f a="_manager">
	<c path="phoenix.ResourceManager"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="phoenix.FilterType" params="" file="/Users/Sven/dev/lab/luxe/phoenix/Texture.hx" module="phoenix.Texture">
		<nearest/>
		<linear/>
	</enum>
	<enum path="phoenix.ClampType" params="" file="/Users/Sven/dev/lab/luxe/phoenix/Texture.hx" module="phoenix.Texture">
		<repeat/>
		<mirror/>
		<edge/>
	</enum>
	<class path="phoenix.Vector" params="" file="/Users/Sven/dev/lab/luxe/phoenix/Vector.hx">
		<Add public="1" set="method" line="88" static="1"><f a="a:b">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></Add>
		<Subtract public="1" set="method" line="96" static="1"><f a="a:b">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></Subtract>
		<MultiplyVector public="1" set="method" line="104" static="1"><f a="a:b">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></MultiplyVector>
		<DivideVector public="1" set="method" line="112" static="1"><f a="a:b">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></DivideVector>
		<Multiply public="1" set="method" line="120" static="1"><f a="a:b">
	<c path="phoenix.Vector"/>
	<x path="Float"/>
	<c path="phoenix.Vector"/>
</f></Multiply>
		<Divide public="1" set="method" line="128" static="1"><f a="a:b">
	<c path="phoenix.Vector"/>
	<x path="Float"/>
	<c path="phoenix.Vector"/>
</f></Divide>
		<AddScalar public="1" set="method" line="136" static="1"><f a="a:b">
	<c path="phoenix.Vector"/>
	<x path="Float"/>
	<c path="phoenix.Vector"/>
</f></AddScalar>
		<SubtractScalar public="1" set="method" line="144" static="1"><f a="a:b">
	<c path="phoenix.Vector"/>
	<x path="Float"/>
	<c path="phoenix.Vector"/>
</f></SubtractScalar>
		<Cross public="1" set="method" line="152" static="1"><f a="a:b">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></Cross>
		<RotationTo public="1" set="method" line="160" static="1"><f a="a:b">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
	<x path="Float"/>
</f></RotationTo>
		<setEulerFromQuaternion public="1" set="method" line="407"><f a="q:?order">
	<c path="phoenix.Quaternion"/>
	<c path="String"/>
	<c path="phoenix.Vector"/>
</f></setEulerFromQuaternion>
		<setEulerFromRotationMatrix public="1" set="method" line="380"><f a="m:?order">
	<c path="phoenix.Matrix4"/>
	<c path="String"/>
	<c path="phoenix.Vector"/>
</f></setEulerFromRotationMatrix>
		<transformDirection public="1" set="method" line="365"><f a="m">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Vector"/>
</f></transformDirection>
		<applyMatrix4 public="1" set="method" line="349"><f a="_m">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Vector"/>
</f></applyMatrix4>
		<applyProjection public="1" set="method" line="335"><f a="m">
	<c path="phoenix.Matrix4"/>
	<c path="phoenix.Vector"/>
</f></applyProjection>
		<applyQuaternion public="1" set="method" line="315"><f a="q">
	<c path="phoenix.Quaternion"/>
	<c path="phoenix.Vector"/>
</f></applyQuaternion>
		<rotationTo public="1" set="method" line="307"><f a="other">
	<c path="phoenix.Vector"/>
	<x path="Float"/>
</f></rotationTo>
		<get_inverted set="method" line="301"><f a=""><c path="phoenix.Vector"/></f></get_inverted>
		<set_z set="method" line="295"><f a="_z">
	<x path="Float"/>
	<x path="Float"/>
</f></set_z>
		<set_y set="method" line="289"><f a="_y">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<set_x set="method" line="283"><f a="_x">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<get_normalized set="method" line="279"><f a=""><c path="phoenix.Vector"/></f></get_normalized>
		<get_length set="method" line="275"><f a=""><x path="Float"/></f></get_length>
		<set_length set="method" line="271"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_length>
		<divideScalar public="1" set="method" line="252"><f a="v">
	<x path="Float"/>
	<c path="phoenix.Vector"/>
</f></divideScalar>
		<multiplyScalar public="1" set="method" line="242"><f a="v">
	<x path="Float"/>
	<c path="phoenix.Vector"/>
</f></multiplyScalar>
		<subtractScalar public="1" set="method" line="232"><f a="v">
	<x path="Float"/>
	<c path="phoenix.Vector"/>
</f></subtractScalar>
		<addScalar public="1" set="method" line="222"><f a="v">
	<x path="Float"/>
	<c path="phoenix.Vector"/>
</f></addScalar>
		<divide public="1" set="method" line="208"><f a="other">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></divide>
		<multiply public="1" set="method" line="194"><f a="other">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></multiply>
		<subtract public="1" set="method" line="180"><f a="other">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></subtract>
		<add public="1" set="method" line="166"><f a="other">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></add>
		<cross public="1" set="method" line="76"><f a="a:b">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></cross>
		<dot public="1" set="method" line="69"><f a="other">
	<c path="phoenix.Vector"/>
	<x path="Float"/>
</f></dot>
		<normalize public="1" set="method" line="64"><f a=""><c path="phoenix.Vector"/></f></normalize>
		<clone public="1" set="method" line="60"><f a=""><c path="phoenix.Vector"/></f></clone>
		<equals public="1" set="method" line="56"><f a="other">
	<c path="phoenix.Vector"/>
	<x path="Bool"/>
</f></equals>
		<toString public="1" set="method" line="52"><f a=""><c path="String"/></f></toString>
		<set public="1" set="method" line="30"><f a="?_x:?_y:?_z:?_w">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="phoenix.Vector"/>
</f></set>
		<listen_z public="1">
			<f a="">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":isVar"/></meta>
		</listen_z>
		<listen_y public="1">
			<f a="">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":isVar"/></meta>
		</listen_y>
		<listen_x public="1">
			<f a="">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":isVar"/></meta>
		</listen_x>
		<inverted public="1" get="accessor" set="null">
			<c path="phoenix.Vector"/>
			<meta><m n=":isVar"/></meta>
		</inverted>
		<normalized public="1" get="accessor" set="null">
			<c path="phoenix.Vector"/>
			<meta><m n=":isVar"/></meta>
		</normalized>
		<length public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</length>
		<w public="1">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</w>
		<z public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</z>
		<y public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</y>
		<x public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</x>
		<new public="1" set="method" line="21"><f a="?_x:?_y:?_z:?_w">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<abstract path="phoenix.Vec" params="" file="/Users/Sven/dev/lab/luxe/phoenix/Vector.hx" module="phoenix.Vector">
		<from><c path="phoenix.Vector"/></from>
		<to><c path="phoenix.Vector"/></to>
	</abstract>
	<class path="phoenix._Vector.Vec_Impl_" params="" file="/Users/Sven/dev/lab/luxe/phoenix/Vector.hx" private="1" module="phoenix.Vector">
		<_new public="1" get="inline" set="null" line="430" static="1">
			<f a="?_x:?_y:?_z:?_w">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="phoenix.Vector"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<_multiply public="1" set="method" line="434" static="1">
			<f a="lhs:rhs">
				<x path="phoenix.Vec"/>
				<x path="phoenix.Vec"/>
				<x path="phoenix.Vec"/>
			</f>
			<meta>
				<m n=":communitative"/>
				<m n=":op"><e>'???'</e></m>
			</meta>
		</_multiply>
		<_multiply_scalar public="1" set="method" line="437" static="1">
			<f a="lhs:rhs">
				<x path="phoenix.Vec"/>
				<x path="Float"/>
				<x path="phoenix.Vec"/>
			</f>
			<meta>
				<m n=":communitative"/>
				<m n=":op"><e>'???'</e></m>
			</meta>
		</_multiply_scalar>
		<_multiply_scalar_int public="1" set="method" line="440" static="1">
			<f a="lhs:rhs">
				<x path="phoenix.Vec"/>
				<x path="Int"/>
				<x path="phoenix.Vec"/>
			</f>
			<meta>
				<m n=":communitative"/>
				<m n=":op"><e>'???'</e></m>
			</meta>
		</_multiply_scalar_int>
		<_divide public="1" set="method" line="444" static="1">
			<f a="lhs:rhs">
				<x path="phoenix.Vec"/>
				<x path="phoenix.Vec"/>
				<x path="phoenix.Vec"/>
			</f>
			<meta>
				<m n=":communitative"/>
				<m n=":op"><e>'???'</e></m>
			</meta>
		</_divide>
		<_divide_scalar public="1" set="method" line="447" static="1">
			<f a="lhs:rhs">
				<x path="phoenix.Vec"/>
				<x path="Float"/>
				<x path="phoenix.Vec"/>
			</f>
			<meta>
				<m n=":communitative"/>
				<m n=":op"><e>'???'</e></m>
			</meta>
		</_divide_scalar>
		<_divide_scalar_int public="1" set="method" line="450" static="1">
			<f a="lhs:rhs">
				<x path="phoenix.Vec"/>
				<x path="Int"/>
				<x path="phoenix.Vec"/>
			</f>
			<meta>
				<m n=":communitative"/>
				<m n=":op"><e>'???'</e></m>
			</meta>
		</_divide_scalar_int>
		<_add public="1" set="method" line="454" static="1">
			<f a="lhs:rhs">
				<x path="phoenix.Vec"/>
				<x path="phoenix.Vec"/>
				<x path="phoenix.Vec"/>
			</f>
			<meta>
				<m n=":communitative"/>
				<m n=":op"><e>'???'</e></m>
			</meta>
		</_add>
		<_add_scalar public="1" set="method" line="457" static="1">
			<f a="lhs:rhs">
				<x path="phoenix.Vec"/>
				<x path="Float"/>
				<x path="phoenix.Vec"/>
			</f>
			<meta>
				<m n=":communitative"/>
				<m n=":op"><e>'???'</e></m>
			</meta>
		</_add_scalar>
		<_add_scalar_int public="1" set="method" line="460" static="1">
			<f a="lhs:rhs">
				<x path="phoenix.Vec"/>
				<x path="Int"/>
				<x path="phoenix.Vec"/>
			</f>
			<meta>
				<m n=":communitative"/>
				<m n=":op"><e>'???'</e></m>
			</meta>
		</_add_scalar_int>
		<_subtract public="1" set="method" line="464" static="1">
			<f a="lhs:rhs">
				<x path="phoenix.Vec"/>
				<x path="phoenix.Vec"/>
				<x path="phoenix.Vec"/>
			</f>
			<meta>
				<m n=":communitative"/>
				<m n=":op"><e>'???'</e></m>
			</meta>
		</_subtract>
		<_subtract_scalar public="1" set="method" line="467" static="1">
			<f a="lhs:rhs">
				<x path="phoenix.Vec"/>
				<x path="Float"/>
				<x path="phoenix.Vec"/>
			</f>
			<meta>
				<m n=":communitative"/>
				<m n=":op"><e>'???'</e></m>
			</meta>
		</_subtract_scalar>
		<_subtract_scalar_int public="1" set="method" line="470" static="1">
			<f a="lhs:rhs">
				<x path="phoenix.Vec"/>
				<x path="Int"/>
				<x path="phoenix.Vec"/>
			</f>
			<meta>
				<m n=":communitative"/>
				<m n=":op"><e>'???'</e></m>
			</meta>
		</_subtract_scalar_int>
	</class>
	<class path="phoenix.defaults.FontBytes" params="" file="/Users/Sven/dev/lab/luxe/phoenix/defaults/FontBytes.hx"><data public="1" set="method" line="5" static="1"><f a=""><c path="String"/></f></data></class>
	<class path="phoenix.defaults.FontString" params="" file="/Users/Sven/dev/lab/luxe/phoenix/defaults/FontString.hx"><data public="1" set="method" line="5" static="1"><f a=""><c path="String"/></f></data></class>
	<class path="phoenix.defaults.Shaders" params="" file="/Users/Sven/dev/lab/luxe/phoenix/defaults/Shaders.hx">
		<vertex_shader public="1" set="method" line="5" static="1"><f a=""><c path="String"/></f></vertex_shader>
		<fragment_textured public="1" set="method" line="32" static="1"><f a=""><c path="String"/></f></fragment_textured>
		<fragment_untextured public="1" set="method" line="61" static="1"><f a=""><c path="String"/></f></fragment_untextured>
	</class>
	<class path="phoenix.geometry.Geometry" params="" file="/Users/Sven/dev/lab/luxe/phoenix/geometry/Geometry.hx">
		<set_clip_rect public="1" set="method" line="474"><f a="val">
	<c path="phoenix.Rectangle"/>
	<c path="phoenix.Rectangle"/>
</f></set_clip_rect>
		<get_clip_rect public="1" set="method" line="468"><f a=""><c path="phoenix.Rectangle"/></f></get_clip_rect>
		<set_clip public="1" set="method" line="454"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_clip>
		<get_clip public="1" set="method" line="448"><f a=""><x path="Bool"/></f></get_clip>
		<set_group public="1" set="method" line="434"><f a="val">
	<x path="Int"/>
	<x path="Int"/>
</f></set_group>
		<get_group public="1" set="method" line="428"><f a=""><x path="Int"/></f></get_group>
		<set_depth public="1" set="method" line="414"><f a="val">
	<x path="Float"/>
	<x path="Float"/>
</f></set_depth>
		<get_depth public="1" set="method" line="407"><f a=""><x path="Float"/></f></get_depth>
		<set_shader public="1" set="method" line="393"><f a="val">
	<c path="phoenix.Shader"/>
	<c path="phoenix.Shader"/>
</f></set_shader>
		<get_shader public="1" set="method" line="387"><f a=""><c path="phoenix.Shader"/></f></get_shader>
		<set_color public="1" set="method" line="375"><f a="val">
	<c path="phoenix.Color"/>
	<c path="phoenix.Color"/>
</f></set_color>
		<set_enabled public="1" set="method" line="367"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_enabled>
		<set_texture public="1" set="method" line="353"><f a="val">
	<c path="phoenix.Texture"/>
	<c path="phoenix.Texture"/>
</f></set_texture>
		<get_texture public="1" set="method" line="347"><f a=""><c path="phoenix.Texture"/></f></get_texture>
		<set_primitive_type set="method" line="333"><f a="val">
	<e path="phoenix.PrimitiveType"/>
	<e path="phoenix.PrimitiveType"/>
</f></set_primitive_type>
		<get_primitive_type set="method" line="327"><f a=""><e path="phoenix.PrimitiveType"/></f></get_primitive_type>
		<refresh set="method" line="281"><f a=""><x path="Void"/></f></refresh>
		<get_scale public="1" set="method" line="273"><f a=""><c path="phoenix.Vector"/></f></get_scale>
		<set_scale public="1" set="method" line="263"><f a="_scale">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></set_scale>
		<get_rotation public="1" set="method" line="257"><f a=""><c path="phoenix.Quaternion"/></f></get_rotation>
		<set_rotation public="1" set="method" line="247"><f a="_rotation">
	<c path="phoenix.Quaternion"/>
	<c path="phoenix.Quaternion"/>
</f></set_rotation>
		<get_pos public="1" set="method" line="241"><f a=""><c path="phoenix.Vector"/></f></get_pos>
		<set_pos public="1" set="method" line="235"><f a="_position">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></set_pos>
		<set_origin public="1" set="method" line="229"><f a="_origin">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></set_origin>
		<translate public="1" set="method" line="223"><f a="_offset">
	<c path="phoenix.Vector"/>
	<x path="Void"/>
</f></translate>
		<batch public="1" set="method" line="178"><f a="vertlist:tcoordlist:colorlist:normallist">
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></batch>
		<remove public="1" set="method" line="172"><f a="v">
	<c path="phoenix.geometry.Vertex"/>
	<x path="Void"/>
</f></remove>
		<add public="1" set="method" line="166"><f a="v">
	<c path="phoenix.geometry.Vertex"/>
	<x path="Void"/>
</f></add>
		<compare public="1" set="method" line="160"><f a="other">
	<c path="phoenix.geometry.Geometry"/>
	<x path="Int"/>
</f></compare>
		<drop public="1" set="method" line="146"><f a="?remove">
	<x path="Bool"/>
	<x path="Void"/>
</f></drop>
		<str public="1" set="method" line="138"><f a=""><x path="Void"/></f></str>
		<short_id public="1" set="method" line="132"><f a=""><c path="String"/></f></short_id>
		<_final_vert_position><c path="phoenix.Vector"/></_final_vert_position>
		<matrix public="1"><c path="phoenix.Matrix4"/></matrix>
		<origin public="1" set="accessor">
			<c path="phoenix.Vector"/>
			<meta><m n=":isVar"/></meta>
		</origin>
		<scale public="1" get="accessor" set="accessor">
			<c path="phoenix.Vector"/>
			<meta><m n=":isVar"/></meta>
		</scale>
		<rotation public="1" get="accessor" set="accessor">
			<c path="phoenix.Quaternion"/>
			<meta><m n=":isVar"/></meta>
		</rotation>
		<pos public="1" get="accessor" set="accessor">
			<c path="phoenix.Vector"/>
			<meta><m n=":isVar"/></meta>
		</pos>
		<color public="1" set="accessor">
			<c path="phoenix.Color"/>
			<meta><m n=":isVar"/></meta>
		</color>
		<immediate public="1">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</immediate>
		<enabled public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</enabled>
		<dirty_clip><x path="Bool"/></dirty_clip>
		<dirty_depth><x path="Bool"/></dirty_depth>
		<dirty_group><x path="Bool"/></dirty_group>
		<dirty_shader><x path="Bool"/></dirty_shader>
		<dirty_texture><x path="Bool"/></dirty_texture>
		<dirty_primitive_type><x path="Bool"/></dirty_primitive_type>
		<shadow_clip><x path="Bool"/></shadow_clip>
		<shadow_depth><x path="Float"/></shadow_depth>
		<shadow_group><x path="Int"/></shadow_group>
		<shadow_shader><c path="phoenix.Shader"/></shadow_shader>
		<shadow_texture><c path="phoenix.Texture"/></shadow_texture>
		<shadow_primitive_type><e path="phoenix.PrimitiveType"/></shadow_primitive_type>
		<clip_rect public="1" get="accessor" set="accessor">
			<c path="phoenix.Rectangle"/>
			<meta><m n=":isVar"/></meta>
		</clip_rect>
		<clip public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</clip>
		<group public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":isVar"/></meta>
		</group>
		<depth public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</depth>
		<shader public="1" get="accessor" set="accessor">
			<c path="phoenix.Shader"/>
			<meta><m n=":isVar"/></meta>
		</shader>
		<texture public="1" get="accessor" set="accessor">
			<c path="phoenix.Texture"/>
			<meta><m n=":isVar"/></meta>
		</texture>
		<primitive_type public="1" get="accessor" set="accessor">
			<e path="phoenix.PrimitiveType"/>
			<meta><m n=":isVar"/></meta>
		</primitive_type>
		<id public="1"><c path="String"/></id>
		<uuid public="1"><c path="String"/></uuid>
		<dropped public="1"><x path="Bool"/></dropped>
		<state public="1"><c path="phoenix.geometry.GeometryState"/></state>
		<batchers public="1"><c path="Array"><c path="phoenix.Batcher"/></c></batchers>
		<added public="1"><x path="Bool"/></added>
		<static_normal_buffer public="1"><c path="lime.gl.GLBuffer"/></static_normal_buffer>
		<static_vcolor_buffer public="1"><c path="lime.gl.GLBuffer"/></static_vcolor_buffer>
		<static_tcoord_buffer public="1"><c path="lime.gl.GLBuffer"/></static_tcoord_buffer>
		<static_vertex_buffer public="1"><c path="lime.gl.GLBuffer"/></static_vertex_buffer>
		<dirty public="1"><x path="Bool"/></dirty>
		<submitted public="1"><x path="Bool"/></submitted>
		<locked public="1"><x path="Bool"/></locked>
		<vertices public="1"><c path="Array"><c path="phoenix.geometry.Vertex"/></c></vertices>
		<new public="1" set="method" line="85"><f a="options">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.geometry.CircleGeometry" params="" file="/Users/Sven/dev/lab/luxe/phoenix/geometry/CircleGeometry.hx">
		<extends path="phoenix.geometry.Geometry"/>
		<set public="1" set="method" line="29"><f a="_circle:_steps">
	<c path="phoenix.Circle"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
		<new public="1" set="method" line="12"><f a="options">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="phoenix.geometry.ComplexQuad" params="" file="/Users/Sven/dev/lab/luxe/phoenix/geometry/ComplexGeometry.hx" module="phoenix.geometry.ComplexGeometry"><a>
	<verts><c path="Array"><c path="phoenix.geometry.Vertex"/></c></verts>
	<uuid><c path="String"/></uuid>
	<flipy><x path="Bool"/></flipy>
	<flipx><x path="Bool"/></flipx>
	<_uv_cache><c path="phoenix.Rectangle"/></_uv_cache>
</a></typedef>
	<class path="phoenix.geometry.ComplexGeometry" params="" file="/Users/Sven/dev/lab/luxe/phoenix/geometry/ComplexGeometry.hx">
		<extends path="phoenix.geometry.Geometry"/>
		<quad_flipy public="1" set="method" line="345"><f a="_quad_id:_flip">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></quad_flipy>
		<quad_flipx public="1" set="method" line="334"><f a="_quad_id:_flip">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></quad_flipx>
		<quad_uv public="1" set="method" line="318"><f a="_quad_id:_uv">
	<c path="String"/>
	<c path="phoenix.Rectangle"/>
	<x path="Void"/>
</f></quad_uv>
		<quad_uv_space public="1" set="method" line="240"><f a="_quad_id:_uv">
	<c path="String"/>
	<c path="phoenix.Rectangle"/>
	<x path="Void"/>
</f></quad_uv_space>
		<quad_alpha public="1" set="method" line="225"><f a="_quad_id:_a">
	<c path="String"/>
	<x path="Float"/>
	<x path="Void"/>
</f></quad_alpha>
		<quad_color public="1" set="method" line="210"><f a="_quad_id:_c">
	<c path="String"/>
	<c path="phoenix.Color"/>
	<x path="Void"/>
</f></quad_color>
		<quad_pos public="1" set="method" line="176"><f a="_quad_id:_p">
	<c path="String"/>
	<c path="phoenix.Vector"/>
	<x path="Void"/>
</f></quad_pos>
		<quad_resize public="1" set="method" line="155"><f a="_quad_id:_quad">
	<c path="String"/>
	<c path="phoenix.Rectangle"/>
	<x path="Void"/>
</f></quad_resize>
		<quad_show public="1" set="method" line="135"><f a="_quad_id">
	<c path="String"/>
	<x path="Void"/>
</f></quad_show>
		<quad_hide public="1" set="method" line="114"><f a="_quad_id">
	<c path="String"/>
	<x path="Void"/>
</f></quad_hide>
		<quad_remove public="1" set="method" line="92"><f a="_quad_id">
	<c path="String"/>
	<x path="Void"/>
</f></quad_remove>
		<quad_add public="1" set="method" line="40"><f a="_options">
	<d/>
	<c path="String"/>
</f></quad_add>
		<quads public="1"><x path="Map">
	<c path="String"/>
	<t path="phoenix.geometry.ComplexQuad"/>
</x></quads>
		<new public="1" set="method" line="31"><f a="_options">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.geometry.CompositeGeometry" params="" file="/Users/Sven/dev/lab/luxe/phoenix/geometry/CompositeGeometry.hx">
		<extends path="phoenix.geometry.Geometry"/>
		<set_enabled public="1" set="method" line="161" override="1"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_enabled>
		<set_clip_rect public="1" set="method" line="152" override="1"><f a="val">
	<c path="phoenix.Rectangle"/>
	<c path="phoenix.Rectangle"/>
</f></set_clip_rect>
		<set_clip public="1" set="method" line="143" override="1"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_clip>
		<set_group public="1" set="method" line="134" override="1"><f a="val">
	<x path="Int"/>
	<x path="Int"/>
</f></set_group>
		<set_depth public="1" set="method" line="125" override="1"><f a="val">
	<x path="Float"/>
	<x path="Float"/>
</f></set_depth>
		<set_texture public="1" set="method" line="116" override="1"><f a="val">
	<c path="phoenix.Texture"/>
	<c path="phoenix.Texture"/>
</f></set_texture>
		<set_shader public="1" set="method" line="107" override="1"><f a="val">
	<c path="phoenix.Shader"/>
	<c path="phoenix.Shader"/>
</f></set_shader>
		<set_primitive_type public="1" set="method" line="98" override="1"><f a="val">
	<e path="phoenix.PrimitiveType"/>
	<e path="phoenix.PrimitiveType"/>
</f></set_primitive_type>
		<set_color public="1" set="method" line="89" override="1"><f a="_color">
	<c path="phoenix.Color"/>
	<c path="phoenix.Color"/>
</f></set_color>
		<set_pos public="1" set="method" line="80" override="1"><f a="_position">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></set_pos>
		<set_origin public="1" set="method" line="71" override="1"><f a="_origin">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
</f></set_origin>
		<translate public="1" set="method" line="63" override="1"><f a="_offset">
	<c path="phoenix.Vector"/>
	<x path="Void"/>
</f></translate>
		<drop public="1" set="method" line="53" override="1"><f a="?remove">
	<x path="Bool"/>
	<x path="Void"/>
</f></drop>
		<remove_geometry public="1" set="method" line="47"><f a="g">
	<c path="phoenix.geometry.Geometry"/>
	<x path="Void"/>
</f></remove_geometry>
		<add_geometry public="1" set="method" line="41"><f a="g">
	<c path="phoenix.geometry.Geometry"/>
	<x path="Void"/>
</f></add_geometry>
		<has_geometry public="1" set="method" line="35"><f a="g">
	<c path="phoenix.geometry.Geometry"/>
	<x path="Bool"/>
</f></has_geometry>
		<replace public="1" set="method" line="27"><f a="_geometry">
	<c path="Array"><c path="phoenix.geometry.Geometry"/></c>
	<x path="Void"/>
</f></replace>
		<clear public="1" set="method" line="20"><f a=""><x path="Void"/></f></clear>
		<geometry public="1"><c path="Array"><c path="phoenix.geometry.Geometry"/></c></geometry>
		<new public="1" set="method" line="12"><f a="?options">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.geometry.GeometryState" params="" file="/Users/Sven/dev/lab/luxe/phoenix/geometry/GeometryState.hx">
		<set_clip_rect public="1" set="method" line="196"><f a="val">
	<c path="phoenix.Rectangle"/>
	<c path="phoenix.Rectangle"/>
</f></set_clip_rect>
		<set_clip public="1" set="method" line="191"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_clip>
		<set_group public="1" set="method" line="186"><f a="val">
	<x path="Int"/>
	<x path="Int"/>
</f></set_group>
		<set_depth public="1" set="method" line="182"><f a="val">
	<x path="Float"/>
	<x path="Float"/>
</f></set_depth>
		<set_shader public="1" set="method" line="177"><f a="val">
	<c path="phoenix.Shader"/>
	<c path="phoenix.Shader"/>
</f></set_shader>
		<set_texture public="1" set="method" line="172"><f a="val">
	<c path="phoenix.Texture"/>
	<c path="phoenix.Texture"/>
</f></set_texture>
		<set_primitive_type public="1" set="method" line="167"><f a="val">
	<e path="phoenix.PrimitiveType"/>
	<e path="phoenix.PrimitiveType"/>
</f></set_primitive_type>
		<update public="1" set="method" line="107"><f a="other">
	<c path="phoenix.geometry.GeometryState"/>
	<x path="Void"/>
</f></update>
		<ttrace public="1" set="method" line="102"><f a="v">
	<d/>
	<x path="Void"/>
</f></ttrace>
		<compare public="1" set="method" line="73"><f a="other">
	<c path="phoenix.geometry.GeometryState"/>
	<x path="Int"/>
</f></compare>
		<clean public="1" set="method" line="68"><f a=""><x path="Void"/></f></clean>
		<str public="1" set="method" line="51"><f a=""><x path="Void"/></f></str>
		<clone public="1" set="method" line="36"><f a=""><c path="phoenix.geometry.GeometryState"/></f></clone>
		<log public="1"><x path="Bool"/></log>
		<clip_rect public="1" set="accessor">
			<c path="phoenix.Rectangle"/>
			<meta><m n=":isVar"/></meta>
		</clip_rect>
		<clip public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</clip>
		<group public="1" set="accessor">
			<x path="Int"/>
			<meta><m n=":isVar"/></meta>
		</group>
		<depth public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</depth>
		<texture public="1" set="accessor">
			<c path="phoenix.Texture"/>
			<meta><m n=":isVar"/></meta>
		</texture>
		<shader public="1" set="accessor">
			<c path="phoenix.Shader"/>
			<meta><m n=":isVar"/></meta>
		</shader>
		<primitive_type public="1" set="accessor">
			<e path="phoenix.PrimitiveType"/>
			<meta><m n=":isVar"/></meta>
		</primitive_type>
		<dirty public="1"><x path="Bool"/></dirty>
		<new public="1" set="method" line="22"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="phoenix.geometry.LineGeometry" params="" file="/Users/Sven/dev/lab/luxe/phoenix/geometry/LineGeometry.hx">
		<extends path="phoenix.geometry.Geometry"/>
		<set public="1" set="method" line="48"><f a="options">
	<d/>
	<x path="Void"/>
</f></set>
		<set_p1 public="1" set="method" line="38"><f a="_p">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_p1>
		<set_p0 public="1" set="method" line="28"><f a="_p">
	<t path="luxe.Vector"/>
	<t path="luxe.Vector"/>
</f></set_p0>
		<p1 public="1" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</p1>
		<p0 public="1" set="accessor">
			<t path="luxe.Vector"/>
			<meta><m n=":isVar"/></meta>
		</p0>
		<new public="1" set="method" line="13"><f a="options">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.geometry.PlaneGeometry" params="" file="/Users/Sven/dev/lab/luxe/phoenix/geometry/PlaneGeometry.hx">
		<extends path="phoenix.geometry.Geometry"/>
		<set_flipy public="1" set="method" line="193"><f a="_val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_flipy>
		<set_flipx public="1" set="method" line="182"><f a="_val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_flipx>
		<set public="1" set="method" line="124"><f a="quad:y">
	<t path="luxe.Rectangle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set>
		<uv_space public="1" set="method" line="55"><f a="_rect">
	<t path="luxe.Rectangle"/>
	<x path="Void"/>
</f></uv_space>
		<uv public="1" set="method" line="39"><f a="_rect">
	<t path="luxe.Rectangle"/>
	<x path="Void"/>
</f></uv>
		<is_set><x path="Bool"/></is_set>
		<_uv_cache><t path="luxe.Rectangle"/></_uv_cache>
		<flipy public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</flipy>
		<flipx public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</flipx>
		<new public="1" set="method" line="18"><f a="options">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.geometry.QuadGeometry" params="" file="/Users/Sven/dev/lab/luxe/phoenix/geometry/QuadGeometry.hx">
		<extends path="phoenix.geometry.Geometry"/>
		<set_flipy public="1" set="method" line="205"><f a="_val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_flipy>
		<set_flipx public="1" set="method" line="194"><f a="_val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_flipx>
		<set public="1" set="method" line="136"><f a="quad">
	<t path="luxe.Rectangle"/>
	<x path="Void"/>
</f></set>
		<resize public="1" set="method" line="124"><f a="quad">
	<t path="luxe.Rectangle"/>
	<x path="Void"/>
</f></resize>
		<uv_space public="1" set="method" line="55"><f a="_rect">
	<t path="luxe.Rectangle"/>
	<x path="Void"/>
</f></uv_space>
		<uv public="1" set="method" line="39"><f a="_rect">
	<t path="luxe.Rectangle"/>
	<x path="Void"/>
</f></uv>
		<is_set><x path="Bool"/></is_set>
		<_uv_cache><t path="luxe.Rectangle"/></_uv_cache>
		<flipy public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</flipy>
		<flipx public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</flipx>
		<new public="1" set="method" line="18"><f a="options">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.geometry.RectangleGeometry" params="" file="/Users/Sven/dev/lab/luxe/phoenix/geometry/RectangleGeometry.hx">
		<extends path="phoenix.geometry.Geometry"/>
		<set public="1" set="method" line="15"><f a="options">
	<d/>
	<x path="Void"/>
</f></set>
		<new public="1" set="method" line="10"><f a="options">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.geometry.RingGeometry" params="" file="/Users/Sven/dev/lab/luxe/phoenix/geometry/RingGeometry.hx">
		<extends path="phoenix.geometry.CircleGeometry"/>
		<new public="1" set="method" line="12"><f a="options">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.geometry.TextureCoord" params="" file="/Users/Sven/dev/lab/luxe/phoenix/geometry/TextureCoord.hx">
		<toString public="1" set="method" line="16"><f a=""><c path="String"/></f></toString>
		<w public="1"><x path="Float"/></w>
		<v public="1"><x path="Float"/></v>
		<u public="1"><x path="Float"/></u>
		<new public="1" set="method" line="10"><f a="?_u:?_v:?_w">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="phoenix.geometry.UV" params="" file="/Users/Sven/dev/lab/luxe/phoenix/geometry/Vertex.hx" module="phoenix.geometry.Vertex">
		<zero/>
		<two/>
		<three/>
		<one/>
	</enum>
	<class path="phoenix.geometry.Vertex" params="" file="/Users/Sven/dev/lab/luxe/phoenix/geometry/Vertex.hx">
		<get_tcoord_array public="1" set="method" line="43"><f a="ind">
	<x path="Int"/>
	<c path="lime.utils.Float32Array"/>
</f></get_tcoord_array>
		<get_vert_array public="1" set="method" line="40"><f a=""><c path="lime.utils.Float32Array"/></f></get_vert_array>
		<normal public="1"><c path="phoenix.Vector"/></normal>
		<uv public="1"><x path="Map">
	<x path="Int"/>
	<c path="phoenix.geometry.TextureCoord"/>
</x></uv>
		<color public="1"><c path="phoenix.Color"/></color>
		<pos public="1"><c path="phoenix.Vector"/></pos>
		<new public="1" set="method" line="29"><f a="_pos:?_normal:?_color">
	<c path="phoenix.Vector"/>
	<c path="phoenix.Vector"/>
	<c path="phoenix.Color"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="phoenix.utils.Maths" params="" file="/Users/Sven/dev/lab/luxe/phoenix/utils/Maths.hx">
		<DEG2RAD public="1" line="13" static="1"><x path="Float"/></DEG2RAD>
		<RAD2DEG public="1" line="14" static="1"><x path="Float"/></RAD2DEG>
		<fixed public="1" set="method" line="16" static="1"><f a="value:precision">
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
</f></fixed>
		<clamp public="1" set="method" line="21" static="1"><f a="value:a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></clamp>
		<clampBottom public="1" set="method" line="27" static="1"><f a="value:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></clampBottom>
		<mapLinear public="1" set="method" line="33" static="1"><f a="value:a1:a2:b1:b2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></mapLinear>
		<smoothstep public="1" set="method" line="39" static="1"><f a="x:min:max">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></smoothstep>
		<smootherstep public="1" set="method" line="49" static="1"><f a="x:min:max">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></smootherstep>
		<random16 public="1" set="method" line="59" static="1"><f a=""><x path="Float"/></f></random16>
		<randInt public="1" set="method" line="65" static="1"><f a="low:high">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></randInt>
		<randFloat public="1" set="method" line="71" static="1"><f a="low:high">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></randFloat>
		<randFloatSpread public="1" set="method" line="77" static="1"><f a="range">
	<x path="Float"/>
	<x path="Float"/>
</f></randFloatSpread>
		<sign public="1" set="method" line="83" static="1"><f a="x">
	<x path="Float"/>
	<x path="Int"/>
</f></sign>
		<degToRad public="1" set="method" line="89" static="1"><f a="deg">
	<x path="Float"/>
	<x path="Float"/>
</f></degToRad>
		<radToDeg public="1" set="method" line="95" static="1"><f a="rad">
	<x path="Float"/>
	<x path="Float"/>
</f></radToDeg>
		<haxe_doc>* 
 * @author Three.js Project (http://threejs.org)
 * @author dcm</haxe_doc>
	</class>
	<class path="sys.io.File" params="" file="/usr/lib/haxe/std/cpp/_std/sys/io/File.hx">
		<saveContent public="1" set="method" line="37" static="1"><f a="path:content">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></saveContent>
		<write public="1" set="method" line="53" static="1"><f a="path:?binary">
	<c path="String"/>
	<x path="Bool"/>
	<c path="sys.io.FileOutput"/>
</f></write>
		<file_open line="70" static="1"><f a=":">
	<c path="String"/>
	<c path="String"/>
	<unknown/>
</f></file_open>
		<haxe_doc>API for reading and writing to files.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.io.FileOutput" params="" file="/usr/lib/haxe/std/cpp/_std/sys/io/FileOutput.hx">
		<extends path="haxe.io.Output"/>
		<file_close line="59" static="1"><f a="">
	<d/>
	<unknown/>
</f></file_close>
		<file_write line="64" static="1"><f a=":::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></file_write>
		<file_write_char line="65" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<unknown/>
</f></file_write_char>
		<close public="1" set="method" line="46" override="1"><f a=""><x path="Void"/></f></close>
		<writeBytes public="1" set="method" line="38" override="1"><f a="s:p:l">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<writeByte public="1" set="method" line="34" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<__f><d/></__f>
		<new set="method" line="30"><f a="f">
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Use [sys.io.File.write] to create a [FileOutput]</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
</haxe>